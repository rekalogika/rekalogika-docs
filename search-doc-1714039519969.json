{"searchDocs":[{"title":"Use Cases: Basic Endpoints","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints","content":"Use Cases: Basic Endpoints üìÑÔ∏è Objects Used in the Examples üìÑÔ∏è GET Collection Endpoint üìÑÔ∏è GET Endpoint üìÑÔ∏è POST Endpoint for Entity Creation üìÑÔ∏è PATCH and PUT Endpoint for Entity Update The properties in the input DTO are uninitialized. This is important for PATCH üìÑÔ∏è DELETE Endpoint üìÑÔ∏è POST Endpoint for an Action Without Input","keywords":"","version":"Next"},{"title":"rekalogika/api-lite","type":0,"sectionRef":"#","url":"/api-lite","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/api-lite","url":"/api-lite#sections","content":" üìÑÔ∏è Introduction A set of tools to simplify working with [API üìÑÔ∏è Components Overview These are the components involved in building an API Platform-based project üìÑÔ∏è Design Considerations &amp; Decisions Some of our design considerations and decisions based on our experience. These üìÑÔ∏è AbstractState Base class for our providers and processors. üìÑÔ∏è Usage Without AbstractState If you don't want your state providers and processors to extend AbstractState, üìÑÔ∏è Mapping By separating the entity and the ApiResource DTO, mapping between the two üìÑÔ∏è Pagination The mapCollection() method automates the task of handling collection results, üìÑÔ∏è Filtering Filtering support is planned, but it is going to take some time. üóÉÔ∏è Use Cases: Basic Endpoints 7 items üóÉÔ∏è Use Cases: Subresource 4 items ","version":"Next","tagName":"h2"},{"title":"AbstractState","type":0,"sectionRef":"#","url":"/api-lite/abstractstate","content":"","keywords":"","version":"Next"},{"title":"map()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#map","content":" Maps an object to another object. Useful for mapping an entity to its API resource DTO.  /** @var Book $book */ $bookDto = $this-&gt;map($book, BookDto::class); // also works with an existing object $bookDto = new BookDto(); $this-&gt;map($book, $bookDto);   ","version":"Next","tagName":"h2"},{"title":"mapCollection()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#mapcollection","content":" Takes a supported collection object, and returns a PaginatorInterface with its items mapped to the specified class. It also respects the current page and items per page of the endpoint.  /** @var Book $book */ // returns a paginator of `ReviewDto` return $this-&gt;mapCollection( collection: $book-&gt;getReviews(), target: BookDto::class, operation: $operation, // operation from the `provide()` method context: $context, // context from the `provide()` method );   If the target is null, mapCollection() skips the mapping, it only does the pagination.  ","version":"Next","tagName":"h2"},{"title":"getUser()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#getuser","content":" Returns the current user according to the security system.  $user = $this-&gt;getUser();   ","version":"Next","tagName":"h2"},{"title":"isGranted()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#isgranted","content":" Checks if the attribute is granted against the current authentication token and the supplied subject.  if (!$this-&gt;isGranted('view', $book)) { throw $this-&gt;createAccessDeniedException(); }   ","version":"Next","tagName":"h2"},{"title":"denyAccessUnlessGranted()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#denyaccessunlessgranted","content":" Throws an AccessDeniedException if the attribute is not granted against the current authentication token and optionally the supplied subject.  $this-&gt;denyAccessUnlessGranted('view', $book);   ","version":"Next","tagName":"h2"},{"title":"createAccessDeniedException()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#createaccessdeniedexception","content":" Creates an AccessDeniedException.  ","version":"Next","tagName":"h2"},{"title":"createNotFoundException()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#createnotfoundexception","content":" Creates a NotFoundException. ","version":"Next","tagName":"h2"},{"title":"GET Endpoint","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/get","content":"GET Endpoint API ResourceState Provider src/ApiResource/Admin/BookDto.php namespace App\\ApiResource\\Admin; use App\\ApiState\\Admin\\Book\\BookProvider; use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Get; #[ApiResource( shortName: 'Admin/Book', routePrefix: '/admin', operations: [ // ... new Get( uriTemplate: '/books/{id}', provider: BookProvider::class, ), // ... ] )] class BookDto { // ... } ","keywords":"","version":"Next"},{"title":"DELETE Endpoint","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/delete","content":"DELETE Endpoint API ResourceState Processor src/ApiResource/Admin/BookDto.php use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Patch; use App\\ApiInput\\BookInputDto; use App\\ApiState\\Admin\\Book\\BookRemoveProcessor; #[ApiResource( shortName: 'Admin/Book', routePrefix: '/admin', operations: [ // ... new Delete( uriTemplate: '/books/{id}', processor: BookRemoveProcessor::class ), // ... ] )] class BookDto { // ... } ","keywords":"","version":"Next"},{"title":"GET Collection Endpoint","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/get-collection","content":"GET Collection Endpoint API ResourceState Provider src/ApiResource/Admin/BookDto.php namespace App\\ApiResource\\Admin; use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\GetCollection; use App\\ApiState\\Admin\\Book\\BookCollectionProvider; #[ApiResource( shortName: 'Admin/Book', routePrefix: '/admin', // // Uncomment the following to enable keyset-pagination: // extraProperties: [ // 'api_lite_rekapager' =&gt; true // ] operations: [ // ... new GetCollection( uriTemplate: '/books', provider: BookCollectionProvider::class, ), // ... ] )] class BookDto { // ... } ","keywords":"","version":"Next"},{"title":"POST Endpoint for Entity Creation","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/post-create","content":"POST Endpoint for Entity Creation API ResourceInput DTOState Processor src/ApiResource/Admin/BookDto.php use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Post; use ApiPlatform\\Metadata\\Put; use App\\ApiInput\\BookInputDto; use App\\ApiState\\Admin\\Book\\BookCreateProcessor; #[ApiResource( shortName: 'Admin/Book', routePrefix: '/admin', operations: [ // ... new Post( uriTemplate: '/books', input: BookInputDto::class, processor: BookCreateProcessor::class ), // ... ] )] class BookDto { // ... } ","keywords":"","version":"Next"},{"title":"PATCH and PUT Endpoint for Entity Update","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/patch-put-update","content":"PATCH and PUT Endpoint for Entity Update API ResourceInput DTOState Processor src/ApiResource/Admin/BookDto.php use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Patch; use App\\ApiInput\\BookInputDto; use App\\ApiState\\Admin\\Book\\BookProvider; use App\\ApiState\\Admin\\Book\\BookUpdateProcessor; #[ApiResource( shortName: 'Admin/Book', routePrefix: '/admin', operations: [ // ... new Patch( uriTemplate: '/books/{id}', input: BookInputDto::class, processor: BookUpdateProcessor::class, read: false, ), new Put( uriTemplate: '/books/{id}', input: BookInputDto::class, processor: BookUpdateProcessor::class, read: false, ), // ... ] )] class BookDto { // ... } ","keywords":"","version":"Next"},{"title":"POST Endpoint for an Action Without Input","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/post-without-input","content":"POST Endpoint for an Action Without Input API ResourceState Processor src/ApiResource/Admin/BookDto.php use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Patch; use ApiPlatform\\OpenApi\\Model\\Operation; use ApiPlatform\\OpenApi\\Model\\RequestBody; use App\\ApiInput\\BookInputDto; use App\\ApiState\\Admin\\Book\\BookCheckProcessor; #[ApiResource( shortName: 'Admin/Book', routePrefix: '/admin', operations: [ // ... new Post( uriTemplate: '/books/{id}/check', processor: BookCheckProcessor::class, input: false, openapi: new Operation( summary: 'Check the book\\'s condition', description: 'Tells us that the book condition has been checked.', ) ), // ... ] )] class BookDto { // ... } ","keywords":"","version":"Next"},{"title":"Components Overview","type":0,"sectionRef":"#","url":"/api-lite/components","content":"","keywords":"","version":"Next"},{"title":"Components Defined by Your Application‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#components-defined-by-your-application","content":" ","version":"Next","tagName":"h2"},{"title":"Domain Layer‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#domain-layer","content":" The heart of your software. The domain layer describes the business logic and rules. It consists of entities, value objects, domain services, and other supporting classes.  In most Symfony and API Platform projects, Doctrine is used to manage the persistence of the domain layer. However, it can be anything &amp; our API layer does not care about how the domain layer is persisted and managed.  ","version":"Next","tagName":"h3"},{"title":"API Resource DTOs‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#api-resource-dtos","content":" These are the data transfer objects (DTOs) that are used to represent the resources in the API. In our projects, we will be using these DTOs as theApiResource classes. Unlike most of the API Platform examples and demos you will find on the Internet, we will not be adding the ApiResource attribute to our entities.  These DTOs will usually mirror the domain entities. They usually contain a subset of the properties, but without the domain logic. And like the entities, these DTOs will usually form a rich, interconnected graph of objects.  These DTOs act as the output of the endpoints.  An entity can be mapped to one or more DTOs if we need different API representations of a specific entity. For example, we can use a specific DTO for a class of user, and a different DTO for another class or user.  ","version":"Next","tagName":"h3"},{"title":"Input DTOs‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#input-dtos","content":" The DTOs representing the input data for operations that require an input, like POST, PUT, and PATCH.  ","version":"Next","tagName":"h3"},{"title":"Components Defined by API Platform‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#components-defined-by-api-platform","content":" ","version":"Next","tagName":"h2"},{"title":"State Provider‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#state-provider","content":" Used to get the output of a GET operations. Using our guidelines, you will implement a state provider for every GET operation that you define. The state provider will be responsible for fetching the entity from the domain layer, mapping it to the DTO, and returning it.  ","version":"Next","tagName":"h3"},{"title":"State Processor‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#state-processor","content":" Modifies the state of the entity. Used by the POST, PUT, PATCH, and DELETE operations. Using our guidelines, you will implement a state processor for every operation that modifies the state of the entity.  ","version":"Next","tagName":"h3"},{"title":"Paginator‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#paginator","content":" A paginator is an API Platform interface used to paginate the results of a GET operations. If your endpoint is a GET operation that is supposed to return a collection of objects, you should return a paginator object instead of an array or a collection. By doing so, you will get proper paging of the results.  ","version":"Next","tagName":"h3"},{"title":"Components Defined By rekalogika/api-lite‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#components-defined-by-rekalogikaapi-lite","content":" ","version":"Next","tagName":"h2"},{"title":"Mapper‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#mapper","content":" Maps an object to another object. The functionality is provided byrekalogika/mapper behind the scenes. It can be used to map between entities and DTOs. This mapper provides several critical features for our purposes, including handling circular references and lazy-loading target objects. Therefore, we can have interconnected DTOs and API Platform should be able to generate IRIs without causing the hydration of the entire object graph.  ","version":"Next","tagName":"h3"},{"title":"Paginator Applier‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#paginator-applier","content":" A service provided by rekalogika/api-lite to automatically transform a collection of objects to a paginator. It ships with paginator appliers for Doctrine Collection, Selectable, Query, QueryBuilder, as well as Pagerfanta and Pagerfanta adapter.. ","version":"Next","tagName":"h3"},{"title":"Filtering","type":0,"sectionRef":"#","url":"/api-lite/filtering","content":"Filtering info Filtering support is planned, but it is going to take some time.","keywords":"","version":"Next"},{"title":"Design Considerations & Decisions","type":0,"sectionRef":"#","url":"/api-lite/design","content":"","keywords":"","version":"Next"},{"title":"Component Decoupling‚Äã","type":1,"pageTitle":"Design Considerations & Decisions","url":"/api-lite/design#component-decoupling","content":" API Platform must not implicitly interact with Doctrine or other persistence layer behind the scenes. You can do that by not attaching #[ApiResource] to any Doctrine entities. But to make sure this is the case, you can add these options to your configuration:  config/packages/api_platform.yaml api_platform: doctrine: enabled: false doctrine_mongodb_odm: enabled: false   ","version":"Next","tagName":"h2"},{"title":"DTOs as the ApiResource‚Äã","type":1,"pageTitle":"Design Considerations & Decisions","url":"/api-lite/design#dtos-as-the-apiresource","content":" Domain entities are not designated ApiResource. Instead, we create a DTO for the purpose. Then, in the state providers and processors, we will map the entity to the DTO, and return the DTO.  ","version":"Next","tagName":"h2"},{"title":"No Serialization Groups‚Äã","type":1,"pageTitle":"Design Considerations & Decisions","url":"/api-lite/design#no-serialization-groups","content":" Serialization groups are not scalable. They can start becoming unwieldy as the project grows. Instead, if we need a different API representation of the same entity, we explicitly create multiple DTOs that act as the ApiResource. These different DTOs should get a different URL and a different shortName.  ","version":"Next","tagName":"h2"},{"title":"Separate Input and Output DTOs‚Äã","type":1,"pageTitle":"Design Considerations & Decisions","url":"/api-lite/design#separate-input-and-output-dtos","content":" Avoid using the same DTO as both input and output, and using serialization groups to define the differences between the two. Instead, we use a separate DTO for input and output.  The ApiResource DTOs defines the output data structure. In POST, PUT, and PATCH endpoints, we create another DTO to represent the input data structure. In the ApiResource DTO, we use the input argument to point to the input DTO.  ","version":"Next","tagName":"h2"},{"title":"Provider-less Operations‚Äã","type":1,"pageTitle":"Design Considerations & Decisions","url":"/api-lite/design#provider-less-operations","content":" ApiResource and all of its operations do not get assigned a provider, except for Get and GetCollection. All processors get their data directly from the repository. We find this degree of explicitness helps with DX, readability, and flexibility.  Get and GetCollection also gets a separate provider each for more explicitness.  Put, Patch, and Delete will require a read: false option to prevent404 error.  ","version":"Next","tagName":"h2"},{"title":"Authorization‚Äã","type":1,"pageTitle":"Design Considerations & Decisions","url":"/api-lite/design#authorization","content":" Because of the nature of our provider-less operations above, the securityproperty in ApiResource and its operations will be less useful, as objectwill either be null or points to the DTO, not the entity.  Instead, our AbstractState provides isGranted() anddenyAccessUnlessGranted() methods that most of us are already familiar. Security checks involving an action toward an object should be done next to the action anyway, not in a separate class. Otherwise, it reduces readability, and can easily lead to coding errors. ","version":"Next","tagName":"h2"},{"title":"Objects Used in the Examples","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/objects","content":"Objects Used in the Examples BookReviewBookDtoReviewDto src/Entity/Book.php namespace App\\Entity; use App\\Repository\\BookRepository; use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\Mapping as ORM; use Symfony\\Bridge\\Doctrine\\Types\\UuidType; use Symfony\\Component\\Uid\\Uuid; #[ORM\\Entity(repositoryClass: BookRepository::class)] class Book extends \\stdClass { #[ORM\\Id] #[ORM\\Column(type: UuidType::NAME, unique: true, nullable: false)] private Uuid $id; #[ORM\\Column] private ?string $title = null; #[ORM\\Column(type: Types::TEXT)] private ?string $description = null; #[ORM\\Column(type: Types::DATETIME_IMMUTABLE, nullable: true)] private ?\\DateTimeInterface $lastChecked = null; /** * @var Collection&lt;array-key,Review&gt; */ #[ORM\\OneToMany( targetEntity: Review::class, mappedBy: 'book', cascade: ['persist', 'remove'], orphanRemoval: true, fetch: 'EXTRA_LAZY', indexBy: 'id', )] private Collection $reviews; public function __construct() { $this-&gt;id = Uuid::v7(); $this-&gt;reviews = new ArrayCollection(); } /** * We want to check our books' conditions every now and then. */ public function check(): void { $this-&gt;lastChecked = new \\DateTimeImmutable(); } public function getId(): Uuid { return $this-&gt;id; } public function getTitle(): ?string { return $this-&gt;title; } public function setTitle(?string $title): self { $this-&gt;title = $title; return $this; } public function getDescription(): ?string { return $this-&gt;description; } public function setDescription(?string $description): self { $this-&gt;description = $description; return $this; } /** * @return Collection&lt;array-key,Review&gt; */ public function getReviews(): Collection { return $this-&gt;reviews; } public function addReview(Review $review): self { if (!$this-&gt;reviews-&gt;contains($review)) { $this-&gt;reviews[] = $review; $review-&gt;setBook($this); } return $this; } public function removeReview(Review $review): self { if ($this-&gt;reviews-&gt;removeElement($review)) { // set the owning side to null (unless already changed) if ($review-&gt;getBook() === $this) { $review-&gt;setBook(null); } } return $this; } public function getLastChecked(): ?\\DateTimeInterface { return $this-&gt;lastChecked; } } ","keywords":"","version":"Next"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/api-lite/intro","content":"","keywords":"","version":"Next"},{"title":"Motivation‚Äã","type":1,"pageTitle":"Introduction","url":"/api-lite/intro#motivation","content":" API Platform documentation encourages developers to use plain old PHP objects (POPOs) or data transfer objects (DTOs) as the models for API communication, instead of using domain entities directly for this purpose. But it does not establish a practical working patterns for that approach.  Practically all the examples and demos we find on the Internet still attach ApiResource to Doctrine entities.  Sometimes API Platform can feel very rigid. It can be difficult to figure out how to accomplish things outside its conventions. There are ways around any problem, just not always immediately obvious. It can feel like that we just want to express what we need by writing a PHP code, not by figuring out the correct combination of attributes to use.  Those coming from Symfony controllers might find API Platform's approach very different, but it does not have to be.  ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Introduction","url":"/api-lite/intro#installation","content":" composer require rekalogika/api-lite   ","version":"Next","tagName":"h2"},{"title":"Synopsis‚Äã","type":1,"pageTitle":"Introduction","url":"/api-lite/intro#synopsis","content":" use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\ApiLite\\State\\AbstractProvider; use Rekalogika\\Mapper\\CollectionInterface; #[ApiResource( shortName: 'Book', operations: [ new Get( uriTemplate: '/books/{id}', provider: BookProvider::class ), ] )] class BookDto { public ?Uuid $id = null; public ?string $title = null; public ?string $description = null; /** * @var ?CollectionInterface&lt;int,ReviewDto&gt; */ public ?CollectionInterface $reviews = null; } /** * @extends AbstractProvider&lt;BookDto&gt; */ class BookProvider extends AbstractProvider { public function __construct( private BookRepository $bookRepository ) { } public function provide( Operation $operation, array $uriVariables = [], array $context = [] ): object|array|null { $book = $this-&gt;bookRepository -&gt;find($uriVariables['id'] ?? null) ?? throw new NotFoundException('Book not found'); $this-&gt;denyAccessUnlessGranted('view', $book); return $this-&gt;map($book, BookDto::class); } }   ","version":"Next","tagName":"h2"},{"title":"To-Do List‚Äã","type":1,"pageTitle":"Introduction","url":"/api-lite/intro#to-do-list","content":" Figure out &amp; implement filtering.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction","url":"/api-lite/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/api-lite/intro#contributing","content":" Issues and pull requests should be filed in the GitHub repositoryrekalogika/api-lite. ","version":"Next","tagName":"h2"},{"title":"Pagination","type":0,"sectionRef":"#","url":"/api-lite/pagination","content":"","keywords":"","version":"Next"},{"title":"Usage‚Äã","type":1,"pageTitle":"Pagination","url":"/api-lite/pagination#usage","content":" Common usage pattern in a state provider for a GetCollection endpoint:  use ApiPlatform\\Metadata\\Operation; use Rekalogika\\ApiLite\\State\\AbstractProvider; /** * @extends AbstractProvider&lt;SomeObjectDto&gt; */ class CollectionProvider extends AbstractProvider { // ... public function provide( Operation $operation, array $uriVariables = [], array $context = [] ): object|array|null { // get the $collectionObject here return $this-&gt;mapCollection( collection: $collectionObject, target: SomeObjectDto::class, operation: $operation, context: $context ); } }   The highlighted code takes the $collectionObject, pages it according to the paging parameters provided by API Platform, maps each item in the collection to the SomeObjectDto class, and returns the results in a PaginatorInterfaceobject that API Platform expects.  ","version":"Next","tagName":"h2"},{"title":"Supported Collection Objects‚Äã","type":1,"pageTitle":"Pagination","url":"/api-lite/pagination#supported-collection-objects","content":" The mapCollection() method supports the following collection object types:  Doctrine Collection and ReadableCollection.Doctrine Selectable.Doctrine ORM Query and QueryBuilder.Pagerfanta's PagerfantaInterface and PagerfantaAdapterInterface  If you enable Rekapager support to get keyset-based pagination, it supports the following types:  Doctrine ORM QueryBuilder.Doctrine Selectable.  ","version":"Next","tagName":"h2"},{"title":"Keyset Pagination (or Cursor Pagination) using Rekapager‚Äã","type":1,"pageTitle":"Pagination","url":"/api-lite/pagination#keyset-pagination-or-cursor-pagination-using-rekapager","content":" The package supports keyset pagination using our Rekapagerpackage. Its usage is opt-in. By default, paginations will be done using the default offset-based API Platform pagination.  info Learn more about Rekapager and keyset pagination in our Rekapager documentation.  To enable Rekapager support per operation, add the api_lite_rekapager extra property to the operation:  #[ApiResource( extraProperties: [ 'api_lite_rekapager' =&gt; true ] )] class Book { // ... }   To enable it globally, you can set it in API Platform's configuration:  config/packages/api_platform.yaml api_platform: defaults: extra_properties: api_lite_rekapager: true   ","version":"Next","tagName":"h2"},{"title":"Supporting Other Collection Objects‚Äã","type":1,"pageTitle":"Pagination","url":"/api-lite/pagination#supporting-other-collection-objects","content":" If you need to support other collection object types, you can create a class implementing PaginatorApplierInterface.  ","version":"Next","tagName":"h2"},{"title":"Use Case: Doctrine Repository‚Äã","type":1,"pageTitle":"Pagination","url":"/api-lite/pagination#use-case-doctrine-repository","content":" Doctrine repositories implement Selectable, so you can conveniently do the following in the state provider, and avoid the nee d to create queries:  use ApiPlatform\\Metadata\\Operation; use Rekalogika\\ApiLite\\State\\AbstractProvider; /** * @extends AbstractProvider&lt;SomeObjectDto&gt; */ class CollectionProvider extends AbstractProvider { public function __construct( private SomeObjectRepository $someObjectRepository ) { } public function provide( Operation $operation, array $uriVariables = [], array $context = [] ): object|array|null { return $this-&gt;mapCollection( collection: $this-&gt;someObjectRepository, target: SomeObjectDto::class, operation: $operation, context: $context ); } }   To get a default sorting, you can override the matching() method in the repository like this:  use Doctrine\\Common\\Collections\\Criteria; class SomeObjectRepository extends EntityRepository implements Selectable { public function matching(Criteria $criteria): Collection { if (count($criteria-&gt;orderings()) === 0) { $criteria-&gt;orderBy(['createdAt' =&gt; 'DESC']); } return parent::matching($criteria); } }  ","version":"Next","tagName":"h2"},{"title":"Mapping","type":0,"sectionRef":"#","url":"/api-lite/mapping","content":"","keywords":"","version":"Next"},{"title":"When To Use the Mapper and When Not To‚Äã","type":1,"pageTitle":"Mapping","url":"/api-lite/mapping#when-to-use-the-mapper-and-when-not-to","content":" When you need to map an entity to a DTO, then the mapper is almost always the tool for the job. It handles circular references and supports lazy-loading, things that are difficult to do manually. The mapper should work most of the time. And when it doesn't, it is only a simple matter to extend it.  However, when you need to map a DTO to an entity, it requires more consideration. Your domain model might mandate a specific way to do things, which might be different from than just calling the setters. If you can rely too much on the mapper, it might indicate that your domain model is anemic, and you should look into that. The integrity of your domain model should not suffer just because using the mapper is convenient.  ","version":"Next","tagName":"h2"},{"title":"Lazy Loading‚Äã","type":1,"pageTitle":"Mapping","url":"/api-lite/mapping#lazy-loading","content":" The mapper supports lazy loading on regular objects and collection objects. So, you are free to add relations among your DTOs as much as you need. You can have your DTOs mirror the relations of your domain entities as closely as you want without worrying about excessive Doctrine queries.  These are what you need to keep in mind:  The DTOs must not be final. Otherwise, lazy loading will not work.You should type hint collection properties using CollectionInterface. Plain arrays cannot support lazy loading.Your DTOs must use the same identifier as your entities. Otherwise, the DTO might cause unwanted hydration of the source entity.  Protip Mapper has a panel in Symfony Profiler. You can use it to debug the mapper if you have a mapping problem.  ","version":"Next","tagName":"h2"},{"title":"Lazy-Loading Collection Example‚Äã","type":1,"pageTitle":"Mapping","url":"/api-lite/mapping#lazy-loading-collection-example","content":" With the following example, API platform will turn the reviews property to the IRI of the collection:  use ApiPlatform\\Core\\Annotation\\ApiProperty; use Rekalogika\\Mapper\\CollectionInterface; class BookDto { /** * @var ?CollectionInterface&lt;int,ReviewDto&gt; */ #[ApiProperty(uriTemplate: '/books/{bookId}/reviews')] public ?CollectionInterface $reviews = null; }   In this case, the serializer will not read the content of the reviewsproperty, and therefore Doctrine won't hydrate the source collection.  ","version":"Next","tagName":"h3"},{"title":"Lazy-Loading Object Example‚Äã","type":1,"pageTitle":"Mapping","url":"/api-lite/mapping#lazy-loading-object-example","content":" With the following example, the book property below will be turned into the IRI of the BookDto resource:  use ApiPlatform\\Core\\Annotation\\ApiProperty; class ReviewDto { #[ApiProperty(readableLink: false)] public ?BookDto $book = null; }   To generate the IRI, API Platform requires only the identifier. Doctrine will not hydrate the entity if all we are getting from it is the identifier. Mapper's proxy is smart enough to determine the identifier of the Doctrine entity, and won't try to map the other properties.  Therefore, generating an IRI won't cost you a Doctrine query, as long as you make sure both the DTO and the Doctrine entity use the same identifier property.  Protip Just use id as the identifier property everywhere, and be done with it.  ","version":"Next","tagName":"h3"},{"title":"The Mapper Remembers...‚Äã","type":1,"pageTitle":"Mapping","url":"/api-lite/mapping#the-mapper-remembers","content":" The mapper remembers the previous mappings it has done in the same request, and will take note of the reverse of the mappings.  If the client sent an IRI in the request, like/user/books/018dda4b-1884-76ab-af9d-71ab512a0c84, API Platform will resolve the IRI using a State Provider having the same URL pattern. If you are using the same pattern elaborated in this document, then your State Provider will get the entity from the database, map it to its DTO, and returns the DTO.  Once API Platform has the DTO, it will pass it as part of the input of your State Processor. So you are getting the DTO, not the entity you need. How would you get the entity? You map the DTO to the entity class. It will return you the entity because you once mapped the entity to the DTO in the State Provider. ","version":"Next","tagName":"h2"},{"title":"Use Cases: Subresource","type":0,"sectionRef":"#","url":"/api-lite/subresource","content":"Use Cases: Subresource üìÑÔ∏è GET Collection Endpoint for Subresources üìÑÔ∏è Referencing a Collection of Subresources Using a Collection of IRIs üìÑÔ∏è GET Endpoint for a Subresource üìÑÔ∏è Referencing a Subresource Using the IRI of the resource","keywords":"","version":"Next"},{"title":"GET Endpoint for a Subresource","type":0,"sectionRef":"#","url":"/api-lite/subresource/get-subresource","content":"GET Endpoint for a Subresource API ResourceState Provider src/ApiResource/User/ReviewDto.php namespace App\\ApiResource\\User; use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\GetCollection; use ApiPlatform\\Metadata\\Link; use App\\ApiState\\User\\Review\\BookReviewCollectionProvider; use App\\ApiState\\User\\Review\\BookReviewProvider; #[ApiResource( shortName: 'User/Review', routePrefix: '/user', operations: [ // ... new Get( uriTemplate: '/books/{bookId}/reviews/{id}', provider: BookReviewProvider::class, uriVariables: [ 'bookId' =&gt; new Link( fromClass: BookDto::class, ) ], ), // ... ] )] class ReviewDto { // ... } ","keywords":"","version":"Next"},{"title":"GET Collection Endpoint for Subresources","type":0,"sectionRef":"#","url":"/api-lite/subresource/get-collection-subresource","content":"GET Collection Endpoint for Subresources API ResourceState Provider src/ApiResource/User/ReviewDto.php namespace App\\ApiResource\\User; use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\GetCollection; use ApiPlatform\\Metadata\\Link; use App\\ApiState\\User\\Review\\BookReviewCollectionProvider; #[ApiResource( shortName: 'User/Review', routePrefix: '/user', operations: [ // ... new GetCollection( uriTemplate: '/books/{bookId}/reviews', uriVariables: [ 'bookId' =&gt; new Link( fromClass: BookDto::class, ), ], provider: BookReviewCollectionProvider::class, paginationItemsPerPage: 10 ), // ... ] )] class ReviewDto { // ... } ","keywords":"","version":"Next"},{"title":"Usage Without AbstractState","type":0,"sectionRef":"#","url":"/api-lite/without-abstractstate","content":"Usage Without AbstractState If you don't want your state providers and processors to extend AbstractState, you can wire the services directly. To use map(), you can inject ApiMapperInterface. And to usemapCollection(), you can inject ApiCollectionMapperInterface. The usage is the same as described in the AbstractState section. warning Be sure to use the correct service class ApiMapperInterface, notMapperInterface, which is the plain mapper implementation fromrekalogika/mapper without the remembering feature.","keywords":"","version":"Next"},{"title":"rekalogika/doctrine-collections-decorator","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/doctrine-collections-decorator","url":"/doctrine-collections-decorator#sections","content":" üìÑÔ∏è Introduction &amp; Installation Lets you easily create decorator classes to modify the behaviors of Doctrine üìÑÔ∏è Creating a Decorator Class This chapter will show you how to use this library. üìÑÔ∏è Decorator Classes and Traits This chapter will describe all the available classes and traits in this package. üìÑÔ∏è Class Diagram Bird's eye view of Doctrine Collection and the parent interfaces. Those with üóÉÔ∏è Cookbook 6 items ","version":"Next","tagName":"h2"},{"title":"rekalogika/direct-property-access","type":0,"sectionRef":"#","url":"/direct-property-access","content":"","keywords":"","version":"Next"},{"title":"Synopsis‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#synopsis","content":" use Rekalogika\\DirectPropertyAccess\\DirectPropertyAccessor; class Person { private string $name = 'Jane'; } $propertyAccessor = new DirectPropertyAccessor(); $name = $propertyAccessor-&gt;getValue($person, 'name'); // Jane $propertyAccessor-&gt;setValue($person, 'name', 'John');   ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony FlexNon-Symfony Projects Open a command console, enter your project directory, and execute: composer require rekalogika/direct-property-access   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#usage","content":" In Symfony projects, you can autowire DirectPropertyAccessor. In other projects, you can simply instantiate it.  Read Symfony's PropertyAccess documentationfor more information on how to use it. The difference is thatDirectPropertyAccessor does not call any of the object's methods, but reads and writes directly to the object's properties, even if they are private.  ","version":"Next","tagName":"h2"},{"title":"Caveats‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#caveats","content":" Currently does not support arrays and paths beyond one level deep.  ","version":"Next","tagName":"h2"},{"title":"Credits‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#credits","content":" This project took inspiration from the following projects.  Symfony Property Accesskwn/reflection-property-accessnelmio/alice  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#contributing","content":" Issues and pull requests should be filed in the GitHub repositoryrekalogika/direct-property-access. ","version":"Next","tagName":"h2"},{"title":"Referencing a Subresource","type":0,"sectionRef":"#","url":"/api-lite/subresource/referencing-subresource","content":"","keywords":"","version":"Next"},{"title":"Using the IRI of the resource‚Äã","type":1,"pageTitle":"Referencing a Subresource","url":"/api-lite/subresource/referencing-subresource#using-the-iri-of-the-resource","content":" By default, API Platform will use IRIs to refer to a resource. But, if you want this style, we recommend setting it explicitly using#[ApiProperty(readableLink: false)].  OutputAPI Resource { &quot;@context&quot;: &quot;/contexts/User/Review&quot;, &quot;@id&quot;: &quot;/user/reviews/018de474-1a23-7494-85f9-e92fb962d2a8&quot;, &quot;@type&quot;: &quot;User/Review&quot;, &quot;id&quot;: &quot;018de474-1a23-7494-85f9-e92fb962d2a8&quot;, &quot;body&quot;: &quot;Occaecati voluptate sed sed suscipit. Voluptas expedita quis molestias quam modi deleniti earum. Voluptas dolorem pariatur iusto quis. Rerum in quisquam nisi neque.&quot;, &quot;rating&quot;: 5, &quot;book&quot;: &quot;/user/books/018de474-1a2a-7975-87bb-5944ee8ee95f&quot; }   ","version":"Next","tagName":"h2"},{"title":"Embed the resource‚Äã","type":1,"pageTitle":"Referencing a Subresource","url":"/api-lite/subresource/referencing-subresource#embed-the-resource","content":" OutputAPI Resource { &quot;@context&quot;: &quot;/contexts/User/Review&quot;, &quot;@id&quot;: &quot;/user/reviewsWithEmbeddedResource/018de474-1a23-7494-85f9-e92fb962d2a8&quot;, &quot;@type&quot;: &quot;User/Review&quot;, &quot;id&quot;: &quot;018de474-1a23-7494-85f9-e92fb962d2a8&quot;, &quot;body&quot;: &quot;Occaecati voluptate sed sed suscipit. Voluptas expedita quis molestias quam modi deleniti earum. Voluptas dolorem pariatur iusto quis. Rerum in quisquam nisi neque.&quot;, &quot;rating&quot;: 5, &quot;book&quot;: { &quot;@id&quot;: &quot;/user/books/018de474-1a2a-7975-87bb-5944ee8ee95f&quot;, &quot;@type&quot;: &quot;User/Book&quot;, &quot;id&quot;: &quot;018de474-1a2a-7975-87bb-5944ee8ee95f&quot;, &quot;title&quot;: &quot;Saepe enim sint culpa fuga.&quot;, &quot;description&quot;: &quot;Ad cupiditate asperiores quas quis non facere nam. Fugit praesentium natus aut error perspiciatis quo. Iusto dolores quaerat quibusdam qui praesentium.&quot;, &quot;reviews&quot;: &quot;/user/books/018de474-1a2a-7975-87bb-5944ee8ee95f/reviews&quot; } }  ","version":"Next","tagName":"h2"},{"title":"Referencing a Collection of Subresources","type":0,"sectionRef":"#","url":"/api-lite/subresource/referencing-collection-subresource","content":"","keywords":"","version":"Next"},{"title":"Using a Collection of IRIs‚Äã","type":1,"pageTitle":"Referencing a Collection of Subresources","url":"/api-lite/subresource/referencing-collection-subresource#using-a-collection-of-iris","content":" By default, API Platform will use a collection of the IRI of the subresource objects. But, if you want this style, we recommend setting it explicitly using#[ApiProperty(readableLink: false)].  OutputAPI Resource { &quot;@context&quot;: &quot;/contexts/User/Book&quot;, &quot;@id&quot;: &quot;/user/books/018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot;, &quot;@type&quot;: &quot;User/Book&quot;, &quot;id&quot;: &quot;018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot;, &quot;title&quot;: &quot;Some Book&quot;, &quot;description&quot;: &quot;Eligendi sunt explicabo quae qui omnis expedita et. Et incidunt earum recusandae itaque recusandae. Ipsam id id qui.&quot;, &quot;reviews&quot;: [ &quot;/user/reviews/018dda4b-19a5-7ac7-824d-caa21760643a&quot;, &quot;/user/reviews/018dda4b-19a7-716a-94e0-2d6704a564d5&quot;, &quot;/user/reviews/018dda4b-19aa-7336-af9b-dbaf19d7e744&quot;, ] }   ","version":"Next","tagName":"h2"},{"title":"Using a Collection of Embedded Resources‚Äã","type":1,"pageTitle":"Referencing a Collection of Subresources","url":"/api-lite/subresource/referencing-collection-subresource#using-a-collection-of-embedded-resources","content":" OutputAPI Resource { &quot;@context&quot;: &quot;/contexts/User/Book&quot;, &quot;@id&quot;: &quot;/user/books/018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot;, &quot;@type&quot;: &quot;User/Book&quot;, &quot;id&quot;: &quot;018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot;, &quot;title&quot;: &quot;Some Book&quot;, &quot;description&quot;: &quot;Eligendi sunt explicabo quae qui omnis expedita et. Et incidunt earum recusandae itaque recusandae. Ipsam id id qui.&quot;, &quot;reviews&quot;: [ { &quot;@id&quot;: &quot;/user/reviews/018dda4b-19a5-7ac7-824d-caa21760643a&quot;, &quot;@type&quot;: &quot;User/Review&quot;, &quot;id&quot;: &quot;018dda4b-19a5-7ac7-824d-caa21760643a&quot;, &quot;body&quot;: &quot;Ut esse esse ea qui. Placeat esse deleniti et est. Deserunt est architecto et et.&quot;, &quot;rating&quot;: 3, &quot;book&quot;: &quot;/user/books/018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot; }, // ... ] }   ","version":"Next","tagName":"h2"},{"title":"Using the IRI of the Collection‚Äã","type":1,"pageTitle":"Referencing a Collection of Subresources","url":"/api-lite/subresource/referencing-collection-subresource#using-the-iri-of-the-collection","content":" If your resource has a lot of subresources, you might want to change it to use the IRI of the collection instead.  OutputAPI Resource { &quot;@context&quot;: &quot;/contexts/User/Book&quot;, &quot;@id&quot;: &quot;/user/books/018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot;, &quot;@type&quot;: &quot;User/Book&quot;, &quot;id&quot;: &quot;018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot;, &quot;title&quot;: &quot;Some Book&quot;, &quot;description&quot;: &quot;Eligendi sunt explicabo quae qui omnis expedita et. Et incidunt earum recusandae itaque recusandae. Ipsam id id qui.&quot;, &quot;reviews&quot;: &quot;/user/books/018dda4b-19be-7ad3-9eb4-b56e253e9c54/reviews&quot; }  ","version":"Next","tagName":"h2"},{"title":"Class Diagram","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/class-diagram","content":"Class Diagram Bird's eye view of Doctrine Collection and the parent interfaces. Those with asterisks are interfaces that we have a decorating trait for.","keywords":"","version":"Next"},{"title":"Cookbook","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook","content":"","keywords":"","version":"Next"},{"title":"Use Cases‚Äã","type":1,"pageTitle":"Cookbook","url":"/doctrine-collections-decorator/cookbook#use-cases","content":" üìÑÔ∏è Type Safety We can use collection decoration to ensure that the items in a collection are of üìÑÔ∏è Record Precounting Database servers can be [slow in counting üìÑÔ∏è Selectable Abstraction Doctrine ORM uses collection objects that also implement the Selectable üìÑÔ∏è Decorating Member Objects We can use a collection decorator to dynamically decorate the members of the üìÑÔ∏è Loading Prevention in Extra Lazy Collections Suppose you have an entity that has a one-to-many relation with a million of üìÑÔ∏è Lazy Chained Matching If you call matching() on a PersistentCollection, it will immediately query ","version":"Next","tagName":"h2"},{"title":"Loading Prevention in Extra Lazy Collections","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook/extra-lazy-load-prevention","content":"","keywords":"","version":"Next"},{"title":"The Decorator Class‚Äã","type":1,"pageTitle":"Loading Prevention in Extra Lazy Collections","url":"/doctrine-collections-decorator/cookbook/extra-lazy-load-prevention#the-decorator-class","content":" This package already comes with ExtraLazyCollection for this purpose.  info While ExtraLazyCollection only allows the safe methods, they still implement the Collection interface so that the object can still be used in places where a Collection is expected.  ","version":"Next","tagName":"h2"},{"title":"Usage Example in Entities‚Äã","type":1,"pageTitle":"Loading Prevention in Extra Lazy Collections","url":"/doctrine-collections-decorator/cookbook/extra-lazy-load-prevention#usage-example-in-entities","content":" use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Collections\\Decorator\\ExtraLazy\\ExtraLazyCollection; #[ORM\\Entity()] class BookShelf { // our bookshelf has a million of books... #[ORM\\OneToMany( targetEntity: Book::class, fetch: 'EXTRA_LAZY', // needs this, or the safe methods become unsafe indexBy: 'id', // needs this, or containsKey() &amp; get() become unsafe )] private Collection $books; public function getBooks(): Collection { return new ExtraLazyCollection($this-&gt;books); } }  ","version":"Next","tagName":"h2"},{"title":"Decorator Classes and Traits","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/classes","content":"","keywords":"","version":"Next"},{"title":"Ready-to-use Decorator Classes‚Äã","type":1,"pageTitle":"Decorator Classes and Traits","url":"/doctrine-collections-decorator/classes#ready-to-use-decorator-classes","content":" The package ships with ready-to-use decorator classes for common use cases:  ExtraLazyCollection: Prevent collection loading in extra-lazy associations.LazyMatchingCollection: Chained matchingoptimization, if you need to call matching() on the result of anothermatching().  ","version":"Next","tagName":"h2"},{"title":"Decorator Classes‚Äã","type":1,"pageTitle":"Decorator Classes and Traits","url":"/doctrine-collections-decorator/classes#decorator-classes","content":" All of our classes come in four flavors:  Those that implement CollectionThose that implement ReadableCollectionThose that implement Collection and SelectableThose that implement ReadableCollection and Selectable  Most people probably want to extend one of the high-level decorator classes. These will simply forward all method calls to the wrapped collection.  CollectionDecoratorReadableCollectionDecoratorSelectableCollectionDecoratorSelectableReadableCollectionDecorator  Also available the 'reject' decorator classes, which will throw an exception when any of the methods is called:  CollectionRejectDecoratorReadableCollectionRejectDecoratorSelectableCollectionRejectDecoratorSelectableReadableCollectionRejectDecorator  ","version":"Next","tagName":"h2"},{"title":"Abstract Decorator Classes‚Äã","type":1,"pageTitle":"Decorator Classes and Traits","url":"/doctrine-collections-decorator/classes#abstract-decorator-classes","content":" Also available are abstract classes for Collection and ReadableCollection, with and without Selectable, if you prefer a slightly low-level approach:  AbstractCollectionDecoratorAbstractReadableCollectionDecoratorAbstractSelectableCollectionDecoratorAbstractSelectableReadableCollectionDecorator  And the 'reject' flavors:  AbstractCollectionRejectDecoratorAbstractReadableCollectionRejectDecoratorAbstractSelectableCollectionRejectDecoratorAbstractSelectableReadableCollectionRejectDecorator  ","version":"Next","tagName":"h2"},{"title":"Decorator Traits‚Äã","type":1,"pageTitle":"Decorator Classes and Traits","url":"/doctrine-collections-decorator/classes#decorator-traits","content":" There are traits for each of the involved interfaces:  ArrayAccessDecoratorTraitIteratorAggregateDecoratorTraitCountableDecoratorTraitReadableCollectionDecoratorTraitCollectionDecoratorTraitSelectableDecoratorTrait  And the 'reject' traits that will throw BadMethodCallException when any of the methods is called.  ArrayAccessRejectDecoratorTraitIteratorAggregateRejectDecoratorTraitCountableRejectDecoratorTraitReadableCollectionRejectDecoratorTraitCollectionRejectDecoratorTraitSelectableRejectDecoratorTrait  All traits require the method getWrapped() which returns the wrapped collection.  ","version":"Next","tagName":"h2"},{"title":"Convenience Trait‚Äã","type":1,"pageTitle":"Decorator Classes and Traits","url":"/doctrine-collections-decorator/classes#convenience-trait","content":" There is one convenience trait ArrayAccessDecoratorDxTrait which forwardsArrayAccess methods not to the wrapped collection, but to other methods of the decorator.  The idea is that you only need to override containsKey(), get(), set(), and remove(); and the methods offsetExists(), offsetGet(), offsetSet(), and offsetUnset() will forward calls to the aforementioned methods. ","version":"Next","tagName":"h2"},{"title":"Decorating Member Objects","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook/decorating-members","content":"","keywords":"","version":"Next"},{"title":"BusinessContract Entity & Superclass‚Äã","type":1,"pageTitle":"Decorating Member Objects","url":"/doctrine-collections-decorator/cookbook/decorating-members#businesscontract-entity--superclass","content":" use Doctrine\\ORM\\Mapping as ORM; interface BusinessContractInterface { // ... } #[ORM\\Entity()] class BusinessContract implements BusinessContractInterface { // ... }   ","version":"Next","tagName":"h2"},{"title":"Decorator for BusinessContract‚Äã","type":1,"pageTitle":"Decorating Member Objects","url":"/doctrine-collections-decorator/cookbook/decorating-members#decorator-for-businesscontract","content":" class BusinessContractDecorator implements BusinessContractInterface { public function __construct(private BusinessContractInterface $wrapped) { } // ... }   ","version":"Next","tagName":"h2"},{"title":"Decorator for the BusinessContract Collection‚Äã","type":1,"pageTitle":"Decorating Member Objects","url":"/doctrine-collections-decorator/cookbook/decorating-members#decorator-for-the-businesscontract-collection","content":" use Doctrine\\Common\\Collections\\Collection; use Doctrine\\Common\\Collections\\Criteria; use Doctrine\\Common\\Collections\\Selectable; use Rekalogika\\Collections\\Decorator\\Decorator\\CollectionDecorator; /** * @extends CollectionDecorator&lt;array-key,BusinessContractInterface&gt; */ class BusinessContractCollectionDecorator extends CollectionDecorator { #[\\Override] public function get(string|int $key): BusinessContractInterface { return new BusinessContractDecorator( $this-&gt;getWrapped()-&gt;get($key) ); } #[\\Override] public function getIterator(): \\Traversable { foreach ($this-&gt;getWrapped() as $key =&gt; $value) { yield $key =&gt; new BusinessContractDecorator($value); } } // We should override all the other methods that returns // BusinessContractInterface, but for conciseness, we skip them here. }   ","version":"Next","tagName":"h2"},{"title":"Usage in the PartnerCompany Object‚Äã","type":1,"pageTitle":"Decorating Member Objects","url":"/doctrine-collections-decorator/cookbook/decorating-members#usage-in-the-partnercompany-object","content":" use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity()] class PartnerCompany { /** * @var Collection&lt;array-key,BusinessContractInterface&gt; */ #[ORM\\OneToMany(targetEntity: BusinessContract::class)] private Collection $businessContracts; public function __construct() { $this-&gt;businessContracts = new ArrayCollection(); } public function getBusinessContracts(): BusinessContractCollectionDecorator { return new BusinessContractCollectionDecorator($this-&gt;businessContracts); } }   ","version":"Next","tagName":"h2"},{"title":"Class Diagram‚Äã","type":1,"pageTitle":"Decorating Member Objects","url":"/doctrine-collections-decorator/cookbook/decorating-members#class-diagram","content":" Now for a bird eye view of our classes.    ","version":"Next","tagName":"h2"},{"title":"Record Precounting","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook/record-precounting","content":"","keywords":"","version":"Next"},{"title":"The Decorator Class‚Äã","type":1,"pageTitle":"Record Precounting","url":"/doctrine-collections-decorator/cookbook/record-precounting#the-decorator-class","content":" use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\Collections\\Decorator\\Decorator\\CollectionDecorator; /** * @extends CollectionDecorator&lt;array-key,Book&gt; */ class BookCollection extends CollectionDecorator { /** * @param Collection&lt;array-key,Book&gt; $collection */ public function __construct( Collection $collection, private int &amp;$count // pass by reference ) { parent::__construct($collection); } #[\\Override] public function count(): int { return $this-&gt;count(); } /** * Calculates the count and stores it in the `$count` property. */ public function preCount(): void { $this-&gt;count = $this-&gt;getWrapped()-&gt;count(); } }   ","version":"Next","tagName":"h2"},{"title":"Usage in the one-to-many Side‚Äã","type":1,"pageTitle":"Record Precounting","url":"/doctrine-collections-decorator/cookbook/record-precounting#usage-in-the-one-to-many-side","content":" use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity()] class BookShelf { /** * @var Collection&lt;array-key,Book&gt; */ #[ORM\\OneToMany(targetEntity: Book::class)] private Collection $books; #[ORM\\Column()] private int $booksCount = 0; public function __construct() { $this-&gt;books = new ArrayCollection(); } public function getBooks(): BookCollection { return new BookCollection($this-&gt;books, $this-&gt;booksCount); } }   ","version":"Next","tagName":"h2"},{"title":"The Caller Side‚Äã","type":1,"pageTitle":"Record Precounting","url":"/doctrine-collections-decorator/cookbook/record-precounting#the-caller-side","content":" To get the count, you can do it the same way as before. But instead of asking the database to do that, this time it will give you the value from the pre-counted result instantly:  $count = $bookShelf-&gt;getBooks()-&gt;count(); // or: $count = count($bookShelf-&gt;getBooks());   When it is time to refresh the pre-counted value, you can do this:  /** @var EntityManagerInterface $entityManager */ $bookShelf-&gt;getBooks()-&gt;preCount(); $entityManager-&gt;flush();  ","version":"Next","tagName":"h2"},{"title":"Selectable Abstraction","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook/selectable-abstraction","content":"","keywords":"","version":"Next"},{"title":"The Decorator Class‚Äã","type":1,"pageTitle":"Selectable Abstraction","url":"/doctrine-collections-decorator/cookbook/selectable-abstraction#the-decorator-class","content":" use Doctrine\\Common\\Collections\\Collection; use Doctrine\\Common\\Collections\\Criteria; use Doctrine\\Common\\Collections\\Selectable; use Rekalogika\\Collections\\Decorator\\AbstractDecorator\\AbstractCollectionDecorator; /** * @extends AbstractCollectionDecorator&lt;array-key,Book&gt; */ class BookCollection extends AbstractCollectionDecorator { /** * @param Collection&lt;array-key,Book&gt;&amp;Selectable&lt;array-key,Book&gt; $collection */ public function __construct(private Collection $collection) { if (!$collection instanceof Selectable) { throw new \\RuntimeException('The wrapped collection must implement the Selectable interface.'); } } /** * @return Collection&lt;array-key,Book&gt;&amp;Selectable&lt;array-key,Book&gt; */ #[\\Override] protected function getWrapped(): Collection&amp;Selectable { return $this-&gt;collection; } public function findByAuthor(string $author): self { $criteria = Criteria::create() -&gt;where(Criteria::expr()-&gt;eq('author', $author)); $result = $this-&gt;getWrapped()-&gt;matching($criteria); return new self($result); } }   ","version":"Next","tagName":"h2"},{"title":"Usage in the one-to-many Side‚Äã","type":1,"pageTitle":"Selectable Abstraction","url":"/doctrine-collections-decorator/cookbook/selectable-abstraction#usage-in-the-one-to-many-side","content":" use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity()] class BookShelf { /** * @var Collection&lt;array-key,Book&gt; */ #[ORM\\OneToMany(targetEntity: Book::class)] private Collection $books; public function __construct() { $this-&gt;books = new ArrayCollection(); } public function getBooks(): BookCollection { return new BookCollection($this-&gt;books); } }   ","version":"Next","tagName":"h2"},{"title":"The Caller Side‚Äã","type":1,"pageTitle":"Selectable Abstraction","url":"/doctrine-collections-decorator/cookbook/selectable-abstraction#the-caller-side","content":" Then the caller will be able to do something like this:  /** @var BookShelf $bookShelf */ $booksByJohnDoe = $bookShelf-&gt;getBooks()-&gt;findByAuthor('John Doe');  ","version":"Next","tagName":"h2"},{"title":"Creating a Decorator Class","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/creating","content":"","keywords":"","version":"Next"},{"title":"Creating a Decorator Class‚Äã","type":1,"pageTitle":"Creating a Decorator Class","url":"/doctrine-collections-decorator/creating#creating-a-decorator-class","content":" The simplest way to create a decorator class is to extend CollectionDecorator.  use Rekalogika\\Collections\\Decorator\\Decorator\\CollectionDecorator; /** * @extends CollectionDecorator&lt;array-key,Book&gt; */ class BookCollection extends CollectionDecorator { // ... }   Then add your methods to override the existing one. In your methods, you can access the wrapped collection object by calling $this-&gt;getWrapped().  Protip If you want the caller to use the matching() method of the wrapped collection, you can use the SelectableCollectionDecorator class instead.  ","version":"Next","tagName":"h2"},{"title":"Using it in an Entity‚Äã","type":1,"pageTitle":"Creating a Decorator Class","url":"/doctrine-collections-decorator/creating#using-it-in-an-entity","content":" To use it, simply wrap the collection in the constructor.  use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; class BookShelf { /** * @var Collection&lt;array-key,Book&gt; */ private Collection $books; public function __construct() { $this-&gt;books = new ArrayCollection(); } public function getBooks(): BookCollection { return new BookCollection($this-&gt;books); } }  ","version":"Next","tagName":"h2"},{"title":"Lazy Chained Matching","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook/lazy-chained-matching","content":"","keywords":"","version":"Next"},{"title":"The Decorator Class‚Äã","type":1,"pageTitle":"Lazy Chained Matching","url":"/doctrine-collections-decorator/cookbook/lazy-chained-matching#the-decorator-class","content":" This package already comes with LazyMatchingCollection that you can use for this purpose.  ","version":"Next","tagName":"h2"},{"title":"Usage Example in Entities‚Äã","type":1,"pageTitle":"Lazy Chained Matching","url":"/doctrine-collections-decorator/cookbook/lazy-chained-matching#usage-example-in-entities","content":" use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Collections\\Decorator\\LazyMatching\\LazyMatchingCollection; #[ORM\\Entity()] class BookShelf { #[ORM\\OneToMany(targetEntity: Book::class, fetch: 'EXTRA_LAZY', indexBy: 'id')] private Collection $books; public function __construct() { $this-&gt;books = new ArrayCollection(); } /** * @return Collection&lt;array-key,Book&gt;&amp;Selectable&lt;array-key,Book&gt; */ public function getBooks(): Collection&amp;Selectable { return new LazyMatchingCollection($this-&gt;books); } public function getScienceBooks(): Collection { return $this-&gt;getBooks()-&gt;matching( Criteria::create() -&gt;where(Criteria::expr()-&gt;eq('genre', 'science')) ); } public function getOldScienceBooks(): Collection { return $this-&gt;getScienceBook()-&gt;matching( Criteria::create() -&gt;where(Criteria::expr()-&gt;lt('publishedAt', new \\DateTime('-10 years'))) ); } }   ","version":"Next","tagName":"h2"},{"title":"The Caller Side‚Äã","type":1,"pageTitle":"Lazy Chained Matching","url":"/doctrine-collections-decorator/cookbook/lazy-chained-matching#the-caller-side","content":" Then the caller will be able to do something like this:  $bookShelf = $entityManager-&gt;find(BookShelf::class, 1); $oldScienceBook = $bookShelf-&gt;getOldScienceBook(); foreach ($oldScienceBook as $book) { echo $book-&gt;getTitle(); }   With this example, there will be only two database queries, one due to$entityManager-&gt;find(), and one due to the foreach call. ","version":"Next","tagName":"h2"},{"title":"rekalogika/domain-event","type":0,"sectionRef":"#","url":"/domain-event","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/domain-event","url":"/domain-event#sections","content":" üìÑÔ∏è Introduction &amp; Installation An implementation of domain event pattern for Symfony &amp; Doctrine. üìÑÔ∏è Outbox Installation &amp; Configuration To use the transactional outbox pattern to publish your events on the event bus, üìÑÔ∏è Basic Usage You make your entities record events happening in your domain. This library üìÑÔ∏è Pseudo Magic Method The interface DomainEventEmitterInterface implemented by your entities and the üìÑÔ∏è Equatable Domain Events A domain event can optionally implement EquatableDomainEventInterface which üìÑÔ∏è Transactions The framework fully supports transaction, as long as the caller uses the üìÑÔ∏è Manual Control To manually manage domain events, you can use üìÑÔ∏è Dispatch Events When a domain event is dispatched, another event is dispatched. The event wraps üìÑÔ∏è Testing Undispatched Event Problem üìÑÔ∏è Transactional Outbox Pattern The package rekalogika/domain-event-outbox implements the transactional outbox üìÑÔ∏è Tips This chapter explains the tips and our best practices that others might find ","version":"Next","tagName":"h2"},{"title":"Type Safety","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook/type-safety","content":"","keywords":"","version":"Next"},{"title":"The Decorator Class‚Äã","type":1,"pageTitle":"Type Safety","url":"/doctrine-collections-decorator/cookbook/type-safety#the-decorator-class","content":" use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\Collections\\Decorator\\Decorator\\CollectionDecorator; /** * @extends CollectionDecorator&lt;array-key,Book&gt; */ class Books extends CollectionDecorator { private static function assert(mixed $book): Book { if (!$book instanceof Book) { throw new \\InvalidArgumentException('Invalid input'); } return $book; } #[\\Override] public function add(mixed $element): void { $this-&gt;getWrapped()-&gt;add(self::assert($element)); } #[\\Override] public function set(string|int $key, mixed $value): void { $this-&gt;getWrapped()-&gt;set($key, self::assert($value)); } }   ","version":"Next","tagName":"h2"},{"title":"Usage in the one-to-many Side‚Äã","type":1,"pageTitle":"Type Safety","url":"/doctrine-collections-decorator/cookbook/type-safety#usage-in-the-one-to-many-side","content":" use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity()] class BookShelf { /** * @var Collection&lt;array-key,Book&gt; */ #[ORM\\OneToMany(targetEntity: Book::class)] private Collection $books; public function __construct() { $this-&gt;books = new ArrayCollection(); } public function getBooks(): Books { return new Books($this-&gt;books); } }  ","version":"Next","tagName":"h2"},{"title":"Introduction & Installation","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/intro","content":"","keywords":"","version":"Next"},{"title":"Motivation‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/doctrine-collections-decorator/intro#motivation","content":" Custom collection classes won't come to Doctrine ORM anytime soon. Therefore, the only way to modify the behavior of a Doctrine collection is to use decorators. However, creating a Collection decorator by hand is a tedious process.  ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/doctrine-collections-decorator/intro#features","content":" Easily create your decorator classes by extending one of the abstract classes.Several ready-made decorators for common use cases.  ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/doctrine-collections-decorator/intro#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  Open a command console, enter your project directory and execute:  composer require rekalogika/doctrine-collections-decorator   ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/doctrine-collections-decorator/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/doctrine-collections-decorator/intro#contributing","content":" This framework consists of multiple repositories split from a monorepo. Be sure to submit issues and pull requests to therekalogika/doctrine-collections-decorator monorepo. ","version":"Next","tagName":"h2"},{"title":"Dispatch Events","type":0,"sectionRef":"#","url":"/domain-event/dispatch-events","content":"","keywords":"","version":"Next"},{"title":"List of the Dispatch Events‚Äã","type":1,"pageTitle":"Dispatch Events","url":"/domain-event/dispatch-events#list-of-the-dispatch-events","content":" DomainEventImmediateDispatchEvent: dispatched immediately after the domain event is recorded.DomainEventPreFlushDispatchEvent: dispatched before the flush() is called.DomainEventPostFlushDispatchEvent: dispatched after the flush() is called.  note DomainEventPreFlushDispatchEvent and DomainEventPostFlushDispatchEvent also includes the ObjectManager (EntityManager) instance that manages the object that emitted the domain event.  ","version":"Next","tagName":"h2"},{"title":"Listening to the Dispatch Events‚Äã","type":1,"pageTitle":"Dispatch Events","url":"/domain-event/dispatch-events#listening-to-the-dispatch-events","content":" use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener; #[AsEventListener] class PreFlushDispatchEventListener { public function __invoke(DomainEventPreFlushDispatchEvent $event) { // log the $event, publish the $event on an event bus, etc } }   ","version":"Next","tagName":"h2"},{"title":"Purpose‚Äã","type":1,"pageTitle":"Dispatch Events","url":"/domain-event/dispatch-events#purpose","content":" This mechanism is created to allow you to build on top of the domain events. For example, you can record the events for audit trails, or publish the events on an event bus.  info The package rekalogika/domain-event-outbox is completely decoupled fromrekalogika/domain-event. The only thing that connects them is the event DomainEventPreFlushDispatchEvent. ","version":"Next","tagName":"h2"},{"title":"Equatable Domain Events","type":0,"sectionRef":"#","url":"/domain-event/equatable","content":"Equatable Domain Events A domain event can optionally implement EquatableDomainEventInterface which requires the method getSignature(). Two objects with the same signature will be considered identical and won't be dispatched twice. This is useful if your entity is working with a million of related objects. By implementing EquatableDomainEventInterface, you can have your ObjectChangedevent dispatched only once and occupy only a single spot in the memory, instead of a million times. use Rekalogika\\Contracts\\DomainEvent\\EquatableDomainEventInterface; class PostCommentAdded implements EquatableDomainEventInterface { public function __construct(private string $postId) { } public function getSignature(): string { return sha1(serialize($this)); } } use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface; use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait; class Post implements DomainEventEmitterInterface { use DomainEventEmitterTrait; // ... public function addComment(string $comment): Comment { // ... // the PostCommentAdded event will only get dispatched once despite of // addComment being called multiple times. $this-&gt;recordEvent(new PostCommentAdded($this-&gt;id)); } } note Equatable domain events only apply to where the events are spooled before they are processed. Immediate domain events are dispatched immediately, and there is no chance for the equatable check to take place. warning There is no guarantee that the event will be dispatched only once. Two events considered identical may have been recorded in two different phases, and never get grouped together.","keywords":"","version":"Next"},{"title":"Manual Control","type":0,"sectionRef":"#","url":"/domain-event/manual-control","content":"","keywords":"","version":"Next"},{"title":"Manual Dispatching‚Äã","type":1,"pageTitle":"Manual Control","url":"/domain-event/manual-control#manual-dispatching","content":" You can disable automatic dispatching on flush() by callingsetAutoDispatchDomainEvents(false).  use Rekalogika\\DomainEvent\\DomainEventAwareEntityManagerInterface; /** @var DomainEventAwareEntityManagerInterface $entityManager */ $entityManager-&gt;setAutoDispatchDomainEvents(false); // ... $entityManager-&gt;dispatchPreFlushDomainEvents(); $entityManager-&gt;flush(); $entityManager-&gt;dispatchPostFlushDomainEvents();   note Immediate dispatching is dispatched outside DomainEventAwareEntityManager, and therefore unaffected by setAutoDispatchDomainEvents().  ","version":"Next","tagName":"h2"},{"title":"Clearing the Events‚Äã","type":1,"pageTitle":"Manual Control","url":"/domain-event/manual-control#clearing-the-events","content":" If the domain event queues are not empty at the end of the request,DomainEventEntityManager will throw UndispatchedEventsException. To prevent that from happening, if you disable auto-dispatch, you need to make sure that you dispatch both pre-flush and post-flush events as above. Alternatively, you can clear the events if you don't want them dispatched:  use Rekalogika\\DomainEvent\\DomainEventAwareEntityManagerInterface; /** @var DomainEventAwareEntityManagerInterface $entityManager */ $entityManager-&gt;setAutoDispatchDomainEvents(false); // ... $entityManager-&gt;flush(); $entityManager-&gt;clearDomainEvents();   note In the event of an uncaught error, the framework will automatically clear undispatched events using the kernel.exception and console.errorevents, so in such cases, you don't have to handle that manually. But if you catch an exception that previously caused pending events not to be dispatched, you need to manually clear the events.  ","version":"Next","tagName":"h2"},{"title":"Getting the Events From the Queue and Dispatching Them Elsewhere‚Äã","type":1,"pageTitle":"Manual Control","url":"/domain-event/manual-control#getting-the-events-from-the-queue-and-dispatching-them-elsewhere","content":" You can get the undispatched events in the queue by calling popDomainEvents().  use Rekalogika\\DomainEvent\\DomainEventAwareEntityManagerInterface; /** @var DomainEventAwareEntityManagerInterface $entityManager */ $events = $entityManager-&gt;popDomainEvents();   note As it suggests, popDomainEvents() also removes the events from the queue.  Then, you can dispatch them in another place, for example, in another process, or at the end of a batch process.  use Rekalogika\\DomainEvent\\DomainEventAwareEntityManagerInterface; /** @var DomainEventAwareEntityManagerInterface $entityManager */ $entityManager-&gt;recordDomainEvent($events); $entityManager-&gt;dispatchPreFlushDomainEvents(); $entityManager-&gt;flush(); $entityManager-&gt;dispatchPostFlushDomainEvents();   You might find the DomainEventStore object useful. You can use it to store the events in transit. It handles EquatableDomainEventInterface and will automatically discard duplicate events.  use Rekalogika\\DomainEvent\\DomainEventAwareEntityManagerInterface; use Rekalogika\\DomainEvent\\Model\\DomainEventStore; /** @var DomainEventAwareEntityManagerInterface $entityManager */ $domainEventStore = new DomainEventStore(); // a batch process foreach (...) { // ... $domainEventStore-&gt;add($entityManager-&gt;popDomainEvents()); } // ... // now at the end of the batch process $entityManager-&gt;recordDomainEvent($domainEventStore); $entityManager-&gt;dispatchPreFlushDomainEvents(); $entityManager-&gt;flush(); $entityManager-&gt;dispatchPostFlushDomainEvents();   ","version":"Next","tagName":"h2"},{"title":"Multiple Entity Managers‚Äã","type":1,"pageTitle":"Manual Control","url":"/domain-event/manual-control#multiple-entity-managers","content":" When working with multiple entity managers, usually the ManagerRegistry is used to get the correct entity manager. This method still works with domain events without any change.  However, if you need the domain-event-specific methods, you can useDomainEventAwareManagerRegistry in place of ManagerRegistry. It adds several methods to the registry that you can use to manage domain event dispatching:  getDomainEventAwareManager()getDomainEventAwareManagers()getDomainEventAwareManagerForClass()  These are basically the same as their counterparts in ManagerRegistry, only return DomainEventAwareObjectManager instead of ObjectManager. ","version":"Next","tagName":"h2"},{"title":"Introduction & Installation","type":0,"sectionRef":"#","url":"/domain-event/intro","content":"","keywords":"","version":"Next"},{"title":"What is a Domain Event?‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#what-is-a-domain-event","content":" A domain event is simply a regular event like you would normally use with Symfony's EventDispatcher. The difference is that a domain event represents something that has happened in your domain. It has a name that is meaningful to the underlying business that the domain represents. A domain event is usually dispatched by your entities, as opposed to being dispatched from your controllers or other services.  ","version":"Next","tagName":"h2"},{"title":"Why Use Domain Events?‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#why-use-domain-events","content":" A domain event represents a business event that has happened. It is a good way to model the business requirements that say &quot;when something happens, do this&quot;.  A domain event is raised by the part of your code where the event is actually happening. Different part of your application might call the same method on an entity. In some cases, the method is called indirectly, and the caller has no idea that it is being called. By using domain events, the event will be dispatched in all the cases. No need to make sure to dispatch the event from all the different places where the method is called.  The application layer (controllers, services) can tell an entity to do something, but it cannot reliably know if the action is actually performed, or if an additional action is performed. A controller or a service can ask$bookshelf-&gt;removeBook($book), but only the $bookshelf knows if the book was actually removed. And if the event actually happened, the entity can tell the world about it by recording a BookRemoved event.  Some problems might tempt you to inject a service into your entity. With domain events, you can avoid that. Your entity can dispatch an event, and you can set up a listener to react to that event. The relevant services can then correctly act on your entity, instead of the other way around.  ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#features","content":" Works out of the box. No configuration is required for basic features.Simple, unopinionated architecture. Uses plain event objects, and doesn't require much from your domain entities.Uses standard Symfony's EventDispatcher, with the same dispatching semantics &amp; listener registrations.Transaction support.Works with multiple entity managers.Multiple events considered identical are dispatched only once.Four listening strategies: immediate, pre-flush, post-flush, and event bus.Uses Symfony Messenger as the event bus implementation.Utilizes the transactional outbox pattern when publishing events to the event bus to guarantee consistency and delivery.Utilizes Symfony Scheduler to relay undelivered events to the event bus.Does not require you to change how you work with entities.Should work everywhere without any change: in controllers, message handlers, command line, etc.Separated contracts &amp; framework. Useful for enforcing architectural boundaries. Your domain doesn't have to depend on the framework.Symfony Profiler integration. Debug your events in the profiler's events panel.  ","version":"Next","tagName":"h2"},{"title":"To Do‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#to-do","content":" Support for Doctrine MongoDB ODM.Support event inheritance.  ","version":"Next","tagName":"h2"},{"title":"Synopsis‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#synopsis","content":" // // The event // final readonly class PostPublished { public function __construct(public string $postId) {} } // // The entity // use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface; use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait; class Post implements DomainEventEmitterInterface { use DomainEventEmitterTrait; // ... public function setStatus(string $status): void { $originalStatus = $this-&gt;status; $this-&gt;status = $status; // records the published event if the new status is published and it // is different from the original status if ($status === 'published' &amp;&amp; $originalStatus !== $status) { $this-&gt;recordEvent(new PostPublished($this-&gt;id)); } } // ... } // // The listener // use Psr\\Log\\LoggerInterface; use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPostFlushDomainEventListener; class PostEventListener { public function __construct(private LoggerInterface $logger) {} // will be called after the post is published and the entity manager is // flushed #[AsPostFlushDomainEventListener] public function onPostPublished(PostPublished $event) { $postId = $event-&gt;postId; $this-&gt;logger-&gt;info(&quot;Post $postId has been published.&quot;); } } // // The caller // use Doctrine\\ORM\\EntityManagerInterface; /** @var Post $post */ /** @var EntityManagerInterface $entityManager */ $post-&gt;setStatus('published'); $entityManager-&gt;flush(); // the event will be dispatched after the flush above, afterwards the listener // above will be called, sending a message to the logger   ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony Flex Open a command console, enter your project directory and execute: composer require rekalogika/domain-event   ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#contributing","content":" This framework consists of multiple repositories split from a monorepo. Be sure to submit issues and pull requests to therekalogika/domain-event-src monorepo. ","version":"Next","tagName":"h2"},{"title":"Basic Usage","type":0,"sectionRef":"#","url":"/domain-event/basic-usage","content":"","keywords":"","version":"Next"},{"title":"Creating Domain Events‚Äã","type":1,"pageTitle":"Basic Usage","url":"/domain-event/basic-usage#creating-domain-events","content":" Domain events are plain old PHP objects that you create to represent a specific event happening in your domain. There is no particular requirement for these classes, except they should be serializable. For event bus dispatching, they must be serializable.  // our event superclass for the Post object abstract class AbstractPostEvent { public function __construct(private string $id) { } public function getId(): string { return $this-&gt;id; } } // our concrete events final class PostCreated extends AbstractPostEvent { } final class PostChanged extends AbstractPostEvent { } final class PostRemoved extends AbstractPostEvent { }   ","version":"Next","tagName":"h2"},{"title":"Recording Events‚Äã","type":1,"pageTitle":"Basic Usage","url":"/domain-event/basic-usage#recording-events","content":" Your emitters (entities) must implement DomainEventEmitterInterface. There is a DomainEventEmitterTrait to help you with that. To record events, you can use the method recordEvents() defined in the trait.  use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface; use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait; use Symfony\\Component\\Uid\\UuidV7; class Post implements DomainEventEmitterInterface { use DomainEventEmitterTrait; private string $id; private string $title; /** @var Collection&lt;int,Comment&gt; */ private Collection $comments; public function __construct(string $title) { $this-&gt;id = new UuidV7(); $this-&gt;title = $title; $this-&gt;comments = new ArrayCollection(); $this-&gt;recordEvent(new PostCreated($this-&gt;id)); } // __remove() is our pseudo magic method that gets triggered when the entity // is about to be removed from the persistence layer public function __remove() { $this-&gt;recordEvent(new PostRemoved($this-&gt;id)); } public function setTitle(string $title): void { $this-&gt;title = $title; $this-&gt;recordEvent(new PostChanged($this-&gt;id)); } }   ","version":"Next","tagName":"h2"},{"title":"Listening to Events‚Äã","type":1,"pageTitle":"Basic Usage","url":"/domain-event/basic-usage#listening-to-events","content":" When an entity records the event, the event will be dispatched up to four times: immediately when it is recorded (immediate strategy), before the flush() is called (pre-flush strategy), and after the flush() is called (post-flush strategy). Additionally, with the optional rekalogika/domain-event-outboxpackage, the event will be published on an event bus.  To listen to the events, you can use the usual Symfony way of listening to events, where the event listener will be invoked after you call flush():  use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener; #[AsEventListener] class PostEventListener { // this method will be invoked after a new Post is persist()-ed &amp; flush()-ed public function __invoke(PostCreated $event) { $postId = $event-&gt;getId(); // ... } }   To choose different dispatching strategy, you can use different attributes:  use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsImmediateDomainEventListener; use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPostFlushDomainEventListener; use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPreFlushDomainEventListener; use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPublishedDomainEventListener; class PostEventListener { #[AsImmediateDomainEventListener] public function immediate(PostCreated $event) { // this will be executed immediately after the entity records the event } #[AsPreFlushDomainEventListener] public function preFlush(PostCreated $event) { // this will be executed when you flush() the new post. before the actual // flush() } #[AsPostFlushDomainEventListener] public function postFlush(PostCreated $event) { // this will be executed when you flush() the new post. after the actual // flush() } #[AsPublishedDomainEventListener] public function eventBus(PostCreated $event) { // the event will be published on the event bus, and this method will // be executed when the event is consumed from the bus } }   note AsEventListener and AsPostFlushDomainEventListener currently have identical behavior, but they utilize different event dispatchers. We plan to have a different event dispatcher behavior withAsPostFlushDomainEventListener while keeping AsEventListener standard.Doing a flush() inside a pre-flush listener is not allowed and will result in a FlushNotAllowedException.AsPublishedDomainEventListener requires the optionalrekalogika/domain-event-outbox package.  ","version":"Next","tagName":"h2"},{"title":"Dispatching the Events‚Äã","type":1,"pageTitle":"Basic Usage","url":"/domain-event/basic-usage#dispatching-the-events","content":" With pre and post-flush strategy, the actual dispatching of the events is done when you call flush() on the entity manager. It will do the following in order:  Collects the events from the entities, and adds them to the pre-flush and post-flush queue. Then it dispatches the events in the pre-flush queue.Calls the actual flush().Dispatches post-flush events in the queue.  The pre-flush events might generate additional events, in which case they will also be dispatched in the pre-flush phase. It does that until there are no more events to dispatch.  note There is a safeguard in place to prevent infinite loops. If the pre-flush events keep generating more pre-flush events, it will throw aSafeguardTriggeredException after 100 iterations.  The AsPublishedDomainEventListener strategy works by adding the events to the outbox table in the same phase as the pre-flush strategy. Then the message relay reads the table, and publishes the events to the event bus. ","version":"Next","tagName":"h2"},{"title":"Pseudo Magic Method","type":0,"sectionRef":"#","url":"/domain-event/pseudo-magic-method","content":"Pseudo Magic Method The interface DomainEventEmitterInterface implemented by your entities and the corresponding DomainEventEmitterTrait add a pseudo magic method __remove(). The __remove() method is called when the entity is about to be removed from the database. You can use this method to record a 'removed' event. use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface; use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait; class Post implements DomainEventEmitterInterface { use DomainEventEmitterTrait; // ... public function __remove() { $this-&gt;recordEvent(new PostRemoved($this-&gt;id)); } } This mechanism is devised because otherwise the entity cannot possibly know if it is being removed from the persistence layer.","keywords":"","version":"Next"},{"title":"Outbox Installation & Configuration","type":0,"sectionRef":"#","url":"/domain-event/outbox-setup","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Outbox Installation & Configuration","url":"/domain-event/outbox-setup#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony Flex Open a command console, enter your project directory and execute: composer require rekalogika/domain-event-outbox   ","version":"Next","tagName":"h2"},{"title":"Symfony Messenger Configuration‚Äã","type":1,"pageTitle":"Outbox Installation & Configuration","url":"/domain-event/outbox-setup#symfony-messenger-configuration","content":" The package requires a Symfony Messenger bus namedrekalogika.domain_event.bus. You can accomplish that by creating the configuration file:  config/packages/rekalogika_domain_event_outbox.yaml framework: messenger: buses: rekalogika.domain_event.bus: default_middleware: allow_no_handlers: true   ","version":"Next","tagName":"h2"},{"title":"Make Sure the Default messenger.yaml Has an Explicit Bus Configuration‚Äã","type":1,"pageTitle":"Outbox Installation & Configuration","url":"/domain-event/outbox-setup#make-sure-the-default-messengeryaml-has-an-explicit-bus-configuration","content":" danger The default Symfony Messenger configuration does not define buses anddefault_bus. You need to make sure they are present in your configuration file. Otherwise, our bus configuration above will silently become the default bus.  config/packages/messenger.yaml # default messenger.yaml with explicit default bus framework: messenger: failure_transport: failed transports: # https://symfony.com/doc/current/messenger.html#transport-configuration async: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' options: use_notify: true check_delayed_interval: 60000 retry_strategy: max_retries: 3 multiplier: 2 failed: 'doctrine://default?queue_name=failed' # sync: 'sync://' ### You need to add this ### START default_bus: messenger.bus.default buses: messenger.bus.default: null ### END routing: Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage: async Symfony\\Component\\Notifier\\Message\\ChatMessage: async Symfony\\Component\\Notifier\\Message\\SmsMessage: async # Route your messages to the transports # 'App\\Message\\YourMessage': async   ","version":"Next","tagName":"h2"},{"title":"Configure Your Domain Events Routing‚Äã","type":1,"pageTitle":"Outbox Installation & Configuration","url":"/domain-event/outbox-setup#configure-your-domain-events-routing","content":" With this package, your domain events become the message classes of the Symfony Messenger. And like other Symfony Messenger messages, you may need to configure the routing for your domain events. You can do that like the following.  config/packages/messenger.yaml framework: messenger: # ... routing: # ... 'Rekalogika\\DomainEvent\\Outbox\\Message\\MessageRelayStartMessage': async 'App\\DomainEvent\\*': async   ","version":"Next","tagName":"h2"},{"title":"Bundle Configuration‚Äã","type":1,"pageTitle":"Outbox Installation & Configuration","url":"/domain-event/outbox-setup#bundle-configuration","content":" The bundle defines the following configuration option:  config/packages/rekalogika_domain_event_outbox.yaml rekalogika_domain_event_outbox: # The name of database table used to store the outgoing messages outbox_table: rekalogika_event_outbox  ","version":"Next","tagName":"h2"},{"title":"Tips","type":0,"sectionRef":"#","url":"/domain-event/tips","content":"","keywords":"","version":"Next"},{"title":"Use UUIDs as Identifiers‚Äã","type":1,"pageTitle":"Tips","url":"/domain-event/tips#use-uuids-as-identifiers","content":" Use UUIDs as entity identifiers &amp; have the entities generate one for themselves on instantiation. That means new entities already have an ID before flush().  use Symfony\\Component\\Uid\\UuidV7; class Post { private string $id; public function __construct(string $title) { $this-&gt;id = new UuidV7(); } // ... }   This way, you can reliably store the ID in your event objects, instead of the object itself. Using the ID in the events means your events can be reliably serialized. It improves logistics because you can pass them anywhere without modification, and without creating additional event objects.  ","version":"Next","tagName":"h2"},{"title":"Persist Early after Entity Creation‚Äã","type":1,"pageTitle":"Tips","url":"/domain-event/tips#persist-early-after-entity-creation","content":" On entity creation, persist() your entities early, and flush() late. This is especially important if you are using the immediate listening strategy. It will let your listener obtain the entity instance by calling find() on the repository using the entity's identifier.  $post = new Post(); $entityManager-&gt;persist($post); $post-&gt;setContent('Hello, World!'); $entityManager-&gt;flush();   ","version":"Next","tagName":"h2"},{"title":"Choosing Dispatching Strategy‚Äã","type":1,"pageTitle":"Tips","url":"/domain-event/tips#choosing-dispatching-strategy","content":" If you want to do something similar to what you are used to doing with application events, you probably want the post-flush strategy. If you are already using Symfony Messenger, consider using the event bus strategy instead for more reliability.  Use pre-flush events to make alterations to your domain that will beflush()-ed together along with the other changes.  ","version":"Next","tagName":"h2"},{"title":"No Event Inheritance, Yet‚Äã","type":1,"pageTitle":"Tips","url":"/domain-event/tips#no-event-inheritance-yet","content":" Symfony Event Dispatcher does not currently support event inheritance. This needs to be mentioned because many programmers expect an event dispatcher to support event inheritance, especially when working with a large amount of event objects.  This is not ideal, and we want this feature in the future. But for now, this is a limitation that you need to be aware of.  ","version":"Next","tagName":"h2"},{"title":"Idempotent Event Bus Listeners‚Äã","type":1,"pageTitle":"Tips","url":"/domain-event/tips#idempotent-event-bus-listeners","content":" Idempotence is a desirable trait in event bus messaging. This means if a listener receives the same event multiple times, it should have the same effect as if it received the event only once.  With an event bus, a system failure might cause the same event to be dispatched more than once. An idempotent listener won't cause any harm when that happens.  In simpler cases, you can leverage EquatableDomainEventInterface. If your event implements EquatableDomainEventInterface, your listener can get the event's signature and store it somewhere. If the event is dispatched again, the listener can check if it has already processed the event. ","version":"Next","tagName":"h2"},{"title":"Transactional Outbox Pattern","type":0,"sectionRef":"#","url":"/domain-event/transactional-outbox-pattern","content":"","keywords":"","version":"Next"},{"title":"How It Works‚Äã","type":1,"pageTitle":"Transactional Outbox Pattern","url":"/domain-event/transactional-outbox-pattern#how-it-works","content":" During the same time as the pre-flush phase, for each of the domain events, the framework wraps the event in a Symfony Messenger Envelope, and then in anOutboxMessage object. Then, it calls the entity manager to persist theOutboxMessage object.  When flush() or commit() is finally called, Doctrine will save theOutboxMessage objects in the same transaction as the rest of the changes to the domain entities. This guarantees that the events are published only if the transaction is successful.  When the message relay is executed. It reads the outbox table, publishes the events to the event bus, and removes the events from the outbox table.  ","version":"Next","tagName":"h2"},{"title":"Comparison with the Post-Flush Strategy‚Äã","type":1,"pageTitle":"Transactional Outbox Pattern","url":"/domain-event/transactional-outbox-pattern#comparison-with-the-post-flush-strategy","content":" With the post-flush strategy, if an error happens during the dispatching, then the event will be lost.  In contrast, the transactional outbox pattern guarantees that the event will be delivered. If an error happens, both the events and the entire changes to the domain model will not be committed to the database. Because all the other changes are rolled back, the discarded events would have been invalid anyway, and should not be delivered.  ","version":"Next","tagName":"h2"},{"title":"Message Relay‚Äã","type":1,"pageTitle":"Transactional Outbox Pattern","url":"/domain-event/transactional-outbox-pattern#message-relay","content":" Message relay's job is to read the outbox table, publish the events to the event bus, and remove the events from the outbox table. The message relay is executed using the following mechanisms:  Using the kernel.terminate and console.terminate events, a listener checks if there are new messages sent to the outbox in the current session. If there are, it tells the message relay to run using Symfony Messenger bus.Using Symfony Scheduler, the message relay is executed every hour. This is mainly used for safety, in case the above mechanism failed to execute for whatever reason.Manually, using the console command bin/console rekalogika:domain-event:relay.  ","version":"Next","tagName":"h2"},{"title":"Message Preparer‚Äã","type":1,"pageTitle":"Transactional Outbox Pattern","url":"/domain-event/transactional-outbox-pattern#message-preparer","content":" When the domain events are being saved to the outbox table, the message preparer services are executed to prepare the events. By default, it adds theUserIdentifierStamp to the envelope. You can add your own message preparer by implementing the MessagePreparerInterface (tag name:rekalogika.domain_event.outbox.message_preparer) ","version":"Next","tagName":"h2"},{"title":"Transactions","type":0,"sectionRef":"#","url":"/domain-event/transaction","content":"","keywords":"","version":"Next"},{"title":"Semantics‚Äã","type":1,"pageTitle":"Transactions","url":"/domain-event/transaction#semantics","content":" Immediate events are dispatched immediately as usual.Pre-flush events will be dispatched before every flush() regardless of the transaction status.Post-flush events will be dispatched after the outermost commit().rollback() clears the pending post-flush events collected during the transaction, but retains the events collected before the transaction.The events are collected only on flush().  ","version":"Next","tagName":"h2"},{"title":"Managing Transaction Using DBAL is not Supported‚Äã","type":1,"pageTitle":"Transactions","url":"/domain-event/transaction#managing-transaction-using-dbal-is-not-supported","content":" warning Doing the transaction by hand using DBAL's Connection is not supported. Always do the transaction using entity manager's methods of beginTransaction(),commit(), rollback(), transactional() and wrapInTransaction().  Don't do like this snippet taken from Doctrine's documentation:  // warning: don't do this $em-&gt;getConnection()-&gt;beginTransaction(); // üëé try { // ... do some work $user = new User; $user-&gt;setName('George'); $em-&gt;persist($user); $em-&gt;flush(); $em-&gt;getConnection()-&gt;commit(); // üëé } catch (Exception $e) { $em-&gt;getConnection()-&gt;rollBack(); // üëé throw $e; }   Instead, do this:  $em-&gt;beginTransaction(); // üëç try { // ... do some work $user = new User; $user-&gt;setName('George'); $em-&gt;persist($user); $em-&gt;flush(); $em-&gt;commit(); // üëç } catch (Exception $e) { $em-&gt;rollback(); // üëç throw $e; }  ","version":"Next","tagName":"h2"},{"title":"Testing","type":0,"sectionRef":"#","url":"/domain-event/testing","content":"","keywords":"","version":"Next"},{"title":"Undispatched Event Problem‚Äã","type":1,"pageTitle":"Testing","url":"/domain-event/testing#undispatched-event-problem","content":" Rekalogika\\DomainEvent\\Exception\\UndispatchedEventsException: There are still 1 undispatched domain events. If you disable autodispatch, you have to dispatch them manually or clear them.  Our entity manager checks if there are any undispatched domain events in__destroy(). If there are, it throws an exception. This poses a problem in unit tests, especially with negative tests.  To prevent the problem, you need to prevent entity manager from going out of scope. In setUp(), save the entity manager to a property, then intearDown(), call clearUndispatchedEvents() on the entity manager.  use Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase; use Rekalogika\\DomainEvent\\DomainEventAwareEntityManagerInterface; class SomeTest extends KernelTestCase { protected DomainEventAwareEntityManagerInterface $entityManager; public function setUp(): void { parent::setUp(); $this-&gt;entityManager = self::getContainer()-&gt;get(DomainEventAwareEntityManagerInterface::class); } public function tearDown(): void { $this-&gt;entityManager-&gt;clearUndispatchedEvents(); parent::tearDown(); } // ... }   ","version":"Next","tagName":"h2"},{"title":"Immediate Dispatcher in Unit Tests‚Äã","type":1,"pageTitle":"Testing","url":"/domain-event/testing#immediate-dispatcher-in-unit-tests","content":" RuntimeException: ImmediateDomainEventDispatcher has not been initialized.  Immediate event dispatcher works by installing the event dispatcher to a static variable. This installation happens during the kernel boot.  If the kernel is not booted, there is no opportunity to install the event dispatcher. This usually happens only in isolated unit tests. To address the problem, you can install a stub event dispatcher manually like this.  use PHPUnit\\Framework\\TestCase; use Rekalogika\\DomainEvent\\ImmediateDomainEventDispatcherInstaller; use Symfony\\Component\\EventDispatcher\\EventDispatcher; class SomeTest extends TestCase { public function setUp(): void { $installer = new ImmediateDomainEventDispatcherInstaller(new EventDispatcher); $installer-&gt;install(); } // ... }   note The stub dispatcher doesn't do anything. If you want to test the dispatching, you need to get the real dispatcher from the container.  tip This is not necessary if your test extends KernelTestCase because it will boot the kernel for you automatically. ","version":"Next","tagName":"h2"},{"title":"rekalogika/file","type":0,"sectionRef":"#","url":"/file","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/file","url":"/file#sections","content":" üìÑÔ∏è Introduction High-level file abstraction library built on top of Flysystem. It lets you work üìÑÔ∏è Installation &amp; Configuration This section explains how to install and configure the rekalogika/file üìÑÔ∏è Concepts &amp; Terms Terms üìÑÔ∏è Using File &amp; FileRepository When using this framework, the user will primarily work with the üìÑÔ∏è Adapters The library provides a FileAdapter class that can be used to adapt or convert üìÑÔ∏è Metadata This chapter describes how file metadata is handled by this library. üìÑÔ∏è Derivation This chapter describes the concept of file derivation and the pipe &amp; filter üìÑÔ∏è Lazy-Loading Proxy This chapter describes how to lazy-load a file. üìÑÔ∏è Null File This chapter describes the null object pattern applied to files. ","version":"Next","tagName":"h2"},{"title":"rekalogika/file-bundle","type":0,"sectionRef":"#","url":"/file-bundle","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/file-bundle","url":"/file-bundle#sections","content":" üìÑÔ∏è Introduction Symfony bundle to easily integrate the rekalogika/file framework and related üìÑÔ∏è Installation &amp; Configuration This chapter describes how to install and configure the bundle. üìÑÔ∏è Associating Files to Doctrine Entities This chapter describes how to create a file property in a Doctrine entity that üìÑÔ∏è Working With Entities &amp; Files You can work with the entities and associated files as usual, and they will work üìÑÔ∏è File Uploads Using FilePond This chapter describes how to easily create a form for uploading files. üìÑÔ∏è Integration With Symfony Components This chapter describes how to integrate this framework with the typical Symfony üìÑÔ∏è Serving Files This chapter describes how to serve files to the client web browser. üìÑÔ∏è Filtering In this framework, 'filtering' is the opportunistic creation &amp; caching of üìÑÔ∏è Translation This chapter explains localization support in the framework. üìÑÔ∏è Mandatory File This chapter explains the situation where a file is mandatory to the entity. üìÑÔ∏è Lazy-Loading Files This chapter describes how to implement the lazy-loading of files in your üìÑÔ∏è Replicating Metadata in Entities This chapter describes how to replicate file metadata in your entities. üìÑÔ∏è Implementing a Collection of Files This chapter describes how to implement a collection of files, or one-to-many üìÑÔ∏è Streaming a ZIP File of Files This chapter explains how to stream-download a ZIP file containing several üóÉÔ∏è Advanced 4 items ","version":"Next","tagName":"h2"},{"title":"Marking Entities using Interface","type":0,"sectionRef":"#","url":"/file-bundle/advanced/file-association-interface","content":"Marking Entities using Interface As an alternative to using attributes to mark your entities, you can also have your entities implement FileAssociationInterface. note We recommend using attributes instead of implementing the interface as described in Associating Files with Doctrine Entities. use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\Association\\FileAssociationInterface; class Product implements FileAssociationInterface { /** * The file properties must accept FileInterface */ private ?FileInterface $image = null; /** * This method gives the list of properties of this class that will * be managed by this framework. In this case it tells us that the * property 'image' is a file property we need to manage. */ public static function getFileAssociationPropertyList(): array { return ['image']; } /** * The framework needs the ID of the entity. By default, it will call getId() * of the object to get the ID. */ public function getId(): string { return $this-&gt;id; } // // The rest of this class is inconsequential to the framework // /** * This framework reads and writes directly to the properties, even if * private. Therefore, you are free to have your own business logic in the * getters and setters. */ public function getImage(): FileInterface { if (date('m-d') == '04-01') { // if today is april 1st return new File('shock-image.jpg'); // april fools! } return $this-&gt;image; } public function setImage(?FileInterface $image): self { if ($this-&gt;status == 'published') { throw new \\Exception(&quot;Cannot change a published product's image&quot;); } $this-&gt;image = $image; return $this; } } ","keywords":"","version":"Next"},{"title":"Creating Filters","type":0,"sectionRef":"#","url":"/file-bundle/advanced/creating-filters","content":"Creating Filters This chapter explains how to create your own file filters usingAbstractFileFilter. Preparation You need to install the package rekalogika/file-derivation to use this feature: composer require rekalogika/file-derivation To create a filter class, you can extend AbstractFileFilter, create a method (or more) for the callers to specify the filtering parameters, and implement all the abstract methods. The following is an example filter class that creates a derived file by (rather uselessly) appending a text to the original content: use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Derivation\\Filter\\AbstractFileFilter; use Rekalogika\\File\\TemporaryFile; class TextAppender extends AbstractFileFilter { private string $text; /** * Your custom method that lets the caller specify the filtering parameters. */ public function appendText(string $text): self { assert(ctype_alpha($text)); // ensure alpha characters only $this-&gt;text = $text; return $this; } /** * This method return the derivation ID from the filtering parameters the * caller provided. */ #[\\Override] protected function getDerivationId(): string { return 'append_' . $this-&gt;text; } #[\\Override] protected function process(): FileInterface { $originalContent = $this-&gt;getSourceFile()-&gt;getContent(); return new TemporaryFile::createFromString($originalContent . $this-&gt;text); } } If you are using autoconfiguration, then you are all set. Otherwise, you need to tag your class with rekalogika.file.derivation.filter: config/services.yaml services: App\\TextAppender: tags: - { name: 'rekalogika.file.derivation.filter' } A caller will be able to use the above filter like the following: use Rekalogika\\Contracts\\File\\FileInterface; /** @var TextAppender $textAppender */ /** @var FileInterface $file */ $derivedFile = $textAppender -&gt;take($file) -&gt;appendText('foo') -&gt;getResult(); ","keywords":"","version":"Next"},{"title":"File Association Internal Details","type":0,"sectionRef":"#","url":"/file-bundle/advanced/entity-association-internal","content":"","keywords":"","version":"Next"},{"title":"Where The Files Are Stored‚Äã","type":1,"pageTitle":"File Association Internal Details","url":"/file-bundle/advanced/entity-association-internal#where-the-files-are-stored","content":" FileLocationResolverInterface decides where to store the file. It takes the entity instance and the name of the property holding the file and outputs aFilePointer describing where the file in that property will be stored. The default implementation DefaultFileLocationResolver stores files into the filesystem with the identifier 'default' and the key similar to the following:  entity/ffa87ef3fc5388bc8b666e2cec17d27cc493d0c1/image/e5/80/72/6d/31337 ‚ï∞----‚ïØ ‚ï∞--------------------------------------‚ïØ ‚ï∞---‚ïØ ‚ï∞---------‚ïØ ‚ï∞---‚ïØ A B C D E   A: Prefix, defaults to 'entity'.B: SHA-1 hash of the entity's fully-qualified class name.C: Property name.D: Hashed directories of the entity's ID. The ID is hashed using SHA-1, then split by 2 characters each. Then, the first four of them are taken to form the directory structure.E: The entity ID.  This default should be sufficient in most cases, for all entities, and all filesystems. It masks internal details (entity class names). It does not pile too many files in one directory (some filesystems struggle with a huge amount of files in a directory). The ordering is chosen to make it easier for manual administration tasks.  To obtain the entity's ID, DefaultFileLocationResolver callsObjectIdResolverInterface. By default, it is DefaultObjectIdResolver which calls getId() of the entity.  To override this default behavior, you can create your own implementation of either FileLocationResolverInterface or ObjectIdResolverInterface. If you are using autoconfiguration, then you are good to go. Otherwise, you need to tag them in the service container:  services: App\\MyFileLocationResolver: tags: - { name: 'rekalogika.file.association.file_location_resolver' } App\\MyObjectIdResolver: tags: - { name: 'rekalogika.file.association.object_id_resolver' }   ","version":"Next","tagName":"h2"},{"title":"About File Names‚Äã","type":1,"pageTitle":"File Association Internal Details","url":"/file-bundle/advanced/entity-association-internal#about-file-names","content":" Like modern key-value cloud storage services, this framework uses the concept of 'keys', not 'paths'. The file name is not part of the key but is stored in the metadata, along with other properties of the file. The original file name is never taken into consideration when determining where to store the file.  The metadata itself is stored in a sidecar file. Using the example above, the metadata will be stored in this location:  entity/ffa87ef3fc5388bc8b666e2cec17d27cc493d0c1/image/e5/80/72/6d/31337.metadata   The caller can obtain the file name using the appropriate methods:  $imageFilename = $entity-&gt;getImage()?-&gt;getName();   When possible, the framework should have copied the file name of the original file to the destination metadata when the file was first associated with the entity.  ","version":"Next","tagName":"h2"},{"title":"How It Works‚Äã","type":1,"pageTitle":"File Association Internal Details","url":"/file-bundle/advanced/entity-association-internal#how-it-works","content":" The storage key of the file is deterministic. It is determined only by the object's class name, the object's ID, and the name of the property containing the file. As long as those don't change, the key will remain the same.  When persisting an entity, the framework will calculate the destination storage key of every applicable property of the entity, and compare it to the current file residing on each property:  If both are the same, the framework leaves it alone.If they are different, the framework will copy the file from the entity to the storage destination.If null, the framework will attempt to remove the file from the storage, irrespective of whether the file exists or not.  ","version":"Next","tagName":"h2"},{"title":"Architecture‚Äã","type":1,"pageTitle":"File Association Internal Details","url":"/file-bundle/advanced/entity-association-internal#architecture","content":" In a nutshell: Doctrine Unit Of Work ‚û°Ô∏è Doctrine Events ‚û°Ô∏è rekalogika/reconstitutor ‚û°Ô∏è InterfaceReconstitutor &amp; AttributeReconstitutor‚û°Ô∏è FileAssociationManager ‚û°Ô∏è FileRepository (from rekalogika/file).  InterfaceReconstitutor &amp; AttributeReconstitutor are the entry points of this package. They execute methods of FileAssociationManager which works with the entities and FileRepository to manage the association between the entities and files.  InterfaceReconstitutor &amp; AttributeReconstitutor are registered to the service container so that they are called by our rekalogika/reconstitutor when the relevant events are being emitted by Doctrine. The service configuration is done by the package rekalogika/file-bundle. ","version":"Next","tagName":"h2"},{"title":"Object ID Resolver","type":0,"sectionRef":"#","url":"/file-bundle/advanced/object-id-resolver","content":"","keywords":"","version":"Next"},{"title":"Creating An Object ID Resolver‚Äã","type":1,"pageTitle":"Object ID Resolver","url":"/file-bundle/advanced/object-id-resolver#creating-an-object-id-resolver","content":" use Rekalogika\\Contracts\\File\\Association\\ObjectIdResolverInterface; class MyObjectIdResolver implements ObjectIdResolverInterface { public function getObjectId(object $object): string { // your implementation here } }   If you are using autoconfiguration, then it is all set. If not, you need to register your class in the service container:  config/services.yaml services: App\\MyObjectIdResolver: tags: - { name: 'rekalogika.file.association.object_id_resolver' }  ","version":"Next","tagName":"h2"},{"title":"Associating Files to Doctrine Entities","type":0,"sectionRef":"#","url":"/file-bundle/doctrine-entity","content":"","keywords":"","version":"Next"},{"title":"Creating a File Property in an Entity‚Äã","type":1,"pageTitle":"Associating Files to Doctrine Entities","url":"/file-bundle/doctrine-entity#creating-a-file-property-in-an-entity","content":" To create a file property in an entity that will be managed by this framework, you need to:  Create a property that accepts a FileInterface.Add the attribute #[WithFileAssociation] to the class.Add the attribute #[AsFileAssociation] to the property.  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Association\\Attribute\\WithFileAssociation; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; use Rekalogika\\File\\File; #[WithFileAssociation] class Product { /** * The file property must accept a FileInterface */ #[AsFileAssociation] private ?FileInterface $image = null; // // The rest of this class is inconsequential to the framework // /** * This framework reads and writes directly to the properties, even if * private. Therefore, you are free to have your own business logic in the * getters and setters. */ public function getImage(): FileInterface { if (date('m-d') == '04-01') { // if today is april 1st return new File('shock-image.jpg'); // april fools! } return $this-&gt;image; } public function setImage(?FileInterface $image): self { if ($this-&gt;status == 'published') { throw new \\Exception(&quot;Cannot change a published product's image&quot;); } $this-&gt;image = $image; return $this; } }   ","version":"Next","tagName":"h2"},{"title":"Mandatory File‚Äã","type":1,"pageTitle":"Associating Files to Doctrine Entities","url":"/file-bundle/doctrine-entity#mandatory-file","content":" If your business logic necessitates that the file is mandatory to an entity, you can omit the ? in the property type hint:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Association\\Attribute\\WithFileAssociation; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; #[WithFileAssociation] class Product { #[AsFileAssociation] private FileInterface $image; }   Read more about mandatory files in the chapter Mandatory File. ","version":"Next","tagName":"h2"},{"title":"Filtering","type":0,"sectionRef":"#","url":"/file-bundle/filtering","content":"","keywords":"","version":"Next"},{"title":"ImageResizer‚Äã","type":1,"pageTitle":"Filtering","url":"/file-bundle/filtering#imageresizer","content":" Preparation You need to install the package rekalogika/file-image to use this feature: composer require rekalogika/file-image   ","version":"Next","tagName":"h2"},{"title":"PHP Usage‚Äã","type":1,"pageTitle":"Filtering","url":"/file-bundle/filtering#php-usage","content":" In PHP files, you need to inject the ImageResizer class to your service or controller:  use Rekalogika\\File\\Image\\ImageResizer; use Rekalogika\\Contracts\\File\\FileInterface; /** @var ImageResizer $imageResizer */ /** @var FileInterface $image */ $resizedImage = $imageResizer -&gt;take($image) -&gt;resize(100, ImageResizer::ASPECRATIO_SQUARE) -&gt;getResult();   The first time it is called, the filter will create a 100-pixel-square-cropped image from the original image. The second time it is called, the filter will return the already created derived image.  If the original image is updated, the filter will create a new derived image and overwrite the old one.  ","version":"Next","tagName":"h3"},{"title":"Twig Usage‚Äã","type":1,"pageTitle":"Filtering","url":"/file-bundle/filtering#twig-usage","content":" In Twig templates, you can use the image_resize filter. For example:  &lt;img src=&quot;{{ image_file|image_resize(100, 'square')|temporary_url }}&quot; /&gt;   The example above will give us a temporary URL to a square-cropped image with a maximum width or height of 100 pixels from the original imageimage_file. ","version":"Next","tagName":"h3"},{"title":"File Uploads Using FilePond","type":0,"sectionRef":"#","url":"/file-bundle/file-upload-filepond","content":"","keywords":"","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"File Uploads Using FilePond","url":"/file-bundle/file-upload-filepond#features","content":" Uses FilePond in the frontend, and Symfony Form in the backend.DX improvement. Simply add a field to your form using FilePondType orFilePondCollectionType and you get file upload, image preview, file removal, and all the other features.To upload, users can browse the files, use drag and drop, or copy &amp; paste them.Looks nice out of the box.No need to write any JavaScript code. Options are supplied using HTML attributes.Upload files along with the other properties of your entity, no need to create a separate form, controller, or logic just for uploading files and removing them.Localization support. Automatically detects the user's locale and displays messages in the correct language.Image preview of uploaded files &amp; images. Also shows the preview for previously uploaded files when editing an entity.To delete the file, users can use the remove button on the preview and submit the form.Ships with the kitchen sink. Includes all the plugins that can be configured without Javascript, and all the available locales.  ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"File Uploads Using FilePond","url":"/file-bundle/file-upload-filepond#installation","content":" Preinstallation checklists:  Make sure Composer is installed globally, as explained in the installation chapter of the Composer documentation.Make sure you haveStimulusBundleconfigured in your app.Make sure your project has Symfony Flex installed and enabled (it is enabled by default).  Open a command console, enter your project directory, and execute:  composer require rekalogika/file-filepond   If you're using WebpackEncore, install your assets and restart Encore (not needed if you're using AssetMapper):  YarnNPM yarn install --force yarn watch   ","version":"Next","tagName":"h2"},{"title":"Usage for a Single File Property‚Äã","type":1,"pageTitle":"File Uploads Using FilePond","url":"/file-bundle/file-upload-filepond#usage-for-a-single-file-property","content":" Simply add your field to your form, using the form type FilePondType. Example:  use Rekalogika\\File\\Bridge\\FilePond\\FilePondType; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\FormBuilderInterface; class MyFormType extends AbstractType { public function buildForm(FormBuilderInterface $builder, array $options): void { $builder // ... -&gt;add('image', FilePondType::class, [ 'label' =&gt; 'Product Image', 'required' =&gt; false, 'attr' =&gt; [ 'accept' =&gt; 'image/png, image/jpeg' ], 'allow_delete' =&gt; true, ]) ; } }   If allow_delete is true, then the file will be removed on form submission if the user removes the file using the remove button on the preview.  ","version":"Next","tagName":"h2"},{"title":"Usage for a Collection of Files‚Äã","type":1,"pageTitle":"File Uploads Using FilePond","url":"/file-bundle/file-upload-filepond#usage-for-a-collection-of-files","content":" First, you need to set up the relation in your entity like what is described inImplementing a Collection of Files. Then you can useFilePondCollectionType. Example:  use Rekalogika\\File\\Bridge\\FilePond\\FilePondCollectionType; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\FormBuilderInterface; class MyFormType extends AbstractType { public function buildForm(FormBuilderInterface $builder, array $options): void { $builder // ... -&gt;add('images', FilePondCollectionType::class, [ 'label' =&gt; 'Product Images', 'required' =&gt; false, 'attr' =&gt; [ 'accept' =&gt; 'image/png, image/jpeg' ], 'allow_delete' =&gt; true, ]); ; } }   If allow_delete is true, then the file will be removed on form submission if the user removes the file using the remove button on the preview.  ","version":"Next","tagName":"h2"},{"title":"Specifying Options‚Äã","type":1,"pageTitle":"File Uploads Using FilePond","url":"/file-bundle/file-upload-filepond#specifying-options","content":" You can specify FilePond options using the attr option of the form field. The example below will disable replacing files.   -&gt;add('image', FilePondType::class, [ 'attr' =&gt; [ 'data-allow-replace' =&gt; 'false' ], ])   The list of available options can be found in the FilePond propertiesdocumentation.  To specify the option, you need to convert from camelCase to kebab-case, and prefix the property name with data-. For example, the property allowReplacebecomes data-allow-replace.  We also use several plugins that add additional options. You can read thedocumentation of each of the plugins to see what options are available.  This is the list of the enabled plugins:  File EncodeFile MetadataFile PosterFile ValidateSizeFile ValidateTypeImage CropImage EditImage ExifOrientationImage PreviewImage ResizeImage TransformImage ValidateSize  ","version":"Next","tagName":"h2"},{"title":"Caveats and Limitations‚Äã","type":1,"pageTitle":"File Uploads Using FilePond","url":"/file-bundle/file-upload-filepond#caveats-and-limitations","content":" Due to a FilePond bug,FilePondCollectionType uses the file encode plugin to upload the files. It works by encoding the files as Base64 strings, and then sending them to the server. It means the files will be about 33% larger on the wire, it might also trigger application based firewalls that limit the size of the request body, and it might exhaust the browser's or the server's memory if the files are too large.  FilePondType is also affected by the bug. But we can afford to tolerate it as the bug does not appear to affect its function, except that we will get an error in the console every time a file is added to the field. ","version":"Next","tagName":"h2"},{"title":"Installation & Configuration","type":0,"sectionRef":"#","url":"/file-bundle/installation","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Installation & Configuration","url":"/file-bundle/installation#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony Flex Open a command console, enter your project directory, and execute: composer require rekalogika/file-bundle   ","version":"Next","tagName":"h2"},{"title":"Configuration‚Äã","type":1,"pageTitle":"Installation & Configuration","url":"/file-bundle/installation#configuration","content":" The bundle should work out of the box without configuration. By default, it will create a filesystem identified by 'default' that stores files in the directory%kernel.project_dir%/var/storage/default.  The following is the default configuration:  config/packages/rekalogika_file.yaml rekalogika_file: filesystems: # our default filesystem service default: rekalogika.file.default_filesystem default_filesystem_directory: '%kernel.project_dir%/var/storage/default'   ","version":"Next","tagName":"h2"},{"title":"Integration With Flysystem Bundle‚Äã","type":1,"pageTitle":"Installation & Configuration","url":"/file-bundle/installation#integration-with-flysystem-bundle","content":" If you are using the Flysystem bundle, you can use the filesystems defined in the Flysystem bundle:  config/packages/rekalogika_file.yaml rekalogika_file: filesystems: # 'default.storage' is the filesystem key under 'flysystem.storages' # in config/packages/flysystem.yaml default: 'default.storage'  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/file-bundle/intro","content":"","keywords":"","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction","url":"/file-bundle/intro#features","content":" Works out of the box without configuration.DX improvement, less micro-management of entity-file relations.Requires only a single property in the entity for each associated file.Having said that, there is an option to replicate the file metadata in the entity, and it does so without changing how you work with the files.Trait and abstract class to ease implementing a one-to-many relation between an entity and multiple files.Reads and writes directly into the file properties, even if private. You are free to have business logic in the getters and setters.Doesn't require you to update another property of the entity (lastUpdated?) just to make sure the correct Doctrine events will be fired.Localization. Show strings in the user's language.Adapters for various Symfony components, including HttpFoundation, Form, and Validator.Image resizing filter.Temporary URL generation to files.Mandatory files (not null for file properties). Substitute the file with a null object if it is not found in the storage backend.Lazy loading for files.ZIP download of multiple files.Full-featured FilePond-based file upload form.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction","url":"/file-bundle/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/file-bundle/intro#contributing","content":" This framework consists of multiple repositories split from a monorepo. Be sure to submit issues and pull requests to therekalogika/file-src monorepo. ","version":"Next","tagName":"h2"},{"title":"Lazy-Loading Files","type":0,"sectionRef":"#","url":"/file-bundle/lazy-loading","content":"","keywords":"","version":"Next"},{"title":"Property Set-Up‚Äã","type":1,"pageTitle":"Lazy-Loading Files","url":"/file-bundle/lazy-loading#property-set-up","content":" To lazy-load files in your entities, simply add the parameter fetch: 'LAZY' to the AsFileAssociation attribute:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; class Product { #[AsFileAssociation(fetch: 'LAZY')] private FileInterface $image; }   ","version":"Next","tagName":"h2"},{"title":"Getter Set-Up‚Äã","type":1,"pageTitle":"Lazy-Loading Files","url":"/file-bundle/lazy-loading#getter-set-up","content":" To preserve the normal behavior of your entity when using a lazy-loading proxy, you should also modify the getter of the property like this:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\FileProxy; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; class Product { #[AsFileAssociation(fetch: 'LAZY')] private FileInterface $image; public function getImage(): ?FileInterface { return FileProxy::getFile($this-&gt;image); } }   Protip You might want to make sure other methods in the entity don't use the property directly but use the getter instead.  info The class FileDecorator used in metadata replication and file collectionis aware of lazy-loading proxies, so you don't need to modify the getter as explained here if you are using FileDecorator.  ","version":"Next","tagName":"h2"},{"title":"Lazy-Loading Proxy and Mandatory Files‚Äã","type":1,"pageTitle":"Lazy-Loading Files","url":"/file-bundle/lazy-loading#lazy-loading-proxy-and-mandatory-files","content":" If you want both lazy-loading and mandatory files, please read the chapterMandatory File. ","version":"Next","tagName":"h2"},{"title":"Implementing a Collection of Files","type":0,"sectionRef":"#","url":"/file-bundle/collection","content":"","keywords":"","version":"Next"},{"title":"Summary‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#summary","content":" This is what we do to implement a one-to-many relation between an entity and several files:  Create a new entity that will represent a file. For convenience, we provideAbstractFile or FileTrait that your entity can extend or use. Create a one-to-many relation from an entity to the entity in #1.  Preparation You need to install the package rekalogika/file-association-entity to use this feature: composer require rekalogika/file-association-entity   ","version":"Next","tagName":"h2"},{"title":"The many-to-one Side‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#the-many-to-one-side","content":" In the following example, we will be creating an entity Product that will have multiple Images.  You will need your Product entity to extend AbstractFile. Alternatively, if your entity needs to extend another entity, you can use the trait FileTraitinstead.  By Extending AbstractFileBy Using FileTrait Create the Image entity by extending AbstractFile. The following are the relevant parts. use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Domain\\File\\Association\\Entity\\AbstractFile; #[ORM\\Entity] class Image extends AbstractFile { // ... #[ORM\\ManyToOne(inversedBy: 'images')] #[ORM\\JoinColumn(nullable: false)] private ?Product $product = null; public function getProduct(): ?Product { return $this-&gt;product; } public function setProduct(?Product $product): static { $this-&gt;product = $product; return $this; } // ... }   ","version":"Next","tagName":"h2"},{"title":"The one-to-many Side‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#the-one-to-many-side","content":" The relevant parts:  use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity] class Product { // ... #[ORM\\OneToMany(mappedBy: 'product', targetEntity: Image::class, orphanRemoval: true)] private Collection $images; public function __construct() { $this-&gt;images = new ArrayCollection(); } /** * @return Collection&lt;int, Image&gt; */ public function getImages(): Collection { return $this-&gt;images; } public function addImage(Image $image): static { if (!$this-&gt;images-&gt;contains($image)) { $this-&gt;images-&gt;add($image); $image-&gt;setProduct($this); } return $this; } public function removeImage(Image $image): static { if ($this-&gt;images-&gt;removeElement($image)) { // set the owning side to null (unless already changed) if ($image-&gt;getProduct() === $this) { $image-&gt;setProduct(null); } } return $this; } // ... }   ","version":"Next","tagName":"h2"},{"title":"(Optional) Accepting FileInterface in the Adder‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#optional-accepting-fileinterface-in-the-adder","content":" For convenience, you might also want to modify the adder addImage above so that it also accepts an instance of FileInterface:  use Rekalogika\\Contracts\\File\\FileInterface; class Product { // ... public function addImage(Image|FileInterface $image): static { if (!$image instanceof Image) { $image = new Image($image); } if (!$this-&gt;images-&gt;contains($image)) { $this-&gt;images-&gt;add($image); $image-&gt;setProduct($this); } return $this; } // ... }   ","version":"Next","tagName":"h2"},{"title":"(Optional) Decorate the Collection Using FileCollection‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#optional-decorate-the-collection-using-filecollection","content":" In the getter, you can also return a FileCollection wrapping the original collection, and change the type hint. Then, the caller will be able to know that the Collection contains files and also an instance of DirectoryInterface.  use Rekalogika\\Domain\\File\\Association\\Entity\\FileCollection; class Product { // ... /** * @return FileCollection&lt;int,Image&gt; */ public function getImages(): FileCollection { return new FileCollection( $this-&gt;images, sprintf('product %s images', $this-&gt;getName()) ); } // ... }   info The second argument of FileCollection is the name of the file collection, and will be used for the directory name, ZIP file name, etc. Read the chapter Stream a ZIP File if you need to download an entire collection as a ZIP file.  Protip There is also ReadableFileCollection, which is the read-only flavor ofFileCollection.  ","version":"Next","tagName":"h2"},{"title":"Using The Relation‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#using-the-relation","content":" By following the guide above, your Image entity is a FileInterface. Therefore, with the example above, you can treat the Image entity as a file.  use Rekalogika\\File\\File; $product = new Product(); $image1 = new File('product_image_1.jpg'); $image2 = new File('product_image_2.jpg'); $image3 = new File('product_image_3.jpg'); $product -&gt;addImage($image1) -&gt;addImage($image2) -&gt;addImage($image3); foreach ($product-&gt;getImages() as $image) { $name = $image-&gt;getName(); // product_image_1.jpg, etc. $description = $image-&gt;getType()-&gt;getDescription(); // &quot;JPEG image&quot;, etc. }   ","version":"Next","tagName":"h2"},{"title":"Indexing and Querying by File Properties‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#indexing-and-querying-by-file-properties","content":" AbstractFile uses EmbeddedMetadata under the hood. Read more about it in theReplicating Metadata in Entities section. ","version":"Next","tagName":"h2"},{"title":"Mandatory File","type":0,"sectionRef":"#","url":"/file-bundle/mandatory-file","content":"","keywords":"","version":"Next"},{"title":"Making a File Mandatory in an Entity‚Äã","type":1,"pageTitle":"Mandatory File","url":"/file-bundle/mandatory-file#making-a-file-mandatory-in-an-entity","content":" To make a file mandatory in an entity, you simply need to type-hint the file property with FileInterface instead of ?FileInterface:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Association\\Attribute\\WithFileAssociation; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; #[WithFileAssociation] class Product { #[AsFileAssociation] private FileInterface $image; }   By doing so, the framework will consider that the property has to be filled with a FileInterface object, one way or another.  ","version":"Next","tagName":"h2"},{"title":"If The File That is Supposed to be Present is not Present...‚Äã","type":1,"pageTitle":"Mandatory File","url":"/file-bundle/mandatory-file#if-the-file-that-is-supposed-to-be-present-is-not-present","content":" If the property is mandatory, but the actual file does not exist in the storage backend, the framework will substitute it with a MissingFile object. The situation is considered an error and will be logged as such. The administrator or the developer is expected to fix the problem.  The MissingFile object is an implementation of the null object pattern. It appears to your application like a normal file, and should not cause a fatal error; unless you are trying to operate on it that would cause a permanent effect, like saving it to an entity.  MissingFile is also an Exception, but is not thrown by the framework. You can treat it as a regular exception, including getting the stack trace from it.  For more information about NullFile in the framework, read the chapterNull File.  ","version":"Next","tagName":"h2"},{"title":"Mandatory File and Lazy-Loading Proxy‚Äã","type":1,"pageTitle":"Mandatory File","url":"/file-bundle/mandatory-file#mandatory-file-and-lazy-loading-proxy","content":" If you are using a lazy-loading proxy, the property will always be filled by an instance of FileInterface. However, the framework does not check if the file exists in the storage backend until you first try to access the file. If you want a mandatory file, you have to do it yourself:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\FileProxy; use Rekalogika\\Domain\\File\\Null\\NullFile; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; #[WithFileAssociation] class Product { #[AsFileAssociation(fetch: 'LAZY')] private FileInterface $image; public function getImage(): FileInterface { return FileProxy::getFile($this-&gt;image) ?? new NullFile; } }   Protip You might want to make sure other methods in the entity don't use the property directly but use the getter instead. ","version":"Next","tagName":"h2"},{"title":"Serving Files","type":0,"sectionRef":"#","url":"/file-bundle/serving-files","content":"","keywords":"","version":"Next"},{"title":"Streaming Files in a Symfony Controller‚Äã","type":1,"pageTitle":"Serving Files","url":"/file-bundle/serving-files#streaming-files-in-a-symfony-controller","content":" Preparation You need to install the package rekalogika/file-symfony-bridge to use this feature: composer require rekalogika/file-symfony-bridge   To send a file to the web browser, you can use FileResponse:  use Rekalogika\\File\\Bridge\\Symfony\\HttpFoundation\\FileResponse; use Rekalogika\\Contracts\\File\\FileInterface; use Symfony\\Component\\HttpFoundation\\Response; class SomeController { public function download(): Response { /** @var FileInterface $file */ $file = ...; return new FileResponse($file); } }   ","version":"Next","tagName":"h2"},{"title":"Generate a Temporary URL to a File‚Äã","type":1,"pageTitle":"Serving Files","url":"/file-bundle/serving-files#generate-a-temporary-url-to-a-file","content":" Rather than creating a controller action to serve a file for every possible situation, it is more convenient to generate a temporary URL to a file.  Preparation You need to install the package rekalogika/file-server to use this feature: composer require rekalogika/file-server If you are not using Symfony Flex, read the documentation ofrekalogika/file-bundle and rekalogika/temporary-url-bundle to learn how to register the required bundles.  ","version":"Next","tagName":"h2"},{"title":"PHP Usage‚Äã","type":1,"pageTitle":"Serving Files","url":"/file-bundle/serving-files#php-usage","content":" Wire in the TemporaryUrlGeneratorInterface service, and use thegenerateUrl() method to generate a temporary URL to a file. It accepts either a FileInterface or a FilePointerInterface.  use Rekalogika\\TemporaryUrl\\TemporaryUrlGeneratorInterface; use Rekalogika\\File\\FileInterface; use Rekalogika\\File\\FilePointerInterface; /** @var TemporaryUrlGeneratorInterface $temporaryUrlGenerator */ /** @var FileInterface|FilePointerInterface $file */ $url = $temporaryUrlGenerator-&gt;generateUrl($file);   ","version":"Next","tagName":"h3"},{"title":"Twig Usage‚Äã","type":1,"pageTitle":"Serving Files","url":"/file-bundle/serving-files#twig-usage","content":" In Twig templates, you can use the temporary_url filter to generate a temporary URL to a file.  &lt;a href=&quot;{{ file|temporary_url }}&quot; {{ temporary_url_autoexpire() }}&gt; Click here to download &lt;/a&gt;   With images, a convenient pattern is to chain the temporary_url filter with the image_resize filter from the rekalogika/file-image package.  &lt;img src=&quot;{{ my_image|image_resize(200)|temporary_url }}&quot; /&gt;   info The image_resize filter requires the rekalogika/file-image package: composer require rekalogika/file-image Read more in the Filtering section.  ","version":"Next","tagName":"h3"},{"title":"More Information‚Äã","type":1,"pageTitle":"Serving Files","url":"/file-bundle/serving-files#more-information","content":" The generateUrl() method and the temporary_url Twig filter accept several options. Read the documentation of rekalogika/temporary-url-bundle to learn more. ","version":"Next","tagName":"h3"},{"title":"Replicating Metadata in Entities","type":0,"sectionRef":"#","url":"/file-bundle/replicating-metadata-in-entities","content":"","keywords":"","version":"Next"},{"title":"Objective‚Äã","type":1,"pageTitle":"Replicating Metadata in Entities","url":"/file-bundle/replicating-metadata-in-entities#objective","content":" This framework gives you the convenience of requiring only a single property to associate a file with an entity. However, there are cases where it can be useful to have the file's metadata stored in the entity. For example:  To optimize performance together with our lazy-loading feature, especially when you are dealing with a lot of entities and/or files.You need to use the database to index, search, or sort the files based on their metadata.  Using the method described in this chapter, you will be able to accomplish that by replicating the files' metadata in your entities and it does not require you to change the way you work with files.  ","version":"Next","tagName":"h2"},{"title":"Execution‚Äã","type":1,"pageTitle":"Replicating Metadata in Entities","url":"/file-bundle/replicating-metadata-in-entities#execution","content":" Preparation You need to install the package rekalogika/file-association-entity to use this feature: composer require rekalogika/file-association-entity   In short, you need to:  Add a property with EmbeddedMetadata type. This is a Doctrine embeddablethat implements RawMetadataInterface we will be using to store the file's metadata.Modify the getter of the file property so that it returns a decorated version of the FileInterface that will use our EmbeddedMetadata in #1.Modify the setter of the file property so it will copy the metadata of a new file to our EmbeddedMetadata in #1.  If your original entity looks like this:  use Doctrine\\ORM\\Mapping\\Entity; use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Association\\Attribute\\WithFileAssociation; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; #[Entity] #[WithFileAssociation] class Product { #[AsFileAssociation] private ?FileInterface $image = null; public function getImage(): ?FileInterface { return $this-&gt;image; } public function setImage(?FileInterface $image): self { $this-&gt;image = $image; return $this; } }   You need to modify it to look like this:  use Doctrine\\ORM\\Mapping\\Embedded; use Doctrine\\ORM\\Mapping\\Entity; use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Domain\\File\\Association\\Entity\\EmbeddedMetadata; use Rekalogika\\Domain\\File\\Association\\Entity\\FileDecorator; use Rekalogika\\File\\Association\\Attribute\\WithFileAssociation; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; #[Entity] #[WithFileAssociation] class Product { #[AsFileAssociation] private ?FileInterface $image = null; #[Embedded] private EmbeddedMetadata $imageMetadata; public function __construct() { $this-&gt;imageMetadata = new EmbeddedMetadata(); } public function getImage(): ?FileInterface { return FileDecorator::getFile($this-&gt;image, $this-&gt;imageMetadata); } public function setImage(?FileInterface $image): self { FileDecorator::setFile($image, $this-&gt;image, $this-&gt;imageMetadata); return $this; } }   After the change, calling the setter will still give you a FileInterface that you can use like before. But behind the scenes, any reads to the metadata will be done from the data stored in the entity. And any writes to the metadata are saved to both the file and the entity.  info Because the metadata is now saved in the entity, after any changes to the metadata, you need to call flush() on the entity manager to save the metadata to the database.  ","version":"Next","tagName":"h2"},{"title":"Using The Metadata Fields for Querying and Indexing‚Äã","type":1,"pageTitle":"Replicating Metadata in Entities","url":"/file-bundle/replicating-metadata-in-entities#using-the-metadata-fields-for-querying-and-indexing","content":" EmbeddedMetadata is a Doctrine embeddable that contains the following fields:  name: The file name.size: The file size in bytes.type: The file MIME type.modificationTime: The file modification time.width: The width, if the file is an image.height: The height, if the file is an image.other: Other metadata that is not covered by the above fields.  You can use these fields (other than the other) to query and index the files in your database.  ","version":"Next","tagName":"h2"},{"title":"Mandatory File Properties‚Äã","type":1,"pageTitle":"Replicating Metadata in Entities","url":"/file-bundle/replicating-metadata-in-entities#mandatory-file-properties","content":" If your file property does not accept a null value, you need to modify the setter like the following.  use Doctrine\\ORM\\Mapping\\Entity; use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Domain\\File\\Association\\Entity\\FileDecorator; use Rekalogika\\Domain\\File\\Null\\NullFile; use Rekalogika\\File\\Association\\Attribute\\WithFileAssociation; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; #[Entity] #[WithFileAssociation] class Product { // $image is not nullable #[AsFileAssociation] private FileInterface $image; // ... public function setImage(FileInterface $image): self { // make sure the image is not unset, otherwise the next line won't work $this-&gt;image = new NullFile(); // setFileMandatory is identical to setFile, except it does not accept // null value and works with properties that does not accept null FileDecorator::setFileMandatory($file, $this-&gt;file, $this-&gt;fileMetadata); return $this; } }  ","version":"Next","tagName":"h2"},{"title":"Translation","type":0,"sectionRef":"#","url":"/file-bundle/translation","content":"","keywords":"","version":"Next"},{"title":"Translatable Strings‚Äã","type":1,"pageTitle":"Translation","url":"/file-bundle/translation#translatable-strings","content":" The framework supports localization in several places, including:  File names. For displaying 'Untitled' in the UI if the file name is null.File type description. For displaying 'Unknown file type' if the file type is not recognized.  use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ $name = $file-&gt;getName(); // this is translatable $baseFileName = $file-&gt;getName()-&gt;getBase(); // also translatable $fullFileName = $file-&gt;getName()-&gt;getFull(); // translatable, too $typeDescription = $file-&gt;getType()-&gt;getDescription(); // translatable as well   ","version":"Next","tagName":"h2"},{"title":"Translation‚Äã","type":1,"pageTitle":"Translation","url":"/file-bundle/translation#translation","content":" The framework uses Symfony's translation contracts. To translate strings, you need to use the TranslatorInterface service:  use Rekalogika\\Contracts\\File\\FileInterface; use Symfony\\Contracts\\Translation\\TranslatorInterface; /** @var FileInterface $file */ /** @var TranslatorInterface $translator */ $fileName = $file-&gt;getName(); $translatedFileName = $fileName-&gt;trans($translator);   note File names are not translated. Only 'Untitled' and 'Unknown file type' are translated.  In Twig:  {# 'file' is an instance of FileInterface #} The file name is {{ file.name|trans }}   ","version":"Next","tagName":"h2"},{"title":"Using the Framework Without Translation‚Äã","type":1,"pageTitle":"Translation","url":"/file-bundle/translation#using-the-framework-without-translation","content":" All the translatable strings also implement Stringable. Therefore, if your application does not use translations, you can simply cast to string.  use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ $fileNameInString = (string) $file-&gt;getName();   ","version":"Next","tagName":"h2"},{"title":"Translating to Your Language‚Äã","type":1,"pageTitle":"Translation","url":"/file-bundle/translation#translating-to-your-language","content":" To add translations to your language, submit a pull request to the repository here:  github.com/rekalogika/file-src/tree/main/packages/file-bundle/translations  Use the English XLIFF as a template. ","version":"Next","tagName":"h2"},{"title":"Working With Entities & Files","type":0,"sectionRef":"#","url":"/file-bundle/working-with-entities","content":"","keywords":"","version":"Next"},{"title":"Creating an entity, adding it to a file, & persisting it‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#creating-an-entity-adding-it-to-a-file--persisting-it","content":" use Doctrine\\ORM\\EntityManagerInterface; use Rekalogika\\File\\File; /** @var EntityManagerInterface $entityManager */ $product = new Product(); $image = new File('/tmp/image.png'); $product-&gt;setImage($image); $entityManager-&gt;persist($product); $entityManager-&gt;flush();   note The framework will copy the file to the storage location, and leave the original file alone. It is the responsibility of the caller to delete the original if it wishes to do so. If the file arrived from a file upload, PHP will delete the file automatically when the request ends.  ","version":"Next","tagName":"h2"},{"title":"Replacing an associated file‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#replacing-an-associated-file","content":" use Doctrine\\ORM\\EntityManagerInterface; use Rekalogika\\File\\File; /** @var EntityManagerInterface $entityManager */ /** @var Product $product */ $newImage = new File('/tmp/newImage.png') $product-&gt;setImage($newImage); $entityManager-&gt;flush();   ","version":"Next","tagName":"h2"},{"title":"Updating the metadata of an associated file‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#updating-the-metadata-of-an-associated-file","content":" use Doctrine\\ORM\\EntityManagerInterface; /** @var Product $product */ $product-&gt;getImage()?-&gt;setName('newImage.png');   note Files are not Doctrine entities. File modifications are carried out immediately, independent of Doctrine's flush().  ","version":"Next","tagName":"h2"},{"title":"Removing an associated file‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#removing-an-associated-file","content":" use Doctrine\\ORM\\EntityManagerInterface; /** @var EntityManagerInterface $entityManager */ /** @var Product $product */ $product-&gt;setImage(null); $entityManager-&gt;flush();   ","version":"Next","tagName":"h2"},{"title":"Removing the entity will also remove the associated file‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#removing-the-entity-will-also-remove-the-associated-file","content":" use Doctrine\\ORM\\EntityManagerInterface; /** @var EntityManagerInterface $entityManager */ /** @var Product $product */ $entityManager-&gt;remove($product); $entityManager-&gt;flush();   ","version":"Next","tagName":"h2"},{"title":"Copying Files Between Entities‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#copying-files-between-entities","content":" use Doctrine\\ORM\\EntityManagerInterface; /** @var EntityManagerInterface $entityManager */ /** @var Product $product1 */ /** @var Product $product2 */ $product2-&gt;setImage($product1-&gt;getImage()); $entityManager-&gt;flush();   ","version":"Next","tagName":"h2"},{"title":"Moving Files Between Entities‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#moving-files-between-entities","content":" use Doctrine\\ORM\\EntityManagerInterface; /** @var EntityManagerInterface $entityManager */ /** @var Product $product1 */ /** @var Product $product2 */ $product2-&gt;setImage($product1-&gt;getImage()); $product1-&gt;setImage(null); $entityManager-&gt;flush();  ","version":"Next","tagName":"h2"},{"title":"Adapters","type":0,"sectionRef":"#","url":"/file/adapters","content":"Adapters The library provides a FileAdapter class that can be used to adapt or convert a file object from another library to our FileInterface. use Rekalogika\\File\\FileAdapter; use Rekalogika\\File\\FileInterface; // $theirFile is any of the supported file object $ourFile = FileAdapter::adapt($theirFile); assert($ourFile instanceof FileInterface); Currently supported objects: string: assumed to be a path to a local filePHP's SplFileInfoSymfony HttpFoundation File (and descendants, including the ubiquitousUploadedFile). Requires the rekalogika/file-symfony-bridge package.FileInterface of OneupUploaderBundle. Requires therekalogika/file-oneup-uploader-bridge package.","keywords":"","version":"Next"},{"title":"Concepts & Terms","type":0,"sectionRef":"#","url":"/file/concepts","content":"","keywords":"","version":"Next"},{"title":"Terms‚Äã","type":1,"pageTitle":"Concepts & Terms","url":"/file/concepts#terms","content":" FileRepository: Manages files in the framework. ImplementsFileRepositoryInterface.File: A file in a Flysystem filesystem. Implements FileInterface. Each file is identified by a filesystem identifier and a key. A null filesystem identifier denotes that the file is in the local filesystem.FilePointer: A pointer to a file. Implements FilePointerInterface. Like a file, a file pointer has a filesystem identifier and a key, but nothing else.Directory: Contains files, file pointers, and other directories.Filesystem: A Flysystem filesystem. Implements Flysystem'sFilesystemOperator. The caller should not use it directly but use theFileRepository instead.Local filesystem: A special Flysystem filesystem initialized by the framework that points to an unscoped local filesystem, using '/' as its root location.  info A Flysystem filesystem using LocalFilesystemAdapter that is set up by the user is not considered a local filesystem in this document.  ","version":"Next","tagName":"h2"},{"title":"Class Diagram‚Äã","type":1,"pageTitle":"Concepts & Terms","url":"/file/concepts#class-diagram","content":" note 'Interface' in the names are stripped for brevity. Simple getters are represented by properties.     ","version":"Next","tagName":"h2"},{"title":"Keys vs Paths‚Äã","type":1,"pageTitle":"Concepts & Terms","url":"/file/concepts#keys-vs-paths","content":" The library encourages using the concept of 'keys', not 'paths'. Although the key can appear similar to a path, the main difference is that the filename is not part of the key, but part of the file's metadata. The key is similar to the primary key of a database table. You can change the 'name' field, but the ID usually stays the same. ","version":"Next","tagName":"h2"},{"title":"Integration With Symfony Components","type":0,"sectionRef":"#","url":"/file-bundle/symfony","content":"","keywords":"","version":"Next"},{"title":"Components Summary‚Äã","type":1,"pageTitle":"Integration With Symfony Components","url":"/file-bundle/symfony#components-summary","content":" Adapters to convert HttpFoundation File objects to a FileInterface and vice versa, with special handling for UploadedFile.FileResponse for streaming a FileInterface to the client web browser.FileType form that works with FileInterface objects.A form transformer FileTransformer that you can add to an existing SymfonyFileType fields so that it gives us a FileInterface instead of aUploadedFile object.A form extension FileTypeExtension that you can optionally register to automatically convert all the existing Symfony FileType so they all give us a FileInterface.Subclassed FileValidator and ImageValidator that works withFileInterface objects.  ","version":"Next","tagName":"h2"},{"title":"Adapters‚Äã","type":1,"pageTitle":"Integration With Symfony Components","url":"/file-bundle/symfony#adapters","content":" Converts a HttpFoundation File (and child classes, including UploadedFile) to a FileInterface:  use Rekalogika\\File\\Bridge\\Symfony\\HttpFoundation\\FromHttpFoundationFileAdapter; use Symfony\\Component\\HttpFoundation\\File\\File; /** @var File $httpFoundationFile */ $file = FromHttpFoundationFileAdapter::adapt($httpFoundationFile);   However, it is more convenient to use the universal adapter instead, although the universal adapter still needs this package to be installed.  use Symfony\\Component\\HttpFoundation\\File\\File; use Rekalogika\\File\\FileAdapter; /** @var File $httpFoundationFile */ $file = FileAdapter::adapt($httpFoundationFile);   Converts a FileInterface to a HttpFoundation File:  use Rekalogika\\File\\Bridge\\Symfony\\HttpFoundation\\ToHttpFoundationFileAdapter; use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ $httpFoundationFile = ToHttpFoundationFileAdapter::adapt($file);   ","version":"Next","tagName":"h2"},{"title":"Streaming a FileInterface‚Äã","type":1,"pageTitle":"Integration With Symfony Components","url":"/file-bundle/symfony#streaming-a-fileinterface","content":" To stream a FileInterface to the client's web browser, you can useFileResponse.  use Rekalogika\\File\\Bridge\\Symfony\\HttpFoundation\\FileResponse; use Rekalogika\\Contracts\\File\\FileInterface; use Symfony\\Component\\HttpFoundation\\Response; class SomeController { public function download(): Response { /** @var FileInterface $file */ $file = ...; return new FileResponse($file); } }   FileResponse accepts additional optional parameters:  $status: HTTP status code. Default: 200.$headers: Array of additional headers. Default: [].$disposition: Force the first parameter of the Content-Disposition header to the specified value. It can be attachment or inline. The filename is automatically taken from the metadata.  ","version":"Next","tagName":"h2"},{"title":"Forms‚Äã","type":1,"pageTitle":"Integration With Symfony Components","url":"/file-bundle/symfony#forms","content":" Protip You might want to use our FilePondType form type instead. See the chapterFile Upload With FilePond for more information.  We provide a FileType that works with FileInterface objects. This is basically the same as Symfony's FileType with a transformer built-in:  use Rekalogika\\File\\Bridge\\Symfony\\Form\\FileType; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\FormBuilderInterface; class SomeFormType extends AbstractType { public function buildForm(FormBuilderInterface $builder, array $options): void { $builder // ... -&gt;add('file', FileType::class, [ // ... ]) ; } }   If for some reason you cannot change the form type, you can useFileTransformer to transform existing fields. It should work with Symfony'sFileType and any third-party form types with a compatible behavior:  use Rekalogika\\File\\Bridge\\Symfony\\Form\\FileTransformer; use Symfony\\Component\\Form\\Extension\\Core\\Type\\FileType; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\FormBuilderInterface; class SomeFormType extends AbstractType { public function buildForm(FormBuilderInterface $builder, array $options): void { $builder -&gt;add('file', FileType::class, [ // ... ]); $builder-&gt;get('file')-&gt;addModelTransformer(new FileTransformer()); } }   You can also modify all the existing Symfony's FileType fields en masse by registering the FileTypeExtension:  config/services.yaml services: Rekalogika\\File\\Bridge\\Symfony\\Form\\FileTypeExtension: tags: - { name: form.type_extension }   ","version":"Next","tagName":"h2"},{"title":"Validators‚Äã","type":1,"pageTitle":"Integration With Symfony Components","url":"/file-bundle/symfony#validators","content":" We provide File and Image validators. They are the same as Symfony'sFile and Image validators, except that they work with FileInterfaceobjects instead of HttpFoundation File objects:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Bridge\\Symfony\\Constraints\\File as FileConstraint; use Rekalogika\\File\\Bridge\\Symfony\\Constraints\\Image as ImageConstraint; class Product { #[ImageConstraint(minWidth: '1000'] private ?FileInterface $photo = null; #[ImageConstraint(maxSize: '10000k'] private ?FileInterface $manual = null; // ... }   caution Due to how the adapters work, some validator functions might not work correctly, like those that check file names. ","version":"Next","tagName":"h2"},{"title":"Streaming a ZIP File of Files","type":0,"sectionRef":"#","url":"/file-bundle/zip-streaming","content":"","keywords":"","version":"Next"},{"title":"Concepts‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#concepts","content":" A DirectoryInterface represents a tree of files. It contains entries ofFileInterface, FilePointerInterface, or other DirectoryInterface. TheFileZip service turns a DirectoryInterface into a ZIP file.  The ZIP file is created on the fly and streamed to the client's web browser, and does not involve a temporary file. Therefore, the operation is relatively inexpensive.  note We are using the ZipStream-PHPpackage under the hood.  ","version":"Next","tagName":"h2"},{"title":"Basic Usage‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#basic-usage","content":" The FileZip::streamZip() method takes a DirectoryInterface and streams a ZIP file to the client's web browser.  use Rekalogika\\File\\Zip\\FileZip; use Rekalogika\\Contracts\\File\\DirectoryInterface; use Rekalogika\\File\\Directory; use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileZip $fileZip */ /** @var FileInterface $file1 */ /** @var FileInterface $file2 */ /** @var FileInterface $file3 */ $directory = new Directory('my_zip_file', [$file1, $file2, $file3]); $fileZip-&gt;streamZip($directory);   ","version":"Next","tagName":"h2"},{"title":"In Controllers‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#in-controllers","content":" To get an HTTP Foundation Response object, useFileZip::createZipResponse():  use Rekalogika\\File\\Zip\\FileZip; use Rekalogika\\File\\Directory; use Rekalogika\\Contracts\\File\\FileInterface; class SomeController { public function download(FileZip $fileZip): Response { /** @var FileInterface $file1 */ /** @var FileInterface $file2 */ /** @var FileInterface $file3 */ $directory = new Directory('my_zip_file', [$file1, $file2, $file3]); return $fileZip-&gt;createZipResponse($directory); } }   ","version":"Next","tagName":"h2"},{"title":"Dealing With Doctrine Collections Containing Files‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#dealing-with-doctrine-collections-containing-files","content":" To convert a Doctrine collection of files into a DirectoryInterface, you can use FileCollection.  use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\Domain\\File\\Association\\Entity\\FileCollection; use Rekalogika\\Contracts\\File\\DirectoryInterface; use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Directory; use Rekalogika\\File\\Zip\\FileZip; class SomeController { public function download(Product $product, FileZip $fileZip): Response { /** @var Collection&lt;int,Images&gt; */ $images = $product-&gt;getImages(); /** @var FileCollection */ $directoryOfImages = new FileCollection($images, 'product-image'); return $fileZip-&gt;createZipResponse($directoryOfImages); } }   ","version":"Next","tagName":"h2"},{"title":"Returning a DirectoryInterface in the Getter Itself‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#returning-a-directoryinterface-in-the-getter-itself","content":" FileCollection implements both DirectoryInterface and Collection. So, it is safe to return a FileCollection in the getter because it won't change the existing behavior of your getter.  use Rekalogika\\Domain\\File\\Association\\Entity\\FileCollection; class Product { // ... /** * @return FileCollection&lt;int,Image&gt; */ public function getImages(): FileCollection { return new FileCollection( $this-&gt;images, sprintf('product %s images', $this-&gt;getName()) ); } // ... }   Then, you can do something like this in the controller:  use Rekalogika\\File\\Zip\\FileZip; class SomeController { public function download(Product $product, FileZip $fileZip): Response { return $fileZip-&gt;createZipResponse($product-&gt;getImages()); } }   ","version":"Next","tagName":"h2"},{"title":"Creating a Link to the ZIP File‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#creating-a-link-to-the-zip-file","content":" The framework registers a temporary URL handler. So, you can simply useTemporaryUrlGeneratorInterface::generateUrl() to generate a temporary URL to the ZIP file.  use Rekalogika\\TemporaryUrl\\TemporaryUrlGeneratorInterface; /** @var TemporaryUrlGeneratorInterface $temporaryUrlGenerator */ /** @var FileCollection */ $images = $product-&gt;getImages(); $url = $temporaryUrlGenerator-&gt;generateUrl($images);   ","version":"Next","tagName":"h2"},{"title":"In Twig Templates‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#in-twig-templates","content":" In Twig templates, you can easily generate URLs to a ZIP file by using thetemporary_url filter with a DirectoryInterface as the input.  &lt;a href=&quot;{{ product.images|temporary_url }}&quot; {{ temporary_url_autoexpire() }}&gt; Download Product Images &lt;/a&gt;  ","version":"Next","tagName":"h2"},{"title":"Derivation","type":0,"sectionRef":"#","url":"/file/derivation","content":"","keywords":"","version":"Next"},{"title":"Derivation‚Äã","type":1,"pageTitle":"Derivation","url":"/file/derivation#derivation","content":" FileInterface supports what we call 'derivation'. A file can have one or more derivations of itself. For example, an image file can have a thumbnail, medium, and large derivation. A derived file can also be derived further. For example, a thumbnail can be in the original aspect ratio, or square-cropped.  FileInterface provides the method getDerivation() that returns aFilePointer to the derived file. Our File objects ensure that a derivation cannot be made if the file is in the local filesystem, or in an ad-hoc filesystem, to avoid cluttering the local filesystem with unwanted files.  ","version":"Next","tagName":"h2"},{"title":"Low-Level Implementation‚Äã","type":1,"pageTitle":"Derivation","url":"/file/derivation#low-level-implementation","content":" At the low level, a derivation is created simply by appending the derivation ID to the original file's key. For example, if the original file's key is:  entity/ffa87ef3fc5388bc8b666e2cec17d27cc493d0c1/image/e5/80/72/6d/31337   then, with the derivation ID '100px', the derived file's key becomes:  entity/ffa87ef3fc5388bc8b666e2cec17d27cc493d0c1/image/e5/80/72/6d/31337.d/100px   Deleting the original file will also result in the deletion of all of its derivations.  Derivation can be nested. Suppose the derived file above will be derived further with the derivation ID of 'square', then the derived file's key becomes:  entity/ffa87ef3fc5388bc8b666e2cec17d27cc493d0c1/image/e5/80/72/6d/31337.d/100px.d/square   caution Because each derivation step requires a round trip to the storage backend, it is not recommended to nest derivations too deep.  ","version":"Next","tagName":"h2"},{"title":"Pipes & Filters Pattern‚Äã","type":1,"pageTitle":"Derivation","url":"/file/derivation#pipes--filters-pattern","content":" Derivation can be used as the building block of filters. A filter is a service that performs opportunistic creation and caching of a derived file from a source file.  A filter can be applied to a FileInterface and does the following:  Obtain the original file.Determine the derivation ID from the parameters provided by the caller. For example, if the caller wants to get a square thumbnail of an image, the filter can use the derivation ID like 'thumbnail-square'.Call FileInterface::getDerivation() to get a pointer to the derived file.Call FileRepository::get() to get the derived file. If the derived file does not exist, produce the derived file, and write to the pointer.If the derived file exists and is newer than the original file, return it.If the derived file exists and is older than the original file, produce the derived file, then overwrite the old derived file.  The caller can then use the filter to create a modified version of the original file without having to worry about the details.  We provide the packagerekalogika/file-derivation to streamline the creation of filters within the Symfony framework. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/file/intro","content":"","keywords":"","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction","url":"/file/intro#features","content":" ","version":"Next","tagName":"h2"},{"title":"General Features‚Äã","type":1,"pageTitle":"Introduction","url":"/file/intro#general-features","content":" Rich, high-level abstraction of files built on top of Flysystem.Abstractions for file name and media type (MIME type).Caches and stores metadata in a sidecar file. Uniform metadata support across all filesystems.Uses the repository pattern for files.Remote fa√ßade pattern in accessing metadata. Improves performance with remote filesystems. Two metadata queries require only one round trip.Rich metadata support.Option to use lazy-loading proxy for files.Support for file derivations.Separated contracts and implementation. Useful for enforcing architectural boundaries. Your domain models don't have to depend on the framework.  ","version":"Next","tagName":"h3"},{"title":"Interoperability Features‚Äã","type":1,"pageTitle":"Introduction","url":"/file/intro#interoperability-features","content":" Adapters for Symfony HttpFoundation, Form, and Validator.Adapter for OneupUploaderBundle.  ","version":"Next","tagName":"h3"},{"title":"Components‚Äã","type":1,"pageTitle":"Introduction","url":"/file/intro#components","content":" The File framework consists of several components.     rekalogika/file: The core library. It provides the file abstraction and metadata support.rekalogika/file-bundle: Integrates the library with Symfony.rekalogika/file-association: Provides support for associating files withrekalogika/file-association-entity: Utilities for handling files inside domain entities.rekalogika/file-contracts: Contains the interfaces and contracts used by the library.rekalogika/file-derivation: Library for creating derived files.rekalogika/file-filepond: Form for uploading files utilizing the FilePond Javascript library.rekalogika/file-image: Provides image resizing filter.rekalogika/file-metadata: Classes that represent file metadata.rekalogika/file-metadata-contracts: Contains additional interfacesrekalogika/file-null: Implementation of the null object pattern.rekalogika/file-oneup-uploader-bridge: Adapter for OneupUploaderBundle.rekalogika/file-server: Temporary URL server for files.rekalogika/file-symfony-bridge: Adapter for Symfony HttpFoundation, Form, andrekalogika/file-zip: Streams files as a ZIP file to the client.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction","url":"/file/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/file/intro#contributing","content":" This framework consists of multiple repositories split from a monorepo. Be sure to submit issues and pull requests to therekalogika/file-src monorepo. ","version":"Next","tagName":"h2"},{"title":"Installation & Configuration","type":0,"sectionRef":"#","url":"/file/installation","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Installation & Configuration","url":"/file/installation#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  Open a command console, enter your project directory, and execute:  composer require rekalogika/file-bundle   ","version":"Next","tagName":"h2"},{"title":"Initialization‚Äã","type":1,"pageTitle":"Installation & Configuration","url":"/file/installation#initialization","content":" In your application, initialize the file repository like the following example:  use Rekalogika\\File\\FileFactory; use League\\Flysystem\\Filesystem; use League\\Flysystem\\Local\\LocalFilesystemAdapter; $fileFactory = new FileFactory( filesystems: [ 'default' =&gt; new Filesystem(new LocalFilesystemAdapter('/var/storage')), ] ); /** @var FileRepositoryInterface */ $fileRepository = $fileFactory-&gt;getFileRepository();   Read Flysystem documentation on how to initialize the filesystem. Once you have a Flysystem filesystem, you can pass it to our FileFactory. Then, use theFileFactory to create a FileRepositoryInterface instance. ","version":"Next","tagName":"h2"},{"title":"Metadata","type":0,"sectionRef":"#","url":"/file/metadata","content":"","keywords":"","version":"Next"},{"title":"Primary Metadata‚Äã","type":1,"pageTitle":"Metadata","url":"/file/metadata#primary-metadata","content":" Firstly, FileInterface has several methods that return and set what can be considered metadata of the file:  use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // Returns the file's name $name = (string) $file-&gt;getName(); // Returns the file's MIME type $mime = (string) $file-&gt;getType(); // Returns the file's size in bytes $size = $file-&gt;getSize(); // Returns the file's last modified time $lastModified = $file-&gt;getLastModified();   ","version":"Next","tagName":"h2"},{"title":"Metadata Objects‚Äã","type":1,"pageTitle":"Metadata","url":"/file/metadata#metadata-objects","content":" A FileInterface can also have several metadata objects associated with it. A metadata object is an object that represents a specific type of metadata of the file.  These are the metadata objects that are currently implemented:  RawMetadataInterface: Represents the raw metadata object. It is a simple key-value object. The value can be a string, integer, boolean, or null.FileMetadataInterface: Represents the metadata that every file has: name, type, size, and last modified time.HttpMetadataInterface: Represents metadata used in HTTP responses. It is used when streaming the file to the client over HTTP.ImageMetadataInterface: Contains metadata specific to images, including image dimension and orientation.  ","version":"Next","tagName":"h2"},{"title":"Getting Metadata Objects‚Äã","type":1,"pageTitle":"Metadata","url":"/file/metadata#getting-metadata-objects","content":" The FileInterface has a get() method that returns an associated object of the file. The caller can use this method to get a specific metadata object of a file.  use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // Returns the FileMetadataInterface object $fileMetadata = $file-&gt;get(FileMetadataInterface::class); // Returns the ImageMetadataInterface object $imageMetadata = $file-&gt;get(ImageMetadataInterface::class); // Getting image related metadata $width = $file-&gt;get(ImageMetadataInterface::class)-&gt;getWidth(); $height = $file-&gt;get(ImageMetadataInterface::class)-&gt;getHeight();   You can also use string aliases instead of FQCNs. This is useful when specifying FQCNs is inconvenient, like in Twig templates:  &lt;img src=&quot;{{ image_file|temporary_url }}&quot; width=&quot;{{ image_file.get('imageMetadata').width }}&quot; height=&quot;{{ image_file.get('imageMetadata').height }}&quot;&gt;   ","version":"Next","tagName":"h2"},{"title":"Setting Metadata‚Äã","type":1,"pageTitle":"Metadata","url":"/file/metadata#setting-metadata","content":" Metadata objects can provide methods that can be used to set the metadata value. For example, the FileMetadataInterface has setName() and setType(), theHttpMetadataInterface has setDisposition(), etc. After setting the metadata using these methods, the caller must call flush() to persist the changes.  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\Metadata\\HttpMetadataInterface; /** @var FileInterface $file */ // Each of the following will be flush automatically individually, and will // require two roundtrips to the storage backend $file-&gt;setType('image/jpeg'); $file-&gt;setName('foo.jpg'); // The following needs an explicit flush(). It will only require one roundtrip // to the storage backend. $file-&gt;get(FileMetadataInterface::class)?-&gt;setType('image/jpeg'); $file-&gt;get(FileMetadataInterface::class)?-&gt;setName('foo.jpg'); $file-&gt;flush();   note Local files don't persist metadata. Changes in the metadata are only valid for the duration of the request. However, if the file is copied or moved to a non-local filesystem, the metadata will be copied and persisted by the destination file.  ","version":"Next","tagName":"h2"},{"title":"Low-Level Metadata Handling‚Äã","type":1,"pageTitle":"Metadata","url":"/file/metadata#low-level-metadata-handling","content":" In a non-local filesystem, the library stores a file's metadata in a sidecar file in the JSON format. If the file key is foo/bar.txt, the metadata file key will befoo/bar.txt.metadata.  Rationale:  Supports all filesystems.Uniform way of handling metadata with all filesystems.Simpler administration. i.e. when copying between different filesystems.Implements coarse-grained remote fa√ßade pattern to improve performance with remote filesystems.  With the local filesystem, the library provides the same interface as above but does not save the metadata to a sidecar file. Instead, the metadata is determined from the file and stored in an in-memory cache. Any changes to the metadata are not persisted and are only valid in the current request but will be considered if the caller copies or moves the file to a non-local filesystem.  The caller is expected to treat files in the local filesystem as transient objects and expected to copy or move the files to a non-local filesystem if they wish to store the file. ","version":"Next","tagName":"h2"},{"title":"Null File","type":0,"sectionRef":"#","url":"/file/null-file","content":"","keywords":"","version":"Next"},{"title":"The Missing File Problem‚Äã","type":1,"pageTitle":"Null File","url":"/file/null-file#the-missing-file-problem","content":" One of the most common problems when working with files is how to handle the case when the business logic necessitates that a file must be present, but in actuality, it is not. For example, if an image has been assigned to a product in the past, the product has a record of it and knows that it has an image. But in the storage, the image is missing for some reason.  We can use a standard null value, but by doing so, we will have to check for null every time we want to use the file, as well as do the branching logic everywhere. This is tedious and error-prone. Such cases also rarely happen, and therefore the handling logic will also be rarely tested. When it happens, it often results in a fatal error, which is not a good user experience.  ","version":"Next","tagName":"h2"},{"title":"Solution: Use a NullFile Object‚Äã","type":1,"pageTitle":"Null File","url":"/file/null-file#solution-use-a-nullfile-object","content":" NullFile is a null object pattern implementation for files. It is a FileInterface that represents the missing file. It appears like a real file to the caller and can be considered a real file by most parts of the code.  Instead of a fatal error, your user will now be able to see if there is a file, but something is wrong with it, and will be able to tell the admin about it. The admin will be able to act on it, for example, by re-uploading the file or restoring it from backup.  The NullFile does that without much effort from the developer.  A NullFile will only stop acting like a real file if the caller is trying to operate on it that would cause a side effect. For example, you will not be able to copy a NullFile to another location, to change its content, etc. If that happens, NullFile will throw a NullFileOperationException.  ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Null File","url":"/file/null-file#usage","content":" Preparation You need to install the package rekalogika/file-null to use this feature: composer require rekalogika/file-null   An example on how to use NullFile in your entity:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Domain\\File\\Null\\NullFile; class Product { private ?FileInterface $image = null; public function __construct(FileInterface $image) { $this-&gt;image = $image; } // The image must never be null. So, if the image does not exist, we // substitute it with a NullFile instead. public function getImage(): FileInterface { return $this-&gt;image ?? new NullFile(); } }   ","version":"Next","tagName":"h2"},{"title":"Checking for a Null File‚Äã","type":1,"pageTitle":"Null File","url":"/file/null-file#checking-for-a-null-file","content":" All null files implement the NullFileInterface. You can use this interface to check if a file is null:  use Rekalogika\\Contracts\\File\\NullFileInterface; /** @var FileInterface $file */ if ($file instanceof NullFileInterface) { // The file is null. }   ","version":"Next","tagName":"h2"},{"title":"InvalidFile: a Null File That is Also an Exception‚Äã","type":1,"pageTitle":"Null File","url":"/file/null-file#invalidfile-a-null-file-that-is-also-an-exception","content":" There is also a null file called InvalidFile which is identical to the standard NullFile, but also extends Exception. The idea is that it contains the stack trace where it was instantiated that can help you debug the problem, if you can log it somewhere. You can also throw it somewhere down the line if you need it.  To log an InvalidFile you can do something like the following.  use Rekalogika\\Contracts\\File\\FileInterface; use Psr\\Log\\LoggerInterface; /** @var FileInterface $file */ /** @var LoggerInterface $logger */ if ($file instanceof InvalidFile) { $logger-&gt;error('Invalid file', [ 'exception' =&gt; $file, ]); }  ","version":"Next","tagName":"h2"},{"title":"Lazy-Loading Proxy","type":0,"sectionRef":"#","url":"/file/proxy","content":"","keywords":"","version":"Next"},{"title":"Getting a Proxy to a File‚Äã","type":1,"pageTitle":"Lazy-Loading Proxy","url":"/file/proxy#getting-a-proxy-to-a-file","content":" To get a lazy-loading proxy to a real file, you can use the method getReference() of FileRepositoryInterface:  use Rekalogika\\Contracts\\File\\FileRepositoryInterface; use Rekalogika\\File\\FilePointer; /** @var FileRepositoryInterface $fileRepository */ $pointer = new FilePointer('default', 'key'); $file = $fileRepository-&gt;getReference($pointer);   The $file variable will contain a FileInterface object that is actually a proxy to the real thing. It behaves the same way as a real FileInterfaceobject, except that it will throw FileNotFoundException if the file is not found when you are trying to use it.  info If the file is already in the cache of the FileRepositoryInterface, then the real file will be returned instead of a proxy.  ","version":"Next","tagName":"h2"},{"title":"Getting The Real File from a Proxy‚Äã","type":1,"pageTitle":"Lazy-Loading Proxy","url":"/file/proxy#getting-the-real-file-from-a-proxy","content":" To get the real file from a proxy, you can call the static methodFileProxy::getFile():  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\FileProxy; /** @var FileInterface $file */ // $realFile will be a FileInterface object or null if it does not exist $realFile = FileProxy::getFile($file);   Protip You can pass any FileInterface to FileProxy::getFile(). If the file is not a proxy, it will be returned as is. ","version":"Next","tagName":"h2"},{"title":"rekalogika/gotenberg-pdf-bundle","type":0,"sectionRef":"#","url":"/gotenberg-pdf-bundle","content":"","keywords":"","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"rekalogika/gotenberg-pdf-bundle","url":"/gotenberg-pdf-bundle#features","content":" Easy provisioning with Symfony Flex, Symfony CLI, and Docker Compose. Just install the bundle and you're ready to generate your first PDF.Separated high-level interfaces in rekalogika/print-contracts. If Gotenberg gets out of fashion in the future, hopefully we only need to replace this package, and don't need to change our code.Abstractions for paper sizes and page layouts.Leverages Symfony HTTP Client. See the requests and responses in SymfonyWith the heavy lifting already done by Gotenberg, there is no need to deal with Chrome instances, CLI tools, Puppeteer, NodeJS, etc.Scalable architecture. Suitable for low-volume development and high-volume usage alike. No need to reengineer if your usage outgrows your solution. Just add more instances of Gotenberg with Docker Compose or the container orchestration tool you are using.  ","version":"Next","tagName":"h2"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/gotenberg-pdf-bundle","url":"/gotenberg-pdf-bundle#sections","content":" üìÑÔ∏è Installation &amp; Quick Start This chapter describes how to install and use the bundle. üìÑÔ∏è Usage This chapter describes how to use the bundle.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"rekalogika/gotenberg-pdf-bundle","url":"/gotenberg-pdf-bundle#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"rekalogika/gotenberg-pdf-bundle","url":"/gotenberg-pdf-bundle#contributing","content":" The rekalogika/gotenberg-pdf-bundle repository is a read-only repo split from the main repo. Issues and pull requests should be submitted to therekalogika/print-src monorepo. ","version":"Next","tagName":"h2"},{"title":"Installation & Quick Start","type":0,"sectionRef":"#","url":"/gotenberg-pdf-bundle/installation","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Installation & Quick Start","url":"/gotenberg-pdf-bundle/installation#installation","content":" Preinstallation checklists:  Make sure Composer is installed globally, as explained in the installation chapter of the Composer documentation. Run composer about to verify.Make sure your project has Symfony Flex installed and enabled (it is enabled by default). Run composer why symfony/flex to verify.  Open a command console, enter your project directory, and execute:  composer config extra.symfony.allow-contrib true composer require rekalogika/gotenberg-pdf-bundle   ","version":"Next","tagName":"h2"},{"title":"Quick Start‚Äã","type":1,"pageTitle":"Installation & Quick Start","url":"/gotenberg-pdf-bundle/installation#quick-start","content":" Checklist:  Make sure you have Docker Compose installed. Run docker compose version to verify.Make sure you have Symfony CLI installed. Run symfony version to verify.  To start the Gotenberg server (and other services registered in the Docker Compose configuration), run:  docker compose up -d   Then start the web server using Symfony CLI:  symfony serve   Create a sample controller for generating a PDF file:  src/Controller/AppController.php namespace App\\Controller; use Rekalogika\\Contracts\\Print\\PageOrientation; use Rekalogika\\Contracts\\Print\\PdfGeneratorInterface; use Rekalogika\\Print\\PageLayout; use Rekalogika\\Print\\Paper; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\HttpFoundation\\StreamedResponse; use Symfony\\Component\\Routing\\Annotation\\Route; class AppController extends AbstractController { #[Route('/pdf')] public function index(PdfGeneratorInterface $pdfGenerator): Response { $pdf = $pdfGenerator-&gt;generatePdfFromHtml( htmlContent: '&lt;h1&gt;Hello World&lt;/h1&gt;', paper: Paper::A4(), pageLayout: PageLayout::inMm(PageOrientation::Portrait, 30) ); return new StreamedResponse( callback: fn () =&gt; fpassthru($pdf-&gt;detach()), status: 200, headers: [ 'Content-Type' =&gt; 'application/pdf', ] ); } }   Then open your browser and go to localhost:8000/pdf. ","version":"Next","tagName":"h2"},{"title":"Usage","type":0,"sectionRef":"#","url":"/gotenberg-pdf-bundle/usage","content":"","keywords":"","version":"Next"},{"title":"Specifying the URL to the Gotenberg Server‚Äã","type":1,"pageTitle":"Usage","url":"/gotenberg-pdf-bundle/usage#specifying-the-url-to-the-gotenberg-server","content":" The bundle uses the GOTENBERG_URL environment variable to determine the URL to the Gotenberg server. You can override it using the standard Symfony environment variable mechanism.  ","version":"Next","tagName":"h2"},{"title":"General Usage‚Äã","type":1,"pageTitle":"Usage","url":"/gotenberg-pdf-bundle/usage#general-usage","content":" Callers will interact with the PdfGeneratorInterface to generate PDF files. The PdfGeneratorInterface is a high-level interface that abstracts away the implementation details of the underlying PDF generator.  namespace Rekalogika\\Contracts\\Print; use Psr\\Http\\Message\\StreamInterface; interface PdfGeneratorInterface { public function generatePdfFromHtml( string $htmlContent, PaperInterface $paper, PageLayoutInterface $pageLayout, ?string $header = null, ?string $footer = null, ): StreamInterface; }   To get an instance of PdfGeneratorInterface, you can usually autowire it in your controller or service:  namespace App\\Controller; use Rekalogika\\Contracts\\Print\\PdfGeneratorInterface; class AppController { public function index(PdfGeneratorInterface $pdfGenerator) { // ... } }   generatePdfFromHtml() returns a PSR-7 StreamInterface containing the resulting PDF file. To get the raw PHP resource, call detach() on the result.  ","version":"Next","tagName":"h2"},{"title":"Paper Size‚Äã","type":1,"pageTitle":"Usage","url":"/gotenberg-pdf-bundle/usage#paper-size","content":" The method generatePdfFromHtml requires a $paper parameter containing aPaperInterface instance. It defines the paper size of the PDF output. You can use the Paper class to create a paper size:  use Rekalogika\\Print\\Paper; $a4Paper = Paper::A4(); // A4 $letterPaper = Paper::Letter(); // Letter $customPaper = Paper::inMm(200, 300); // Custom paper size in mm $customPaperInInches = Paper::inInches(7, 10); // Custom paper size in inches   There are many other paper sizes defined in the class.  ","version":"Next","tagName":"h2"},{"title":"Page Layout‚Äã","type":1,"pageTitle":"Usage","url":"/gotenberg-pdf-bundle/usage#page-layout","content":" The method generatePdfFromHtml requires a $pageLayout parameter containing a PageLayoutInterface instance. It defines the orientation of the page and its margins. You can use the PageLayout class to create a page layout:  use Rekalogika\\Print\\PageLayout; use Rekalogika\\Contracts\\Print\\PageOrientation; // Portrait with 30mm margins $layout = PageLayout::inMm(PageOrientation::Portrait, 30); // Landscape with 2 inches of vertical margin and 1 inch of horizontal margin $layout = PageLayout::inInches(PageOrientation::Landscape, 2, 1); // Portrait with 10mm top margin, 20mm right margin, 30mm bottom margin, and // 40mm left margin $layout = PageLayout::inMm(PageOrientation::Portrait, 10, 20, 30, 40);   ","version":"Next","tagName":"h2"},{"title":"Header and Footer‚Äã","type":1,"pageTitle":"Usage","url":"/gotenberg-pdf-bundle/usage#header-and-footer","content":" The $header and $footer parameters of generatePdfFromHtml are optional. You can use them to specify the HTML content of the header and footer of the PDF file. Read the Header and Footer chapter of the Gotenberg documentation to learn more. ","version":"Next","tagName":"h2"},{"title":"rekalogika/mapper","type":0,"sectionRef":"#","url":"/mapper","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/mapper","url":"/mapper#sections","content":" üìÑÔ∏è Introduction rekalogika/mapper is an object mapper for PHP and Symfony, also commonly known üìÑÔ∏è Installation &amp; Basic Usage Install and use the mapper. üìÑÔ∏è Mapping Object to Object Mapping an object to another object is the most common task done by a mapper. üìÑÔ∏è Mapping Arrays &amp; Array-Like Objects This chapter describes how to map arrays and array-like objects. üìÑÔ∏è Mapping Between Object and Array Mapping between an object and an array follows the same semantics as [mapping üìÑÔ∏è Context and Mapping Options Provide context variables to the mapper to control the mapping process. üìÑÔ∏è Manual Mapping using an Object Mapper If you need a custom logic in an object to another object mapping, one way to do üìÑÔ∏è Manual Mapping using a Class Factory Method This mapping method is deprecated. üìÑÔ∏è Predetermined Mapping Preset The user can provide a list of predetermined mapping between objects to Mapper. üìÑÔ∏è Architecture This chapter describes the architecture of the library. üìÑÔ∏è Mapping Table When we tell the mapper to map a source to a target, it will look up the mapping üìÑÔ∏è Creating a Custom Transformer Extend the mapper by creating your own transformer. üìÑÔ∏è Overriding a Mapping Table Entry If the mapper chooses the wrong transformer for a specific source and target üìÑÔ∏è SubMapper SubMapper is a highly simplified mapper used in places where you might need to üìÑÔ∏è Debugging the Mapper Command Line üìÑÔ∏è Rationale, or Why Create Another Mapper? TLDR: ","version":"Next","tagName":"h2"},{"title":"Using File & FileRepository","type":0,"sectionRef":"#","url":"/file/file","content":"","keywords":"","version":"Next"},{"title":"Working With the File Repository‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#working-with-the-file-repository","content":" ","version":"Next","tagName":"h2"},{"title":"Create a file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#create-a-file","content":" caution These methods overwrite the existing file if it already exists.  use Rekalogika\\Contracts\\File\\FileRepositoryInterface; use Rekalogika\\File\\FilePointer; /** @var FileRepositoryInterface $fileRepository */ // Create a file from a string $file = $fileRepository-&gt;createFromString( new FilePointer('default', 'key'), 'Hello World!' ); // Create a file from a stream (resource or PSR-7 StreamInterface) $file = $fileRepository-&gt;createFromStream( new FilePointer('default', 'key'), $stream ); // Create a file from a local file $file = $fileRepository-&gt;createFromLocalFile( new FilePointer('default', 'key'), '/tmp/foo.txt' );   ","version":"Next","tagName":"h3"},{"title":"Get a file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#get-a-file","content":" use Rekalogika\\Contracts\\File\\FileRepositoryInterface; use Rekalogika\\Contracts\\File\\Exception\\File\\FileNotFoundException; use Rekalogika\\File\\FilePointer; /** @var FileRepositoryInterface $fileRepository */ // get() will throw an exception if the file is not found try { $file = $fileRepository-&gt;get(new FilePointer('default', 'key')); } catch (FileNotFoundException $e) { // File not found } // tryGet() will return null if the file is not found $file = $fileRepository-&gt;tryGet(new FilePointer('default', 'key')); // With a local file, you can also do it without using file repository: try { $file = new File('/path/to/file'); } catch (FileNotFoundException $e) { // File not found }   ","version":"Next","tagName":"h3"},{"title":"Delete a file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#delete-a-file","content":" use Rekalogika\\Contracts\\File\\FileRepositoryInterface; use Rekalogika\\File\\FilePointer; /** @var FileRepositoryInterface $fileRepository */ $fileRepository-&gt;delete(new FilePointer('default', 'key'));   ","version":"Next","tagName":"h3"},{"title":"Copy and move a file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#copy-and-move-a-file","content":" use Rekalogika\\Contracts\\File\\FileRepositoryInterface; use Rekalogika\\File\\FilePointer; /** @var FileRepositoryInterface $fileRepository */ $newFile = $fileRepository-&gt;copy( new FilePointer('default', 'key'), new FilePointer('otherfilesystem', 'destinationkey') ); $newFile = $fileRepository-&gt;move( new FilePointer('default', 'key'), new FilePointer('otherfilesystem', 'destinationkey') );   tip You can also use a FileInterface as the origin or the destination of the move or copy operation.  ","version":"Next","tagName":"h3"},{"title":"Create a temporary file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#create-a-temporary-file","content":" use Rekalogika\\Contracts\\File\\FileRepositoryInterface; /** @var FileRepositoryInterface $fileRepository */ $file = $fileRepository-&gt;createTemporaryFile();   note The temporary file is represented by a special TemporaryFile that will be automatically deleted if it is unset or falls out of scope.  ","version":"Next","tagName":"h3"},{"title":"Working With a File‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#working-with-a-file","content":" ","version":"Next","tagName":"h2"},{"title":"Reading the file's content‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#reading-the-files-content","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // As a string $string = $file-&gt;getContent(); // As a stream $stream = $file-&gt;getContentAsStream(); // getContentAsStream() returns a PSR-7 StreamInterface, to get a plain PHP // resource, call detach() on it $resource = $stream-&gt;detach();   ","version":"Next","tagName":"h3"},{"title":"Writing to the file, replacing its content‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#writing-to-the-file-replacing-its-content","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // From a string $file-&gt;setContent('Hello World!'); // From a stream or resource $file-&gt;setContentFromStream($resource);   ","version":"Next","tagName":"h3"},{"title":"Renaming the file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#renaming-the-file","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ $file-&gt;setName('my-photo.jpg'); // If you omit the extension, the library will automatically choose the correct // extension based on the file's MIME type $file-&gt;setName('my-photo'); $name = (string) $file-&gt;getName(); // my-photo.jpg // If you absolutely don't want an extension, you can set it directly to the // metadata $file-&gt;get(FileMetadataInterface::class)-&gt;setName('my-photo'); $file-&gt;flush(); // getName() returns FileNameInterface that provides several convenient methods // to get information about the filename $file-&gt;setName('foo.png'); $name = (string) $file-&gt;getName(); // foo.png $fullName = $file-&gt;getName()-&gt;getFull(); // foo.png $baseName = $file-&gt;getName()-&gt;getBase(); // foo $extension = $file-&gt;getName()-&gt;getExtension(); // png $hasExtension = $file-&gt;getName()-&gt;hasExtension(); // true   ","version":"Next","tagName":"h3"},{"title":"Saving to a local file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#saving-to-a-local-file","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // Saves the file to /tmp/foo.txt $localFile = $file-&gt;saveToLocalFile('/tmp/foo.txt'); // Saves the file to a temporary file $temporaryFile = $file-&gt;createLocalTemporaryFile();   ","version":"Next","tagName":"h3"},{"title":"Media type (MIME type) handling‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#media-type-mime-type-handling","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // Setting the MIME type is usally not necessary as the framework will // automatically detect media type $file-&gt;setType('image/jpeg'); // sets the media type to image/jpeg $type = (string) $file-&gt;getType(); // image/jpeg $type = $file-&gt;getType()-&gt;getName(); // image/jpeg $type = $file-&gt;getType()-&gt;getType(); // image $type = $file-&gt;getType()-&gt;getSubType(); // jpeg $type = $file-&gt;getType()-&gt;getCommonExtensions(); // ['jpg', 'jpeg', 'jpe'] $type = $file-&gt;getType()-&gt;getExtension(); // jpg $type = (string) $file-&gt;getType()-&gt;getDescription(); // JPEG image   ","version":"Next","tagName":"h3"},{"title":"File size & last modified time‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#file-size--last-modified-time","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // Main metadata $size = $file-&gt;getSize(); // file size in bytes $lastModified = $file-&gt;getLastModified(); // last modified time   ","version":"Next","tagName":"h3"},{"title":"Image metadata‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#image-metadata","content":" use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\Metadata\\ImageMetadataInterface; /** @var FileInterface $file */ $width = $file-&gt;get(ImageMetadataInterface::class)?-&gt;getWidth(); $height = $file-&gt;get(ImageMetadataInterface::class)?-&gt;getHeight(); // You can also use string identifiers, useful when specifying FQCNs is // unwieldy, like in Twig templates $width = $file-&gt;get('imageMetadata')?-&gt;getWidth(); $height = $file-&gt;get('imageMetadata')?-&gt;getHeight();   ","version":"Next","tagName":"h3"},{"title":"HTTP metadata‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#http-metadata","content":" use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\Metadata\\HttpMetadataInterface; /** @var FileInterface $file */ // Setting the disposition value, will be used in the Content-Disposition header // when the file is downloaded $file-&gt;get(HttpMetadataInterface::class)?-&gt;setDisposition('attachment'); $file-&gt;flush(); // Getting all the HTTP headers that will be used when the file is downloaded $httpHeaders = $file-&gt;get(HttpMetadataInterface::class)?-&gt;getHeaders();   ","version":"Next","tagName":"h3"},{"title":"Flushing metadata‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#flushing-metadata","content":" Updating metadata using a high-level method (those on FileInterface) will be saved automatically. But using a low-level method (underFileInterface::get()), you have to call flush() manually. You can take advantage of this so that multiple metadata updates are saved in a single round trip.  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\Metadata\\HttpMetadataInterface; /** @var FileInterface $file */ // Each of the following will be flush automatically individually, and will // require two roundtrips to the storage backend $file-&gt;setType('image/jpeg'); $file-&gt;setName('foo.jpg'); // The following needs an explicit flush(). It will only require one roundtrip // to the storage backend. $file-&gt;get(FileMetadataInterface::class)?-&gt;setType('image/jpeg'); $file-&gt;get(FileMetadataInterface::class)?-&gt;setName('foo.jpg'); $file-&gt;flush();   ","version":"Next","tagName":"h3"},{"title":"File Pointer & comparison‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#file-pointer--comparison","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // get pointer from a FileInterface $filePointer = $file-&gt;getPointer(); // determine if two File/FilePointer objects point to the same file $isEqual = $filePointer-&gt;isEqualTo($file); $isEqual = $file-&gt;isEqualTo($filePointer); $isEqual = $file1-&gt;isEqualTo($file2); $isEqual = $filePointer1-&gt;isEqualTo($filePointer2);  ","version":"Next","tagName":"h3"},{"title":"Architecture","type":0,"sectionRef":"#","url":"/mapper/architecture","content":"","keywords":"","version":"Next"},{"title":"Main Components‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#main-components","content":" ","version":"Next","tagName":"h2"},{"title":"Mapper Factory‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#mapper-factory","content":" Creates the mapper service. Only used in non-framework usage.  ","version":"Next","tagName":"h3"},{"title":"Mapper‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#mapper","content":" A fa√ßade for the entire mapping framework. A user-facing interface that is used directly by the caller. It provides a convenient, typed interface, for the caller, and forwards the call to the main transformer.  ","version":"Next","tagName":"h3"},{"title":"Main Transformer‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#main-transformer","content":" The main transformer is the entry point of the library. It is responsible for finding the transformer that supports the source to target mapping, and forwards the task to that transformer.  ","version":"Next","tagName":"h3"},{"title":"Transformer Registry Internal‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#transformer-registry-internal","content":" A registry of the transformers. It is used by the main transformer to find the matching transformer for the specific source and target types.  ","version":"Next","tagName":"h3"},{"title":"Object Cache Factory Internal‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#object-cache-factory-internal","content":" An object cache stores the objects that have been mapped, keyed by the source object and the target type. This is used to handle circular references. The object cache factory creates such object caches.  ","version":"Next","tagName":"h3"},{"title":"Mapping Factory Internal‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#mapping-factory-internal","content":" Creates the mapping table from the list of the transformers.  The mapping table is a list of the supported source to target type, mapped to the transformer suitable for the task. It is used by TransformerRegistry to find the correct transformer for transforming the source to the target type.  ","version":"Next","tagName":"h3"},{"title":"Transformer‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#transformer","content":" Transforms a source variable to the target variable. A transformer class provides the list of the supported source to target mappings, as well as the logic for transforming the source to the target.  ","version":"Next","tagName":"h3"},{"title":"Components Used by Transformers‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#components-used-by-transformers","content":" ","version":"Next","tagName":"h2"},{"title":"Object to Object Metadata Factory Internal‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#object-to-object-metadata-factory-internal","content":" Creates the metadata for ObjectToObjectTransformer. The metadata provides all the information it needs to do the mapping between two objects.  ","version":"Next","tagName":"h3"},{"title":"Symfony Property Info Third-party‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#symfony-property-info-third-party","content":" The library uses the Symfony Property Info component to list the properties of the source and target variables, and to query their types. This library uses the Type objects returned by the Symfony Property Info component as the means of describing the types of the source and target variables.  ","version":"Next","tagName":"h3"},{"title":"Property Mapper‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#property-mapper","content":" A custom, user-provided method that maps a single property from the source to the target.  ","version":"Next","tagName":"h3"},{"title":"Property Mapper Resolver Internal‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#property-mapper-resolver-internal","content":" Used to determine if a property mapper is available for a specific source and target property pair.  ","version":"Next","tagName":"h3"},{"title":"Eager Properties Resolver‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#eager-properties-resolver","content":" Inspect a class and determine the properties that can be mapped eagerly, without triggering the hydration of the object. As such, this is only applicable to source objects that are proxy, like Doctrine proxies. The user may create a new implementation for determining the eager properties of a specific class.  ","version":"Next","tagName":"h3"},{"title":"Proxy Registry Internal‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#proxy-registry-internal","content":" Register a proxy class, and save it to the filesystem.  ","version":"Next","tagName":"h3"},{"title":"Proxy Generator‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#proxy-generator","content":" Generates the source code of a proxy class.  The user may decorate ProxyGeneratorInterface and throwProxyNotSupportedException to disable proxying for a specific target class.  ","version":"Next","tagName":"h3"},{"title":"Array Like Metadata Factory Internal‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#array-like-metadata-factory-internal","content":" Creates the metadata for TraversableToArrayAccessTransformer andTraversableToTraversableTransformer. The metadata provides all the information it needs to do the mapping between two arrays or array-like objects.  ","version":"Next","tagName":"h3"},{"title":"Object Mapper‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#object-mapper","content":" A custom, user-provided methods for mapping a specific object pair.  ","version":"Next","tagName":"h3"},{"title":"Object Mapper Resolver Internal‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#object-mapper-resolver-internal","content":" Obtains an object mapper for a specific source and target object pair.  ","version":"Next","tagName":"h3"},{"title":"Object Mapper Table Factory Internal‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#object-mapper-table-factory-internal","content":" Constructs the object mapper table from all the available object mappers in the system.  ","version":"Next","tagName":"h3"},{"title":"Symfony Serializer Third-party‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#symfony-serializer-third-party","content":" Transforms objects to arrays and back.  ","version":"Next","tagName":"h3"},{"title":"SubMapper Factory Internal‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#submapper-factory-internal","content":" Creates a SubMapper instance.  ","version":"Next","tagName":"h3"},{"title":"Symfony PropertyAccess Third-party‚Äã","type":1,"pageTitle":"Architecture","url":"/mapper/architecture#symfony-propertyaccess-third-party","content":" Reads and writes the properties of an object. ","version":"Next","tagName":"h3"},{"title":"Context and Mapping Options","type":0,"sectionRef":"#","url":"/mapper/context-options","content":"","keywords":"","version":"Next"},{"title":"Context‚Äã","type":1,"pageTitle":"Context and Mapping Options","url":"/mapper/context-options#context","content":" The Context object stores objects that are used during the mapping process. The caller can provide a Context in the map() method. If not provided, the mapper will create a new Context object internally.  Context stores objects using class names as keys. Therefore, only one object of a given class can be stored in a Context.  use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MapperInterface; // Create a context $context = Context::create(); // Create a context, initialized with mapper options &amp; a custom object $mapperOptions = new MapperOptions(lazyLoading: false); $yourCustomObject = new YourCustomObject(); $context = Context::create($mapperOptions, $yourCustomObject); // Call map() with the context /** @var MapperInterface $mapper */ $target = $mapper-&gt;map($source, TargetObject::class, $context); // Add an object to the context, note that context is immutable $context = $context-&gt;with($someObject); // Remove an object from the context $context = $context-&gt;without(SomeObject::class); // Get an object from the context $mapperOptions = $context-&gt;get(MapperOptions::class); // or $mapperOptions = $context(MapperOptions::class); // Iterates over all objects in the context foreach ($context as $object) { // ... }   The Context is available in most of the places where you write code to customize the mapping process.  ","version":"Next","tagName":"h2"},{"title":"Built-in Context Objects‚Äã","type":1,"pageTitle":"Context and Mapping Options","url":"/mapper/context-options#built-in-context-objects","content":" The following context objects are provided by the mapper:  MapperOptions: Options for the mapping process.ObjectCache: Used to store objects that have already been mapped. It is used to handle circular references and to prevent infinite loops.Path: Stores the mapping path. Used for tracing and creating meaningful error messages.NormalizerContext and DenormalizerContext: Used to store the context that will be used by Symfony Serializer.  ","version":"Next","tagName":"h2"},{"title":"Mapper Options‚Äã","type":1,"pageTitle":"Context and Mapping Options","url":"/mapper/context-options#mapper-options","content":" The MapperOptions object is passed by the caller to provide options for the mapping process. The following options are available:  lazyLoading: Enable lazy-loading.readTargetValue: If true, the mapper will get the existing value from the target. If exists, it will be used as the target. If false, the mapper will always create a new target object. ","version":"Next","tagName":"h2"},{"title":"Debugging the Mapper","type":0,"sectionRef":"#","url":"/mapper/debugging","content":"","keywords":"","version":"Next"},{"title":"Command Line‚Äã","type":1,"pageTitle":"Debugging the Mapper","url":"/mapper/debugging#command-line","content":" ","version":"Next","tagName":"h2"},{"title":"Get the List of Transformers‚Äã","type":1,"pageTitle":"Debugging the Mapper","url":"/mapper/debugging#get-the-list-of-transformers","content":" php bin/console debug:container --tag=rekalogika.mapper.transformer   ","version":"Next","tagName":"h3"},{"title":"Dump the Mapping Table‚Äã","type":1,"pageTitle":"Debugging the Mapper","url":"/mapper/debugging#dump-the-mapping-table","content":" php bin/console rekalogika:mapper:mapping   ","version":"Next","tagName":"h3"},{"title":"Get the Mapping Result Between a Source and Target Type‚Äã","type":1,"pageTitle":"Debugging the Mapper","url":"/mapper/debugging#get-the-mapping-result-between-a-source-and-target-type","content":" php bin/console rekalogika:mapper:try 'App\\Entity\\Book' 'App\\Entity\\BookDto'   ","version":"Next","tagName":"h3"},{"title":"Symfony Profiler‚Äã","type":1,"pageTitle":"Debugging the Mapper","url":"/mapper/debugging#symfony-profiler","content":" In debug mode, Mapper will collect mapping data and display it in the Symfony Profiler. You can find comprehensive mapping information in the Mapper tab in the Symfony Profiler. ","version":"Next","tagName":"h2"},{"title":"Manual Mapping using a Class Factory Method","type":0,"sectionRef":"#","url":"/mapper/class-factory-mapper","content":"","keywords":"","version":"Next"},{"title":"Mapping from another Object‚Äã","type":1,"pageTitle":"Manual Mapping using a Class Factory Method","url":"/mapper/class-factory-mapper#mapping-from-another-object","content":" You can have your DTO implement the MapFromObjectInterface and create themapFromObject() method:  src/Dto/MoneyDto.php namespace App\\Dto; use Brick\\Money\\Money; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MethodMapper\\MapFromObjectInterface; use Rekalogika\\Mapper\\MethodMapper\\SubMapperInterface; final class MoneyDto implements MapFromObjectInterface { // ... public static function mapFromObject( object $source, SubMapperInterface $mapper, Context $context ): static { if (!$source instanceof Money) { throw new \\InvalidArgumentException('Source must be instance of ' . Money::class); } return new static( $source-&gt;getAmount()-&gt;__toString(), $source-&gt;getCurrency()-&gt;getCurrencyCode(), ); } }   Then, the next time you are mapping from the Money object to the MoneyDtoobject, the mapper will call the mapFromObject() method to get the resultingMoneyDto. The mapping will be done even if your Money object is deeply buried within the object you are mapping from.  ","version":"Next","tagName":"h2"},{"title":"Mapping to Another Object‚Äã","type":1,"pageTitle":"Manual Mapping using a Class Factory Method","url":"/mapper/class-factory-mapper#mapping-to-another-object","content":" You can also get the reverse of the above by implement theMapToObjectInterface and create the mapToObject() method.  src/Dto/MoneyDto.php namespace App\\Dto; use Brick\\Money\\Money; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MethodMapper\\MapToObjectInterface; use Rekalogika\\Mapper\\MethodMapper\\SubMapperInterface; final class MoneyDto implements MapToObjectInterface { // ... public function mapToObject( object|string $target, SubMapperInterface $mapper, Context $context ): object { return Money::of($this-&gt;amount, $this-&gt;currency); } }   ","version":"Next","tagName":"h2"},{"title":"SubMapper‚Äã","type":1,"pageTitle":"Manual Mapping using a Class Factory Method","url":"/mapper/class-factory-mapper#submapper","content":" The $mapper parameter in the mapFromObject() and mapToObject() methods provides you with the SubMapper. Read more about the sub mapper in theSubMapper chapter. ","version":"Next","tagName":"h2"},{"title":"Mapping Arrays & Array-Like Objects","type":0,"sectionRef":"#","url":"/mapper/collection","content":"","keywords":"","version":"Next"},{"title":"Mapping to an Array‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#mapping-to-an-array","content":" Suppose you have these entities:  use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; class Post { /** @var Collection&lt;int,Comment&gt; */ private Collection $comments; public function __construct() { $this-&gt;comments = new ArrayCollection(); } /** * @return Collection&lt;int,Comment&gt; */ public function getComments(): Collection { return $this-&gt;comments; } } class Comment { private string $text; public function __construct(string $text) { $this-&gt;text = $text; } public function getText(): string { return $this-&gt;text; } }   To map those entities to the corresponding DTOs, you can simply create the DTOs like the following. Notice the type-hint of the $comments property:  class PostDto { /** @var ?array&lt;int,CommentDto&gt; */ public ?array $comments = null; } class CommentDto { public string $text; }   Then, you can map between the two objects:  /** @var MapperInterface $mapper */ $postDto = $mapper-&gt;map($post, PostDto::class);   info Without the type-hint, the mapper will copy the source objects to the target array as-is.  The source side must be an iterable: an array or a Traversable object, i.e. anything that you can foreach() over.  ","version":"Next","tagName":"h2"},{"title":"Mapping to an Array-Like Object‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#mapping-to-an-array-like-object","content":" You can also map to an array-like object. Example:  class PostDto { /** @var ?\\ArrayObject&lt;int,CommentDto&gt; */ public ?\\ArrayObject $comments = null; }   Supported types of the target side:  ArrayAccessArrayObjectArrayIteratorDoctrine ReadableCollectionDoctrine CollectionDoctrine ArrayCollectionCollectionInterface  ","version":"Next","tagName":"h2"},{"title":"Mapping Using an Adder Method‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#mapping-using-an-adder-method","content":" Mapper supports mapping using an adder method on the target side. Example:  class PostDto { /** @var array&lt;int,CommentDto&gt; */ private array $comments = []; /** * @return array&lt;int,CommentDto&gt; */ public function getComments(): array { return $this-&gt;comments; } public function addComment(CommentDto $comment): void { $this-&gt;comments[] = $comment; } public function removeComment(CommentDto $comment): void { $key = array_search($comment, $this-&gt;comments, true); if ($key !== false) { unset($this-&gt;comments[$key]); } } }   ","version":"Next","tagName":"h2"},{"title":"Generator-Backed Mapping‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#generator-backed-mapping","content":" If the target is type-hinted with Traversable, the mapper will map to aGenerator object.  class PostDto { /** @var ?\\Traversable&lt;int,CommentDto&gt; */ public ?\\Traversable $comments = null; }   With this approach, no values are stored on the target side. Instead, the target will transform the source values to the desired type on-the-fly as you iterate over it.  If the source is an array or an object that implements Countable, the result will also be a Countable, i.e. that you can count() or -&gt;count(). In addition, if your source is an extra-lazy Doctrine Collection, the consumer will be able to count() the target without causing a full hydration of the source.  note For this to work, the target must be null or unset.  ","version":"Next","tagName":"h2"},{"title":"Non-Integer and Non-String Keys‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#non-integer-and-non-string-keys","content":" The mapper supports non-integer and non-string keys if the underlying objects support it, including SplObjectStorage. The key value will be transformed to the target key type-hint, just like the values. Example:  class RelationshipMap { /** @var \\ArrayAccess&lt;Person,Person&gt; */ public \\ArrayAccess $spouseMap; public function __construct() { $this-&gt;spouseMap = new \\SplObjectStorage(); } } class RelationshipMapDto { /** @var ?\\ArrayAccess&lt;PersonDto,PersonDto&gt; */ public ?\\ArrayAccess $spouseMap = null; } $jack = new Person('Jack'); $jill = new Person('Jill'); $map = new RelationshipMap(); $map-&gt;spouseMap[$jack] = $jill; $map-&gt;spouseMap[$jill] = $jack; $mapDto = $mapper-&gt;map($map, RelationshipMapDto::class);   warning For this to work, the type-hint of the target side cannot be SplObjectStorageor other concrete class. Use ArrayAccess instead. Also it must be initially null, not pre-initialized. The mapper uses a custom HashTable object on the target side to accomplish this. Using Traversable type hint also works.  ","version":"Next","tagName":"h2"},{"title":"Lazy Loading‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#lazy-loading","content":" The mapper supports lazy-loading, and will instantiate a lazy-loading object on the target size if the conditions are met.  The target must be type-hinted using Traversable, ArrayAccess, or the special CollectionInterface.If the target is ArrayAccess or CollectionInterface, the source must be an array, or an array-like object that implements ArrayAccess, Traversable, and Countable (pretty much all of them do).The target side cannot be a simple array.The target variable must not be pre-initialized. It must be null or uninitialized.The target property must not be using an adder method.Does not support non-integer, non-string keys.  If lazy loading is active on the target side, and the source supports lazy loading (like Doctrine PersistentCollection), the source will not be hydrated unless the consumer actually uses the mapped property on the target side. This might be useful, like if you are using the DTOs in a view, where you don't always need to use the property. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/mapper/intro","content":"","keywords":"","version":"Next"},{"title":"Synopsis‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#synopsis","content":" use App\\Entity\\Book; use Rekalogika\\Mapper\\MapperInterface; /** @var MapperInterface $mapper */ /** @var Book $book */ $result = $mapper-&gt;map($book, BookDto::class); // or map to an existing object $bookDto = new BookDto(); $mapper-&gt;map($book, $bookDto);   ","version":"Next","tagName":"h2"},{"title":"Why Use a Mapper?‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#why-use-a-mapper","content":" Why do we need to use a mapper to save a few keystrokes, and not just use something simple like this?  class BookDto { public static function create(Book $book): self { $dto = new self(); // ... return $dto; } }   Everyone must have that idea at some point. However, as the project grows, the target classes (DTOs) may start to reference each other, and become a rich object graph. Your code will start to have many special cases, and is no longer as simple as you thought it would be. It becomes harder to maintain, and then eventually forces you to sit back and try to resolve the problem. When (if?) you successfully engineer a solution, you will end up with something that resembles a mapping framework anyway.  Mapping can be simple, but can also become a highly complex task. A mapper is created out of necessity to handle the complexity, not just as a means of saving a few keystrokes.  ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#features","content":" ","version":"Next","tagName":"h2"},{"title":"General‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#general","content":" Automatically lists the properties of the source and target, detects their types, and maps them accordingly.Reads the type from PHP type declaration and PHPDoc annotations, including the type of the nested objects.Does not attempt to circumvent your class constraints. Reads only from and writes only to public properties, getters, setters. Does not instantiate objects without their constructor.Constructor initialization.Handles nested objects.Handles recursion and circular references.Inheritance support. Maps to abstract classes and interfaces using an inheritance map attribute.Maps to and from stdClass, objects extending stdClass, and other objects with dynamic properties (#[AllowDynamicProperties]).Maps an object to an array, and vice versa.  ","version":"Next","tagName":"h3"},{"title":"Custom Mapping‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#custom-mapping","content":" Override the mapping of a specific property using a custom property mapper.Override the mapping between two specific classes using a custom object mapper.Extend the mapper by creating new transformers, or decorating the existing ones.Match classes using attributes in your transformers, in addition to using class names.Preset mapping. Provide a table of predetermined mappings that the mapper can use.  ","version":"Next","tagName":"h3"},{"title":"Object Lazy-Loading‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#object-lazy-loading","content":" If possible, target objects are lazy-loaded. The mapping does not take place until the target is accessed, and will never take place if it is never accessed.Attempts to detect identifier properties on the source side. Those properties will be mapped eagerly to the target side, as they should not trigger the hydration of the source. As an example, API Platform will be able to generate IRIs without causing the hydration of the entire object graph.  ","version":"Next","tagName":"h3"},{"title":"Arrays and Array-Like Objects‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#arrays-and-array-like-objects","content":" Handles the mapping between array or array-like objects.Handles adder methods on the target side.Handles non-string &amp; non-integer keys in array-like objects, includingSplObjectStorage.  ","version":"Next","tagName":"h3"},{"title":"Array-Like Lazy-Loading‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#array-like-lazy-loading","content":" Lazy loading if the target is type-hinted with ArrayAccess, Traversable orCollectionInterface. The target will not iterate the source object until it is accessed, or never if it is never accessed.Stream mapping. Maps the source members to the target side as they are being iterated. This may consume less memory.With lazy loading, if the source is a Countable, then the target will also be a Countable. With an extra-lazy Doctrine Collection, the consumer will be able to count the target without causing a full hydration of the source.  ","version":"Next","tagName":"h3"},{"title":"Development Experience (DX)‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#development-experience-dx","content":" Helpful exception messages.Console commands for debugging.Data collector and profiler integration.Coded from the start using PHP 8, strict types, and maxed-out PHPStan and Psalm level.  ","version":"Next","tagName":"h3"},{"title":"To-Do List‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#to-do-list","content":" Option to read &amp; write to private properties.Migrate engine to symfony/type-info.Auto-detect static factory method.Use our own interface for proxy objects.MapFrom and MapTo attributes.Support ramsey/uuidImprove non-framework usage.Warm up proxies on build time from the list of classes provided by the user.Lazy-loading using Doctrine Collection type hint on the target side.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#contributing","content":" Issues and pull requests should be filed in the GitHub repositoryrekalogika/mapper. ","version":"Next","tagName":"h2"},{"title":"Creating a Custom Transformer","type":0,"sectionRef":"#","url":"/mapper/creating-transformer","content":"","keywords":"","version":"Next"},{"title":"Creating the Transformer‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#creating-the-transformer","content":" Suppose you are using the brick/money library to represent a monetary value in your application, and you need to map the Money object to the following DTO:  src/Dto/MoneyDto.php namespace App\\Dto; class MoneyDto { public function __construct( private string $amount, private string $currency, ) { } public function getAmount(): string { return $this-&gt;amount; } public function getCurrency(): string { return $this-&gt;currency; } }   You can create the transformer as follows:  src/Mapper/MoneyToMoneyDtoTransformer.php namespace App\\Mapper; use Brick\\Money\\Money; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; use Rekalogika\\Mapper\\Contracts\\TypeMapping; use Rekalogika\\Mapper\\Util\\TypeCheck; use Rekalogika\\Mapper\\Util\\TypeFactory; use Symfony\\Component\\PropertyInfo\\Type; class MoneyToMoneyDtoTransformer implements TransformerInterface { // This tells the library that this transformer supports the transformation // from the Money object to the MoneyDto object, and vice versa. // // The TypeFactory methods are convenience methods for creating the // PropertyInfo Type objects. public function getSupportedTransformation(): iterable { yield new TypeMapping( TypeFactory::objectOfClass(Money::class), TypeFactory::objectOfClass(MoneyDto::class) ); yield new TypeMapping( TypeFactory::objectOfClass(MoneyDto::class), TypeFactory::objectOfClass(Money::class) ); } // This method is called when the mapper is trying to transform Money to // MoneyDto, and vice versa. // // The $source and $target parameters are the source and target objects, // respectively. $target is usually null, unless there is already an // existing value in the target object. // // $sourceType and $targetType are the types of the source and target, in // the form of PropertyInfo Type object. // // The TypeCheck class is a convenience class for verifying the type // specified by a Type object. public function transform( mixed $source, mixed $target, ?Type $sourceType, ?Type $targetType, Context $context ): mixed { if ( $source instanceof Money &amp;&amp; TypeCheck::isObjectOfType($targetType, MoneyDto::class) ) { return new MoneyDto( amount: $source-&gt;getAmount()-&gt;__toString(), currency: $source-&gt;getCurrency()-&gt;getCurrencyCode(), ); } if ( $source instanceof MoneyDto &amp;&amp; TypeCheck::isObjectOfType($targetType, Money::class) ) { return Money::of( $source-&gt;getAmount(), $source-&gt;getCurrency() ); } throw new InvalidArgumentException('Unsupported transformation'); } }   ","version":"Next","tagName":"h2"},{"title":"Registering the Transformer‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#registering-the-transformer","content":" If you are not using autoconfiguration, you need to register the transformer and add the rekalogika.mapper.transformer tag:  config/services.yaml services: App\\Mapper\\MoneyToMoneyDtoTransformer: tags: - { name: rekalogika.mapper.transformer, priority: 0 }   info The default priority is 0. The higher the priority, the mapping supplied by the transformer will be considered earlier.  If you are using autoconfiguration, you can use the #[AsTaggedItem] attribute to set its priority.  ","version":"Next","tagName":"h2"},{"title":"Verifying‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#verifying","content":" To verify that the transformer is registered, you can use the debug:containercommand:  php bin/console debug:container --tag=rekalogika.mapper.transformer   Also, you can verify the existence of the transformer in the mapping table:  php bin/console rekalogika:mapper:mapping   ","version":"Next","tagName":"h2"},{"title":"Delegating Mapping to the Main Transformer‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#delegating-mapping-to-the-main-transformer","content":" Your transformer does not need to do everything. You can delegate the mapping of properties or other objects back to the main transformer. To accomplish this, your transformer needs to implement MainTransformerAwareInterface. We also provide MainTransformerAwareTrait to help you with that:  src/Mapper/MyObjectToMyDtoTransformer.php namespace App\\Mapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\MainTransformerAwareInterface; use Rekalogika\\Mapper\\Contracts\\MainTransformerInterface; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; class MyObjectToMyDtoTransformer implements TransformerInterface, MainTransformerAwareInterface { use MainTransformerAwareTrait; public function transform( mixed $source, mixed $target, ?Type $sourceType, ?Type $targetType, Context $context ): mixed { // ... // delegating the task of transforming 'someProperty' to the main // transformer $target-&gt;someProperty = $this-&gt;getMainTransformer()-&gt;transform( source: $source-&gt;getSomeProperty(), target: $target-&gt;someProperty, // current value of the target targetTypes: [TypeFactory::objectOfClass(SomeDto::class)] context: $context ); // ... return $target; } // ... }   ","version":"Next","tagName":"h2"},{"title":"Variant Target Matching‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#variant-target-matching","content":" By default, the target in the mapping is invariant. This means that the target type must exactly be the same as the target specified in the mapping. For example, the mapping MoneyToMoneyDtoTransformer above is invariant. It will only do the mapping if the target is type-hinted exactly MoneyDto, but not any of its subclasses.  To get a variant matching, set the third parameter of TypeMapping to true.  use Brick\\Money\\Money; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; use Rekalogika\\Mapper\\Contracts\\TypeMapping; use Rekalogika\\Mapper\\Util\\TypeFactory; class MoneyToMoneyDtoTransformer implements TransformerInterface { // ... public function getSupportedTransformation(): iterable { yield new TypeMapping( TypeFactory::objectOfClass(Money::class), TypeFactory::objectOfClass(MoneyDto::class), true ); } // ... }   Suppose you have a UsdMoneyDto object that extends MoneyDto, using the example above, the mapping will apply if the target is type-hinted asMoneyDto or UsdMoneyDto.  info The source is always variant.  ","version":"Next","tagName":"h2"},{"title":"Caching and Circular References Detection‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#caching-and-circular-references-detection","content":" If you delegate the mapping of the property of your object, your transformer should add the resulting object to the cache right after instantiation, but before mapping its properties. This is done to prevent infinite recursion when there is a circular reference in the source object.  src/Mapper/MyObjectToMyDtoTransformer.php namespace App\\Mapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\MainTransformerAwareInterface; use Rekalogika\\Mapper\\Contracts\\MainTransformerInterface; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; use Symfony\\Component\\PropertyInfo\\PropertyTypeExtractorInterface; class MyObjectToMyDtoTransformer implements TransformerInterface, { public function transform( mixed $source, mixed $target, ?Type $sourceType, ?Type $targetType, Context $context ): mixed { // ... // instantiate the target object $target = new MyDto(); // add it to the cache $context(ObjectCache::class) -&gt;saveTarget($source, $targetType, $target); // delegate the work of mapping the property to the main transformer $target-&gt;property = $this-&gt;getMainTransformer()-&gt;transform( source: $source-&gt;getProperty(), target: $target-&gt;property, targetTypes: $this-&gt;propertyTypeExtractor -&gt;getTypes($target, 'property'); context: $context ); return $target; } // ... }   ","version":"Next","tagName":"h2"},{"title":"Attribute Matching‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#attribute-matching","content":" You can also match classes using attributes in your transformers, in addition to using class names. The prerequisite is that your attribute needs to implementMapperAttributeInterface.  src/Attribute/MyAttribute.php use Rekalogika\\Mapper\\Attribute\\MapperAttributeInterface; #[\\Attribute(\\Attribute::TARGET_CLASS)] class SomeAttribute implements MapperAttributeInterface { }   Then you can use it as if it is the object's class name in yourgetSupportedTransformation().  src/Mapper/MyObjectToMyDtoTransformer.php use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; use Rekalogika\\Mapper\\Contracts\\TypeMapping; use Rekalogika\\Mapper\\Util\\TypeCheck; use Rekalogika\\Mapper\\Util\\TypeFactory; use Symfony\\Component\\PropertyInfo\\Type; class MyObjectToMyDtoTransformer implements TransformerInterface { // ... public function getSupportedTransformation(): iterable { yield new TypeMapping( TypeFactory::objectOfClass(SomeAttribute::class), TypeFactory::objectOfClass(SomeDto::class) ); } // ... }   When using attributes, the $sourceType and $targetType parameters in thetransform() method will refer to the type of the attribute, not the object.  ","version":"Next","tagName":"h2"},{"title":"Refusal to Transform‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#refusal-to-transform","content":" If the transformer throws RefuseToHandleException, the MainTransformer will pass the mapping to the next transformer in the priority chain.  src/Mapper/MyObjectToMyDtoTransformer.php namespace App\\Mapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; class MyObjectToMyDtoTransformer implements TransformerInterface, { public function transform( mixed $source, mixed $target, ?Type $sourceType, ?Type $targetType, Context $context ): mixed { if ($source instanceof MyObject) { throw new RefuseToHandleException(); } // ... } // ... }   ","version":"Next","tagName":"h2"},{"title":"Property Path‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#property-path","content":" MainInterface::transform() has an optional $path parameter. If your transformer defers the mapping of a property to the main transformer, you should pass the property name to this parameter. It will be used for tracing and for generating a meaningful exception message if the mapping fails.  src/Mapper/MyObjectToMyDtoTransformer.php namespace App\\Mapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; class MyObjectToMyDtoTransformer implements TransformerInterface, { public function transform( mixed $source, mixed $target, ?Type $sourceType, ?Type $targetType, Context $context ): mixed { // ... // delegate the work of mapping the property to the main transformer $target-&gt;someProperty = $this-&gt;getMainTransformer()-&gt;transform( source: $source-&gt;getProperty(), target: $target-&gt;someProperty, targetTypes: $this-&gt;propertyTypeExtractor -&gt;getTypes($target, 'someProperty'); context: $context, path: 'someProperty' ); return $target; } // ... }   If your target object is an array-like object, you should use the [n]notation:  src/Mapper/MyObjectToMyDtoTransformer.php namespace App\\Mapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; class MyObjectToMyDtoTransformer implements TransformerInterface, { public function transform( mixed $source, mixed $target, ?Type $sourceType, ?Type $targetType, Context $context ): mixed { // ... // delegate the work of mapping the array key to the main transformer $target[$key] = $this-&gt;getMainTransformer()-&gt;transform( source: $source[$key], target: $target[$key], targetTypes: $targetTypes, context: $context, path: sprintf('[%s]', $key) ); return $target; } // ... }  ","version":"Next","tagName":"h2"},{"title":"Mapping Table","type":0,"sectionRef":"#","url":"/mapper/mapping-table","content":"","keywords":"","version":"Next"},{"title":"Mapping Table Properties‚Äã","type":1,"pageTitle":"Mapping Table","url":"/mapper/mapping-table#mapping-table-properties","content":" A row in the mapping table has the following properties:  Ordering number. Transformers have a priority. A mapping entry generated by a transformer with a higher priority will be checked earlier than those generated by one with a lower priority.Source and target type pair.Target variance. Invariant means the target type must be exactly the same as specified in the mapping table. Variant means the target type can also be a subclass of the type specified in the mapping table. Note that the source type is always variant.Transformer service ID.  ","version":"Next","tagName":"h2"},{"title":"Viewing the Mapping Table‚Äã","type":1,"pageTitle":"Mapping Table","url":"/mapper/mapping-table#viewing-the-mapping-table","content":" To inspect the mapping table, you can use the rekalogika:mapper:mappingcommand:  $ php bin/console rekalogika:mapper:mapping   The Mapper panel of the Symfony Profiler also shows the mapping table.  ","version":"Next","tagName":"h2"},{"title":"Default Mapping Table‚Äã","type":1,"pageTitle":"Mapping Table","url":"/mapper/mapping-table#default-mapping-table","content":" Ordering\tSource Type\tTarget Type\tTarget Variance\tClass1\tnull\tnull\tinvariant\tNullToNullTransformer 2\tint\tint\tinvariant\tScalarToScalarTransformer 3\tint\tfloat\tinvariant\tScalarToScalarTransformer 4\tint\tstring\tinvariant\tScalarToScalarTransformer 5\tint\tbool\tinvariant\tScalarToScalarTransformer 6\tfloat\tint\tinvariant\tScalarToScalarTransformer 7\tfloat\tfloat\tinvariant\tScalarToScalarTransformer 8\tfloat\tstring\tinvariant\tScalarToScalarTransformer 9\tfloat\tbool\tinvariant\tScalarToScalarTransformer 10\tstring\tint\tinvariant\tScalarToScalarTransformer 11\tstring\tfloat\tinvariant\tScalarToScalarTransformer 12\tstring\tstring\tinvariant\tScalarToScalarTransformer 13\tstring\tbool\tinvariant\tScalarToScalarTransformer 14\tbool\tint\tinvariant\tScalarToScalarTransformer 15\tbool\tfloat\tinvariant\tScalarToScalarTransformer 16\tbool\tstring\tinvariant\tScalarToScalarTransformer 17\tbool\tbool\tinvariant\tScalarToScalarTransformer 18\tstring\tDateTimeInterface\tinvariant\tDateTimeTransformer 19\tstring\tDateTime\tinvariant\tDateTimeTransformer 20\tstring\tDateTimeImmutable\tinvariant\tDateTimeTransformer 21\tstring\tDatePoint\tinvariant\tDateTimeTransformer 22\tDateTimeInterface\tDateTimeInterface\tinvariant\tDateTimeTransformer 23\tDateTimeInterface\tDateTime\tinvariant\tDateTimeTransformer 24\tDateTimeInterface\tDateTimeImmutable\tinvariant\tDateTimeTransformer 25\tDateTimeInterface\tDatePoint\tinvariant\tDateTimeTransformer 26\tDateTimeInterface\tstring\tinvariant\tDateTimeTransformer 27\tstring\tBackedEnum\tvariant\tStringToBackedEnumTransformer 28\tMapToObjectInterface\tobject\tvariant\tClassMethodTransformer 29\tobject\tMapFromObjectInterface\tvariant\tClassMethodTransformer 30\tStringable\tstring\tinvariant\tObjectToStringTransformer 31\tUnitEnum\tstring\tinvariant\tObjectToStringTransformer 32\tTraversable\tCollection\tinvariant\tTraversableToArrayAccessTransformer 33\tTraversable\tReadableCollection\tinvariant\tTraversableToArrayAccessTransformer 34\tTraversable\tArrayCollection\tinvariant\tTraversableToArrayAccessTransformer 35\tTraversable\tArrayObject\tinvariant\tTraversableToArrayAccessTransformer 36\tTraversable\tArrayIterator\tinvariant\tTraversableToArrayAccessTransformer 37\tTraversable\tArrayAccess\tinvariant\tTraversableToArrayAccessTransformer 38\tTraversable\tCollectionInterface\tinvariant\tTraversableToArrayAccessTransformer 39\tTraversable\tarray\tinvariant\tTraversableToArrayAccessTransformer 40\tarray\tCollection\tinvariant\tTraversableToArrayAccessTransformer 41\tarray\tReadableCollection\tinvariant\tTraversableToArrayAccessTransformer 42\tarray\tArrayCollection\tinvariant\tTraversableToArrayAccessTransformer 43\tarray\tArrayObject\tinvariant\tTraversableToArrayAccessTransformer 44\tarray\tArrayIterator\tinvariant\tTraversableToArrayAccessTransformer 45\tarray\tArrayAccess\tinvariant\tTraversableToArrayAccessTransformer 46\tarray\tCollectionInterface\tinvariant\tTraversableToArrayAccessTransformer 47\tarray\tarray\tinvariant\tTraversableToArrayAccessTransformer 48\tTraversable\tTraversable\tinvariant\tTraversableToTraversableTransformer 49\tarray\tTraversable\tinvariant\tTraversableToTraversableTransformer 50\tobject\tarray\tinvariant\tObjectToArrayTransformer 51\tarray\tobject\tvariant\tArrayToObjectTransformer 52\tobject\tobject\tvariant\tObjectToObjectTransformer 53\tnull\tstring\tinvariant\tNullTransformer 54\tnull\tint\tinvariant\tNullTransformer 55\tnull\tfloat\tinvariant\tNullTransformer 56\tnull\tbool\tinvariant\tNullTransformer 57\tnull\tarray\tinvariant\tNullTransformer 58\tmixed\tnull\tinvariant\tNullTransformer 59\tmixed\tmixed\tvariant\tCopyTransformer ","version":"Next","tagName":"h2"},{"title":"Installation & Basic Usage","type":0,"sectionRef":"#","url":"/mapper/installation-usage","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Installation & Basic Usage","url":"/mapper/installation-usage#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony FlexNon-Symfony Projects Open a command console, enter your project directory, and execute: composer require rekalogika/mapper   ","version":"Next","tagName":"h2"},{"title":"Getting the Mapper Service‚Äã","type":1,"pageTitle":"Installation & Basic Usage","url":"/mapper/installation-usage#getting-the-mapper-service","content":" In Symfony projects, you can simply autowire MapperInterface to your services and controllers just as you would do with any other service.  In non-Symfony projects, you can use the MapperFactory to get the mapper service:  use Rekalogika\\Mapper\\MapperFactory; $mapperFactory = new MapperFactory(); $mapper = $mapperFactory-&gt;getMapper();   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Installation & Basic Usage","url":"/mapper/installation-usage#usage","content":" Suppose you have a Book entity:  src/Entity/Book.php namespace App\\Entity; class Book { public function __construct( private int $id, private string $title, private string $author, ) { } public function getId(): ?int { return $this-&gt;id; } public function getTitle(): ?string { return $this-&gt;title; } public function getAuthor(): ?string { return $this-&gt;author; } }   And need to map it to the BookDto data transfer object:  src/Dto/BookDto.php namespace App\\Dto; class BookDto { public string $id; public string $title; public string $author; }   You can simply do:  use App\\Entity\\Book; use Rekalogika\\Mapper\\MapperInterface; /** @var MapperInterface $mapper */ /** @var Book $book */ $result = $mapper-&gt;map($book, BookDto::class); // or map to an existing object $bookDto = new BookDto(); $mapper-&gt;map($book, $bookDto);  ","version":"Next","tagName":"h2"},{"title":"Mapping Between Object and Array","type":0,"sectionRef":"#","url":"/mapper/object-array","content":"Mapping Between Object and Array Mapping between an object and an array follows the same semantics as mapping involving an stdClassobject. Internally, Mapper will convert the array to stdClass, and convert the result back to an array if necessary.","keywords":"","version":"Next"},{"title":"Mapping Object to Object","type":0,"sectionRef":"#","url":"/mapper/object","content":"","keywords":"","version":"Next"},{"title":"How It Works‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#how-it-works","content":" The mapper identifies properties that have the same name on the source and the target side. It looks at public properties, public getters &amp; setters, and constructor arguments.  It gets the existing value on the target side. If it is null, then it instantiates a new target object, populating its constructor arguments by transforming properties of the same name from the source object.  It then transforms each source property to the target type, and sets them on the target.  ","version":"Next","tagName":"h2"},{"title":"Mapping to Abstract Classes and Interfaces‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#mapping-to-abstract-classes-and-interfaces","content":" To map to an abstract class or an interface, you need to add the attributeInheritanceMap to the abstract class or interface. For example:  use Rekalogika\\Mapper\\Attribute\\InheritanceMap; use Rekalogika\\Mapper\\Tests\\Fixtures\\Inheritance\\ConcreteClassA; use Rekalogika\\Mapper\\Tests\\Fixtures\\Inheritance\\ConcreteClassB; #[InheritanceMap([ ConcreteClassA::class =&gt; ConcreteClassADto::class, ConcreteClassB::class =&gt; ConcreteClassBDto::class, ConcreteClassB::class =&gt; ConcreteClassCDto::class, ])] abstract class AbstractClassDto { }   In the above example, the mapper will map the source to ConcreteClassADto if the source is an instance of ConcreteClassA, and so on.  note This only applies if there is no a preexisting object on the target side.  ","version":"Next","tagName":"h2"},{"title":"Custom Property Mapper‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#custom-property-mapper","content":" If you need a custom mapping logic for a specific property, you can create a service and add the attribute AsPropertyMapper to a custom method.  note This is optional. You only need to use this if you need a custom logic to populate a specific target property.  Example:  use Rekalogika\\Mapper\\PropertyMapper\\AsPropertyMapper; class UserMapper { #[AsPropertyMapper( targetClass: UserDto::class, property: 'name', )] public function mapName(User $user): string { return strtoupper($user-&gt;getFirstName() . ' ' . $user-&gt;getLastName()); } }   The above example concatenates first name and last name from the source Userobject, transforms it to uppercase, and returns the result. Mapper will then assign the result to the name property of the target UserDto object, as specified in the arguments of the AsPropertyMapper attribute.  ","version":"Next","tagName":"h2"},{"title":"Shorthand Using AsPropertyMapper Attached to the Class‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#shorthand-using-aspropertymapper-attached-to-the-class","content":" If you have many properties to manually map, you can put the AsPropertyMapperattribute on the class, and it will apply to all methods in the class. Example:  use Rekalogika\\Mapper\\PropertyMapper\\AsPropertyMapper; #[AsPropertyMapper(targetClass: UserDto::class)] class UserMapper { #[AsPropertyMapper('name')] public function mapName(User $user): string { return strtoupper($user-&gt;getFirstName() . ' ' . $user-&gt;getLastName()); } #[AsPropertyMapper('birthDate')] public function mapBirthDate(User $user): string { return $user-&gt;getBirthDate()-&gt;format('Y-m-d'); } #[AsPropertyMapper('email')] public function mapEmail(User $user): string { return $user-&gt;getEmailAddress(); } }   ","version":"Next","tagName":"h3"},{"title":"Property Name Magic‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#property-name-magic","content":" For even more shorthand, you can omit the property name altogether, and the mapper will use the method name, stripping the leading 'map' and lowercasing the first letter.  use Rekalogika\\Mapper\\PropertyMapper\\AsPropertyMapper; #[AsPropertyMapper(targetClass: UserDto::class)] class UserMapper { // maps to 'name' #[AsPropertyMapper] public function mapName(User $user): string { return strtoupper($user-&gt;getFirstName() . ' ' . $user-&gt;getLastName()); } // maps to 'birthDate' #[AsPropertyMapper] public function mapBirthDate(User $user): string { return $user-&gt;getBirthDate()-&gt;format('Y-m-d'); } // maps to 'email #[AsPropertyMapper] public function mapEmail(User $user): string { return $user-&gt;getEmailAddress(); } }   ","version":"Next","tagName":"h3"},{"title":"Extra Arguments‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#extra-arguments","content":" You also have the option to inject the main transformer, sub-mapper, and the context to the property mapper. This can be in any order, but the first argument must be the source object.  use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MainTransformerInterface; use Rekalogika\\Mapper\\PropertyMapper\\AsPropertyMapper; use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; #[AsPropertyMapper(targetClass: UserDto::class)] class UserMapper { #[AsPropertyMapper] public function mapName( User $user, MainTransformerInterface $mainTransformer, SubMapperInterface $subMapper, Context $context ): string { return strtoupper($user-&gt;getFirstName() . ' ' . $user-&gt;getLastName()); } }   ","version":"Next","tagName":"h3"},{"title":"Manual Wiring‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#manual-wiring","content":" If you don't use autowiring, autoconfiguration, or don't want to use attributes, you can add the service manually like this:  config/services.yaml services: App\\Mapper\\UserMapper: tags: - name: 'rekalogika.mapper.property_mapper' method: 'mapName' sourceClass: 'App\\Entity\\User' targetClass: 'App\\Dto\\UserDto' property: 'name' - name: 'rekalogika.mapper.property_mapper' method: 'mapBirthDate' sourceClass: 'App\\Entity\\User' targetClass: 'App\\Dto\\UserDto' property: 'birthDate' - name: 'rekalogika.mapper.property_mapper' method: 'mapEmail' sourceClass: 'App\\Entity\\User' targetClass: 'App\\Dto\\UserDto' property: 'email'   ","version":"Next","tagName":"h3"},{"title":"Dumping Property Mapper Table‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#dumping-property-mapper-table","content":" To dump the list of all property mappers, run the following command:  $ bin/console debug:container --tag=rekalogika.mapper.property_mapper   ","version":"Next","tagName":"h3"},{"title":"Lazy Loading‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#lazy-loading","content":" Mapper will attempt to create a lazy-loading proxy for the target object, and use it in place of the real object. The benefit is that the target object will not be hydrated until it is actually used.  If the source object is a Doctrine entity, the mapping will not trigger the hydration of the source; even accessing ID properties on the target will also not trigger the hydration. Only after accessing other properties of the target will the hydration take place.  warning If the target is final, then lazy-loading will not be possible. There are also other cases that can prevent a lazy-loading proxy from being created. To see if a proxy is being used, or the reason why it is not, you can see that in the Mapper panel in the Symfony profiler.  ","version":"Next","tagName":"h2"},{"title":"Mapping to Doctrine Entities‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#mapping-to-doctrine-entities","content":" Doctrine reads properties using Reflection directly, and therefore will not trigger the hydration of our proxy objects. To prevent problems while working with Doctrine entities, Mapper will prevent proxy creation if the target is a Doctrine entity.  ","version":"Next","tagName":"h3"},{"title":"API Platform‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#api-platform","content":" With API Platform, if you are using DTOs as ApiResource, then API Platform should be able to generate IRIs without causing the hydration of the source (if the source is a Doctrine entity). The only thing you need to do is to ensure the source (a Doctrine entity) and the target (an ApiResource DTO) both use the same identifier property name. Or better: just use id as the identifier everywhere, and be done with it.  Without lazy-loading, API Platform will hydrate everything in the object graph, even when it only needs to generate an IRI.  ","version":"Next","tagName":"h3"},{"title":"Eager Properties‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#eager-properties","content":" During the mapping, Mapper will try to identify the identifier properties on the source side. First, it looks for the information in Doctrine's class metadata. If not found, it will use id, uuid, or identifier if any of those exists on the source side.  These identifier properties will not be lazy, and will be mapped immediately after the instantiation of the target proxy object. This should not cause the hydration of the source side because a Doctrine proxy already hold the identifier, even when uninitialized.  If your application needs to have a custom logic for determining the identifier fields, you can create a service implementingEagerPropertiesResolverInterface.  info If an identifier property maps to a constructor argument on the target side, then everything in the constructor will be mapped eagerly.  ","version":"Next","tagName":"h3"},{"title":"Ad-Hoc Disabling of Lazy-Loading‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#ad-hoc-disabling-of-lazy-loading","content":" There should be no downside to using a lazy-loading proxy in place of the real object. In most cases, they should be interchangeable. However, a proxy incurs a small overhead, and you may wish to disable it in some cases, for example if you are using the Mapper in a batch process.  If you want to disable lazy-loading for a mapping run, you can set the optionenableLazyLoading to false in the MapperOptions object, and add it to the context:  use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Context\\MapperOptions; $options = new MapperOptions(lazyLoading: false); $context = Context::create($options); $target = $this-&gt;mapper-&gt;map($source, TargetDto::class, $context);   ","version":"Next","tagName":"h3"},{"title":"Other Ways of Disabling Lazy-Loading‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#other-ways-of-disabling-lazy-loading","content":" You can make the target final.You can instantiate manually, and pass the object as the mapper's target.You can decorate ProxyGeneratorInterface, and throwProxyNotSupportedException if it asks for your specific class. ReadDoctrineProxyGenerator for example.  ","version":"Next","tagName":"h3"},{"title":"Classes With Dynamic Properties, Including stdClass‚Äã","type":1,"pageTitle":"Mapping Object to Object","url":"/mapper/object#classes-with-dynamic-properties-including-stdclass","content":" Mapper supports classes with #[AllowDynamicProperties], including stdClassand all classes that extends stdClass, with the following semantics.  If the target is stdClass (or an object with #[AllowDynamicProperties]), then all properties of the source will be mapped to the target. If the target has explicit properties, then they will be respected as usual.  If the source is a stdClass (or an object with #[AllowDynamicProperties]) and the target is a regular object, then the mapping will take place for each property of the target that has a matching property on the source side. ","version":"Next","tagName":"h2"},{"title":"Overriding a Mapping Table Entry","type":0,"sectionRef":"#","url":"/mapper/overriding-transformer","content":"Overriding a Mapping Table Entry If the mapper chooses the wrong transformer for a specific source and target type pair, you can override it by decorating the correct transformer and adding it to the mapping table. note Note that in this case, we don't decorate the transformer to replace the original transformer in the dependency injection container. Instead, we are &quot;duplicating&quot; an existing transformer, override its type mapping information, and putting it earlier in the mapping table. Suppose you have a YourObject class and a YourObjectDto class, but the mapper does not use the desired transformer for the job. You can fix it by decorating the correct transformer like this: use Rekalogika\\Mapper\\Transformer\\AbstractTransformerDecorator; use Rekalogika\\Mapper\\Transformer\\ObjectToObjectTransformer; use Rekalogika\\Mapper\\Transformer\\Contracts\\TypeMapping; use Rekalogika\\Mapper\\Util\\TypeFactory; class OverrideTransformer extends AbstractTransformerDecorator { public function __construct(ObjectToObjectTransformer $transformer) { parent::__construct($transformer); } public function getSupportedTransformation(): iterable { yield new TypeMapping( TypeFactory::objectOfClass(YourObject::class), TypeFactory::objectOfClass(YourObjectDto::class), ); } } With the above example, when the source is YourObject and the target isYourObjectDto, the mapper will now choose ObjectToObjectTransformer instead of choosing from the rest of the mapping table.","keywords":"","version":"Next"},{"title":"Rationale, or Why Create Another Mapper?","type":0,"sectionRef":"#","url":"/mapper/rationale","content":"Rationale, or Why Create Another Mapper? TLDR: Needs to respect class constraints.Automatic mapping based on type information in the classes.Option to have a custom mapping logic.The custom mapping logic needs to have easy access to the main mapper.Helpful error messages.Easy to extend. info The situation described there is valid at the time of writing, at the start of 2024. The situation may have changed since then. We developed a project that during its planning phase we determined that it would be beneficial to integrate an automapper into the architecture. We looked around and found some potential automappers, and decided to go ahead with the planned architecture. We first triedAutoMapper-Plus and the first stumbling block is that it reads and writes directly to properties, including private properties, which is unacceptable to our purposes. For example, we store monetary values as integers in the object, and convert them from and to Moneyobjects in the getter and setter. Using this mapper, it would get us the raw integers, not the Money objects. We feel it violates the principles of encapsulation, we need a mapper that respects class constraints. However, this was not a blocker as it has the option to use a custom property accessor, and it was possible to resolve this issue by creating an adapter that uses Symfony PropertyAccess component. AutoMapper-Plus can automatically create mapping pairs on-the-fly. But it is limited to simple mapping that does not involve conversion or nested objects. We needed to create a mapping for every non-trivial pair, despite the type information is already there in the involved classes. It would be nice if the mapper can recognize the type information and maps the variables automatically, at least most of the time. Sometimes, it is necessary to have a custom logic in the mapping, and the mapper needs to accommodate that. With AutoMapper-Plus, it is possible to create a custom mapper, but it is not immediately obvious from the interface how to access the main mapper. It would be nice if we can easily delegate mapping tasks to the main mapper when we need to. Next, we tried Jolicode Automapper, formerly known as Jane Automapper. It behaved as expected, there were no big surprises, and there was very little to complain about its behavior. It is very fast as it compiles its mapping code to PHP files. The problem was error handling. When an error occurred in the compiled mappers, it was usually a TypeError that was difficult to debug, and even more difficult to resolve the problem. Addressing the problem requires the skill of working with AST. We found that the problems were usually deployment errors (usually forgetting to clear the cache), some edge cases (easy to work around), or bugs in the mapper. It was rare to get an error, but when it happened, it was difficult and time-consuming to resolve. We did contribute some fixes back to the project. We have come to the realization that automatic mapping has these inherent risks, and when that happens, the mapper should give us a clear error message, including in which mapping pairs the error occurred. The second problem was that the mapper was difficult to extend. Adding a new transformer requires the knowledge of working with AST, and there was no option to do a mapping using plain old PHP code that you write yourself, except for some limited usage. We hit a brick wall when a new requirement surfaced that requires the mapper to target an abstract class, a feature that was not supported by the mapper. We figured it would be easier for us to spend a week creating our own mapper from scratch using our experiences with the other mappers. Note: it now supports manual mapping using plain PHP. Other mappers that were considered: MicroMapper is a mapper that requires you to write the mapping code yourself. It is all manual work, but still working within the mapping framework, and should be suitable for our purpose, as long as we are willing to write the mapping code ourselves. It also easily lets us delegate the mapping of child properties to the main mapper. We feel the MicroMapper model is not that much more work compared to creating a custom mapping configuration in other mappers, especially with AI code generation. We only tried MicroMapper briefly; however, we were way past of contemplating whether to do the mapping manually. If MicroMapper were available at the time we started the project, it would be our first choice. Pull request for a future Symfony Mapper. In the form that I saw it, it was too simplistic, and does not provide any extension points. But it is currently the only open pull request about mapper in Symfony, so it is something to look forward to in the future.","keywords":"","version":"Next"},{"title":"Manual Mapping using an Object Mapper","type":0,"sectionRef":"#","url":"/mapper/object-mapper","content":"","keywords":"","version":"Next"},{"title":"Extra Arguments‚Äã","type":1,"pageTitle":"Manual Mapping using an Object Mapper","url":"/mapper/object-mapper#extra-arguments","content":" You also have the option to inject the main transformer, sub-mapper, and the context to the property mapper. This can be in any order, but the first argument must be the source object.  use Brick\\Money\\Money; use Rekalogika\\Mapper\\Attribute\\AsObjectMapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MainTransformerInterface; use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; class MoneyObjectMapper { #[AsObjectMapper] public function mapMoneyToMoneyDto( Money $money, MainTransformerInterface $mainTransformer, SubMapperInterface $subMapper, Context $context ): MoneyDto { return new MoneyDto( $money-&gt;getAmount()-&gt;__toString(), $money-&gt;getCurrency()-&gt;getCurrencyCode(), ); } }   Read more about the sub mapper in the SubMapper chapter.  ","version":"Next","tagName":"h2"},{"title":"Using a Lazy-Loading Proxy‚Äã","type":1,"pageTitle":"Manual Mapping using an Object Mapper","url":"/mapper/object-mapper#using-a-lazy-loading-proxy","content":" Instead of doing the mapping immediately, you can also use the createProxy()method to create a target proxy object. The mapping will be deferred to the point when you first access the properties of the proxy object.  use Brick\\Money\\Money; use Rekalogika\\Mapper\\Attribute\\AsObjectMapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MainTransformerInterface; use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; class MoneyObjectMapper { #[AsObjectMapper] public function mapMoneyToMoneyDto( Money $source, SubMapperInterface $subMapper, ): MoneyDto { return $subMapper-&gt;createProxy( MoneyDto::class, static function (MoneyDto $target) use ($source) { $target-&gt;__construct( $source-&gt;getAmount()-&gt;__toString(), $source-&gt;getCurrency()-&gt;getCurrencyCode(), ); }, ); } }   Read more about the createProxy() method in the SubMapperchapter. ","version":"Next","tagName":"h2"},{"title":"Predetermined Mapping Preset","type":0,"sectionRef":"#","url":"/mapper/preset","content":"","keywords":"","version":"Next"},{"title":"Usage‚Äã","type":1,"pageTitle":"Predetermined Mapping Preset","url":"/mapper/preset#usage","content":" use Rekalogika\\Mapper\\MapperInterface; use Rekalogika\\Mapper\\Transformer\\Context\\PresetMapping; use Rekalogika\\Mapper\\Context\\Context; /** @var MapperInterface $mapper */ /** @var Book $book */ /** @var BookDto $bookDto */ // this means if a Book is being mapped to a BookDto, use the provided $bookDto $presetMapping = new PresetMapping([ $book =&gt; [ BookDto::class =&gt; $bookDto, ] ]) $context = Context::create($presetMapping); $result = $mapper-&gt;map($book, BookDto::class, $context); assert($bookDto === $result); // true   ","version":"Next","tagName":"h2"},{"title":"Populating PresetMapping from an Existing ObjectCache‚Äã","type":1,"pageTitle":"Predetermined Mapping Preset","url":"/mapper/preset#populating-presetmapping-from-an-existing-objectcache","content":" You can use the ObjectCache from a previous mapping to populate thePresetMapping object.  use Rekalogika\\Mapper\\ObjectCache\\ObjectCacheFactoryInterface; use Rekalogika\\Mapper\\Transformer\\Context\\PresetMapping; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MapperInterface; /** @var ObjectCacheFactoryInterface $objectCacheFactory */ /** @var MapperInterface $mapper */ /** @var Book $book */ /** @var BookDto $bookDto */ $objectCache = $objectCacheFactory-&gt;createObjectCache(); $context = Context::create($objectCache); $result = $mapper-&gt;map($book, BookDto::class, $context); $presetMapping = PresetMappingFactory::fromObjectCache($objectCache); // or to get the reversed mapping: $reversedMapping = PresetMappingFactory::fromObjectCacheReversed($objectCache); // ...   You can also generate the reversed mapping from the cache. i.e, a mapping from$book to BookDto::class will generate a PresetMapping containing the mapping from the previous result to Book::class.  use Rekalogika\\Mapper\\Transformer\\Context\\PresetMappingFactory; $reversedPresetMapping = PresetMappingFactory::fromObjectCacheReversed($objectCache);   ","version":"Next","tagName":"h2"},{"title":"Example Use Case: Remembering Mapper‚Äã","type":1,"pageTitle":"Predetermined Mapping Preset","url":"/mapper/preset#example-use-case-remembering-mapper","content":" A mapper that remembers the previous mappings. So you can get the original source object if you have the resulting DTO.  use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Exception\\UnexpectedValueException; use Rekalogika\\Mapper\\MapperInterface; use Rekalogika\\Mapper\\ObjectCache\\ObjectCacheFactoryInterface; use Rekalogika\\Mapper\\Transformer\\Context\\PresetMapping; use Rekalogika\\Mapper\\Transformer\\Context\\PresetMappingFactory; use Symfony\\Contracts\\Service\\ResetInterface; class RememberingMapper implements MapperInterface, ResetInterface { private PresetMapping $presetMapping; public function __construct( private MapperInterface $decorated, private ObjectCacheFactoryInterface $objectCacheFactory ) { $this-&gt;presetMapping = new PresetMapping(); } public function reset(): void { $this-&gt;presetMapping = new PresetMapping(); } public function map( object $source, object|string $target, ?Context $context = null ): object { $objectCache = $this-&gt;objectCacheFactory-&gt;createObjectCache(); $context ??= Context::create(); $context = $context-&gt;with($objectCache, $this-&gt;presetMapping); $result = $this-&gt;decorated-&gt;map($source, $target, $context); $newPresetMapping = PresetMappingFactory::fromObjectCacheReversed($objectCache); $this-&gt;presetMapping-&gt;mergeFrom($newPresetMapping); return $result; } }  ","version":"Next","tagName":"h2"},{"title":"rekalogika/psr-16-simple-cache-bundle","type":0,"sectionRef":"#","url":"/psr-16-simple-cache-bundle","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"rekalogika/psr-16-simple-cache-bundle","url":"/psr-16-simple-cache-bundle#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony Flex Open a command console, enter your project directory, and execute: composer require rekalogika/psr-16-simple-cache-bundle   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"rekalogika/psr-16-simple-cache-bundle","url":"/psr-16-simple-cache-bundle#usage","content":" Callers can simply wire in Psr\\SimpleCache\\CacheInterface. The service uses the same underlying pool used by Symfony's CacheInterface.  use Psr\\SimpleCache\\CacheInterface; class SomeService { public function __construct(private CacheInterface $cache) { } public function doSomething() { $this-&gt;cache-&gt;set('foo', 'bar'); } }   ","version":"Next","tagName":"h2"},{"title":"Rationale‚Äã","type":1,"pageTitle":"rekalogika/psr-16-simple-cache-bundle","url":"/psr-16-simple-cache-bundle#rationale","content":" We are using PSR-16 mostly as an expiring key-value storage. While PSR-6 and Symfony's CacheInterface are more powerful and easier to use for caching things, we don't feel their interfaces are suitable for key-value storage.  ","version":"Next","tagName":"h2"},{"title":"Credits‚Äã","type":1,"pageTitle":"rekalogika/psr-16-simple-cache-bundle","url":"/psr-16-simple-cache-bundle#credits","content":" This package is just a service definition. The actual implementation is done by the Symfony project; they just don't make the service available by default.  Adapters For Interoperability between PSR-6 and PSR-16 CacheService definition by Tobion  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"rekalogika/psr-16-simple-cache-bundle","url":"/psr-16-simple-cache-bundle#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"rekalogika/psr-16-simple-cache-bundle","url":"/psr-16-simple-cache-bundle#contributing","content":" Issues and pull requests should be filed in the GitHub repositoryrekalogika/psr-16-simple-cache-bundle. ","version":"Next","tagName":"h2"},{"title":"SubMapper","type":0,"sectionRef":"#","url":"/mapper/submapper","content":"","keywords":"","version":"Next"},{"title":"map() Method‚Äã","type":1,"pageTitle":"SubMapper","url":"/mapper/submapper#map-method","content":" The map() method maps an object to the class or object you specified.  use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; /** @var SubMapperInterface $subMapper */ // using class-string as the target type $postDto = $subMapper-&gt;map($source, PostDto::class); // the target can also be an existing object $postDto = new PostDto(); $subMapper-&gt;map($source, $postDto);   ","version":"Next","tagName":"h2"},{"title":"mapForProperty() Method‚Äã","type":1,"pageTitle":"SubMapper","url":"/mapper/submapper#mapforproperty-method","content":" With the mapForProperty(), you specify the property name of the variable that will contain the result of the mapping. SubMapper will detect the type of the property in $containing::$propertyName and use it as the target type for the mapping.  This is useful if the property is an array or an array-like object, as PHP doesn't have generics and it is not simple to specify the type of the array elements.  use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; class Post { /** @var list&lt;Comment&gt; */ public array $comments; } class Comment {} class PostDto { /** @var list&lt;CommentDto&gt; */ public array $comments; } class CommentDto {} /** @var Post $post */ /** @var SubMapperInterface $subMapper */ $postDto = new PostDto(); $subMapper-&gt;cache($postDto); $commentsDto = $subMapper-&gt;mapForProperty($post-&gt;comments, PostDto::class, 'comments'); $postDto-&gt;comments = $commentsDto;   $containing can be a class string or an existing object. If it is an existing object, SubMapper will attempt to retrieve the current object from the property and map the source to it.  ","version":"Next","tagName":"h2"},{"title":"cache() Method‚Äã","type":1,"pageTitle":"SubMapper","url":"/mapper/submapper#cache-method","content":" To reduce the possibility of infinite recursion due to circular references, you can use the cache() method to store the object that is being mapped. You should call cache() after you instantiate the object and before you delegate the mapping of its properties by calling map() or mapForProperty().  use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; /** @var SubMapperInterface $subMapper */ $postDto = new PostDto(); $subMapper-&gt;cache($postDto); $postDto-&gt;author = $subMapper-&gt;map($source-&gt;author, AuthorDto::class); return $postDto;   ","version":"Next","tagName":"h2"},{"title":"createProxy() Method‚Äã","type":1,"pageTitle":"SubMapper","url":"/mapper/submapper#createproxy-method","content":" You can use the createProxy() method to create a proxy object that will be initialized only after you first access its properties.  use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; /** @var SubMapperInterface $subMapper */ /** @var Post $source */ // this is the function that will be used to initialize the proxy object $initializer = static function ( PostDto $target ) use ($source): void { $target-&gt;__construct(); $target-&gt;name = $source-&gt;getName(); }; $postDto = $subMapper-&gt;createProxy( PostDto::class, // real target class $initializer, // will be executed when the proxy is first accessed ['id'] // eager properties, accessing these will not trigger the // hydration of the proxy object ); // id is eager, so this will not cause the initializer to be called. $postDto-&gt;id = $post-&gt;getId(); // this will trigger the initializer $name = $postDto-&gt;name;  ","version":"Next","tagName":"h2"},{"title":"rekalogika/reconstitutor","type":0,"sectionRef":"#","url":"/reconstitutor","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/reconstitutor","url":"/reconstitutor#sections","content":" üìÑÔ∏è Introduction &amp; Installation This library provides a thin layer that sits above Doctrine events to help you üìÑÔ∏è Usage Explains how to use the reconstitutor library. ","version":"Next","tagName":"h2"},{"title":"Introduction & Installation","type":0,"sectionRef":"#","url":"/reconstitutor/intro","content":"","keywords":"","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/reconstitutor/intro#features","content":" Simple declaration in a class. You can create a reconstitutor class to handle the reconstitution of a specific entity class, entities that implement a specific interface, entities in a class hierarchy, or those with a specific PHP attribute.Our abstract classes provide get() and set() methods as a convenience. They let you work with the properties directly, bypassing getters and setters. It is the best practice in reconstitutions as it frees you to have business logic in the getters and setters.The get() and set() methods are forwarders to a custom implementation of Symfony's PropertyAccessorInterface. Therefore, you can use the same exceptions defined in PropertyAccessorInterface.It has what we think is the correct behavior. It asks your reconstitutor to save only after Doctrine has successfully saved the object. It doesn't rely on Doctrine seeing the object being dirty before flush()-ing. i.e. your entities don't have to modify a Doctrine-managed property ‚Äîlike$lastUpdated‚Äî just to make sure the correct Doctrine event will be fired.  ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/reconstitutor/intro#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony Flex Open a command console, enter your project directory, and execute: composer require rekalogika/reconstitutor   ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/reconstitutor/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/reconstitutor/intro#contributing","content":" Issues and pull requests should be filed in the GitHub repositoryrekalogika/reconstitutor. ","version":"Next","tagName":"h2"},{"title":"API Platform Integration","type":0,"sectionRef":"#","url":"/rekapager/api-platform","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"API Platform Integration","url":"/rekapager/api-platform#installation","content":" Preinstallation checklists:  Make sure Composer is installed globally, as explained in the installation chapter of the Composer documentation. Run composer about to verify.Make sure your project has Symfony Flex installed and enabled (it is enabled by default). Run composer why symfony/flex to verify.  Open a command console, enter your project directory, and execute:  composer require rekalogika/rekapager-api-platform   ","version":"Next","tagName":"h2"},{"title":"Provided Components‚Äã","type":1,"pageTitle":"API Platform Integration","url":"/rekapager/api-platform#provided-components","content":" A decorator for OpenApiFactoryInterface that changes the type of every 'page' query parameter from integer to string. It should still be compatible with API Platform's standard pagination system.PagerNormalizer: a normalizer for PagerInterface.RekapagerExtension: an extension for API Platform's Doctrine ORM integration to use Rekapager.PagerFactory: creates a PagerInterface object from a PageableInterface, the current operation, and the context. Useful in a state provider or processor.  ","version":"Next","tagName":"h2"},{"title":"Usage in a State Provider or Processor‚Äã","type":1,"pageTitle":"API Platform Integration","url":"/rekapager/api-platform#usage-in-a-state-provider-or-processor","content":" In a state provider, you can use PagerFactoryInterface to transform anyPageableInterface into a PagerInterface. Then, you can simply return the pager instance and our PagerNormalizer will output it correctly.  use ApiPlatform\\Metadata\\Operation; use ApiPlatform\\State\\ProviderInterface; use Rekalogika\\Rekapager\\ApiPlatform\\PagerFactoryInterface; use Rekalogika\\Rekapager\\Doctrine\\Collections\\SelectableAdapter; use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; /** * @implements ProviderInterface&lt;Post&gt; */ class PostProvider implements ProviderInterface { public function __construct( private PostRepository $postRepository, private PagerFactoryInterface $pagerFactory, ) { } public function provide( Operation $operation, array $uriVariables = [], array $context = [] ): object|array|null { $adapter = new SelectableAdapter($this-&gt;postRepository); $pageable = new KeysetPageable($adapter); $pager = $this-&gt;pagerFactory-&gt;createPager($pageable, $operation, $context); return $pager; } }   PagerFactory should respect these standard API Platform settings in the operation, as well as their corresponding global settings.  paginationItemsPerPage: the number of items per page.paginationClientEnabled: whether to enable the pagination settings from the client.paginationClientItemsPerPage: the number of items per page that the client requested.paginationMaximumItemsPerPage  ","version":"Next","tagName":"h2"},{"title":"Doctrine ORM Support‚Äã","type":1,"pageTitle":"API Platform Integration","url":"/rekapager/api-platform#doctrine-orm-support","content":" This package supports the pagination for API Platform's Doctrine ORM integration as an alternative to the default pagination. Its usage is opt-in. You can enable it per operation using the rekapager_orm_enabled extra property:  #[ApiResource( extraProperties: [ 'rekapager_orm_enabled' =&gt; true ] )] class Post { // ... }   To enable it globally, you can set it in the configuration:  config/packages/api_platform.yaml api_platform: defaults: extra_properties: rekapager_orm_enabled: true  ","version":"Next","tagName":"h2"},{"title":"Usage","type":0,"sectionRef":"#","url":"/reconstitutor/usage","content":"","keywords":"","version":"Next"},{"title":"Reconstitution of a Class‚Äã","type":1,"pageTitle":"Usage","url":"/reconstitutor/usage#reconstitution-of-a-class","content":" This will apply to objects that are instances of a specific class, subclasses of a specific class, or implement a specific interface.  Suppose you have an Order object that stores a payment receipt in thepaymentReceipt property:  use Symfony\\Component\\HttpFoundation\\File\\File; use Symfony\\Component\\Uid\\UuidV7; class Order { private string $id; private ?File $paymentReceipt = null; public function __construct() { $this-&gt;id = new UuidV7; } public function getId(): string { return $this-&gt;id; } public function getPaymentReceipt(): ?File { return $this-&gt;paymentReceipt; } public function setPaymentReceipt(File $paymentReceipt): void { $this-&gt;paymentReceipt = $paymentReceipt; } }   note In the above class, Doctrine related attributes are omitted for brevity.  During the fetching of the object from the database, Doctrine will instantiate the object and hydrate $id and other properties that it manages. Afterward, it will be our reconstitutor's turn to handle the $paymentReceipt property. Similar things also happen when the object is persisted to the database, or removed.  use Rekalogika\\Reconstitutor\\AbstractClassReconstitutor; use Symfony\\Component\\HttpFoundation\\File\\File; /** * @extends AbstractClassReconstitutor&lt;Order&gt; */ final class OrderReconstitutor extends AbstractClassReconstitutor { /** * The class that this reconstitutor manages. It can also be a super class * or an interface. */ public static function getClass(): string { return Order::class; } /** * When the object is being saved, we check if the paymentReceipt has been * just uploaded. If it is, we save it to a file. */ public function onSave(object $order): void { $path = sprintf('/tmp/payment_receipt/%s', $order-&gt;getId()); $file = $this-&gt;get($order, 'paymentReceipt'); if ($file instanceof UploadedFile) { file_put_contents($path, $file-&gt;getContent()); $this-&gt;set($order, 'paymentReceipt', new File($path)); } } /** * When the object is being loaded from the database, we check if the * supposed payment receipt is already saved. If it is, then we load the * file to the property. */ public function onLoad(object $order): void { $path = sprintf('/tmp/payment_receipt/%s', $order-&gt;getId()); if (file_exists($path)) { $file = new File($path); } else { $file = null; } $this-&gt;set($order, 'paymentReceipt', $file); } /** * If the order is being removed, we remove the associated payment receipt * here. */ public function onRemove(object $order): void { $path = sprintf('/tmp/payment_receipt/%s', $order-&gt;getId()); if (file_exists($path)) { unlink($path); } } }   ","version":"Next","tagName":"h2"},{"title":"Reconstitution of Classes With a Specific PHP Attribute‚Äã","type":1,"pageTitle":"Usage","url":"/reconstitutor/usage#reconstitution-of-classes-with-a-specific-php-attribute","content":" Alternatively, you can also target classes with a specific PHP attribute. The following modifies above example to use an attribute for targeting.  The entity class:  use Symfony\\Component\\HttpFoundation\\File\\File; use Symfony\\Component\\Uid\\UuidV7; #[MyAttribute] class Order { // ... }   And the reconstitutor class:  use Rekalogika\\Reconstitutor\\AbstractAttributeReconstitutor; use Symfony\\Component\\HttpFoundation\\File\\File; final class OrderReconstitutor extends AbstractAttributeReconstitutor { /** * If the object has this attribute, then we are going to handle it. */ public static function getAttributeClass(): string { return MyAttribute::class; } public function onSave(object $order): void { // ... } public function onLoad(object $order): void { // ... } public function onRemove(object $order): void { // ... } }   ","version":"Next","tagName":"h2"},{"title":"get() and set() Helpers‚Äã","type":1,"pageTitle":"Usage","url":"/reconstitutor/usage#get-and-set-helpers","content":" In reconstitution, you should get and set the object's properties directly, bypassing the getters and setters, just like what Doctrine does. To help you with that, the abstract classes provide the get() and set() helpers.  These are just forwarders to our custom implementation of the familiar Symfony PropertyAccess (see rekalogika/direct-property-accessfor more information). Therefore, you can catch the same exceptions as you would when using the original Symfony PropertyAccess. ","version":"Next","tagName":"h2"},{"title":"Adapters","type":0,"sectionRef":"#","url":"/rekapager/adapters","content":"","keywords":"","version":"Next"},{"title":"Doctrine ORM QueryBuilder Adapter‚Äã","type":1,"pageTitle":"Adapters","url":"/rekapager/adapters#doctrine-orm-querybuilder-adapter","content":" composer require rekalogika/rekapager-doctrine-orm-adapter   The QueryBuilderAdapter supports keyset pagination. The class requires aQueryBuilder instance with the following conditions:  It must have a sort order. Be sure to call orderBy() or addOrderBy() on the query builder before passing it to the adapter.If a field in a sort order uses non-scalar type, you should provide a type mapping. The adapter will use it in the setParameter() method of theQueryBuilder. See the example below.  info If you don't provide a type mapping, the adapter will try to look it up from Doctrine's class metadata. If it fails, it will use heuristics to detect the type for some common objects.  use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\EntityRepository; use Rekalogika\\Rekapager\\Doctrine\\ORM\\QueryBuilderAdapter; use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; /** @var EntityRepository $postRepository */ $queryBuilder = $postRepository -&gt;createQueryBuilder('p') -&gt;where('p.group = :group') -&gt;setParameter('group', $group) -&gt;addOrderBy('p.date', 'DESC') // a date field that accepts DateTime -&gt;addOrderBy('p.title', 'ASC') -&gt;addOrderBy('p.id', 'ASC'); $adapter = new QueryBuilderAdapter( queryBuilder: $queryBuilder, typeMapping: [ 'p.date' =&gt; Types::DATE_MUTABLE // the type of the date field ] ); // QueryBuilderAdapter only supports Keyset pagination $pageable = new KeysetPageable($adapter);   ","version":"Next","tagName":"h2"},{"title":"Doctrine Collections Selectable Adapter‚Äã","type":1,"pageTitle":"Adapters","url":"/rekapager/adapters#doctrine-collections-selectable-adapter","content":" composer require rekalogika/rekapager-doctrine-collections-adapter   The SelectableAdapter supports both keyset and offset pagination. The class requires a Selectable instance. Usually, it is a Doctrine Collection used in entities, or a Doctrine repository.  The class needs to work with a Criteria object, but if the caller omits it, the adapter will create an empty Criteria object. If the Criteria does not have a sort order, the adapter will sort the collection using the field id. If the object does not have an id field, Doctrine will throw an exception.  use Doctrine\\Common\\Collections\\Criteria; use Doctrine\\ORM\\EntityRepository; use Rekalogika\\Rekapager\\Doctrine\\Collections\\SelectableAdapter; use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; use Rekalogika\\Rekapager\\Offset\\OffsetPageable; /** @var EntityRepository $postRepository */ $selectable = $postRepository; // a Doctrine repository is also a Selectable // or $selectable = $user-&gt;getComments(); // a Doctrine Collection in an entity $criteria = Criteria::create() -&gt;where(Criteria::expr()-&gt;eq('group', $group)) -&gt;orderBy([ 'date' =&gt; Order::Descending, 'title' =&gt; Order::Ascending, 'id' =&gt; Order::Ascending ]); $adapter = new SelectableAdapter($selectable, $criteria); $pageable = new KeysetPageable($adapter); // or $pageable = new OffsetPageable($adapter);   ","version":"Next","tagName":"h2"},{"title":"Doctrine Collections Collection Adapter‚Äã","type":1,"pageTitle":"Adapters","url":"/rekapager/adapters#doctrine-collections-collection-adapter","content":" composer require rekalogika/rekapager-doctrine-collections-adapter   The CollectionAdapter supports only offset pagination. The class works with a Doctrine ReadableCollection (also Collection) instance.  use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\Rekapager\\Doctrine\\Collections\\CollectionAdapter; use Rekalogika\\Rekapager\\Offset\\OffsetPageable; /** @var Collection $collection */ $collection = $user-&gt;getComments(); // a Doctrine Collection in an entity $adapter = new CollectionAdapter($collection); $pageable = new OffsetPageable($adapter);   ","version":"Next","tagName":"h2"},{"title":"Pagerfanta Adapter Adapter‚Äã","type":1,"pageTitle":"Adapters","url":"/rekapager/adapters#pagerfanta-adapter-adapter","content":" composer require rekalogika/rekapager-pagerfanta-adapter   Allows leveraging any of the existing Pagerfanta adapters. ThePagerfantaAdapterAdapter supports only offset pagination. The adapter takes a Pagerfanta's AdapterInterface instance as its argument.  use Pagerfanta\\Doctrine\\Collections\\SelectableAdapter; use Rekalogika\\Rekapager\\Offset\\OffsetPageable; use Rekalogika\\Rekapager\\Pagerfanta\\PagerfantaAdapterAdapter; $criteria = Criteria::create() -&gt;where(Criteria::expr()-&gt;eq('group', $group)); $pagerfantaAdapter = new SelectableAdapter($user-&gt;getPosts(), $criteria); $adapter = new PagerfantaAdapterAdapter($pagerfantaAdapter); $pageable = new OffsetPageable($adapter);   info If you already have a Pagerfanta instance, you can use PagerfantaPageableinstead. ","version":"Next","tagName":"h2"},{"title":"rekalogika/rekapager","type":0,"sectionRef":"#","url":"/rekapager","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/rekapager","url":"/rekapager#sections","content":" üìÑÔ∏è Introduction Rekapager is a pagination library for PHP, supporting both offset-based and üìÑÔ∏è Installation You need to install the integration package for the framework you are using. üìÑÔ∏è Adapters An adapter provides a common interface for different types of underlying data. üìÑÔ∏è Pageables and Pages A PageableInterface represents a collection that can be üìÑÔ∏è Pager and PagerItem A PagerInterface represents navigation through a collection of items. A view üìÑÔ∏è Symfony Integration Symfony integration is provided by the package rekalogika/rekapager-bundle. üìÑÔ∏è API Platform Integration API Platform integration is provided by the package üìÑÔ∏è Batch Processing Any PageableInterface objects can be used to iterate its underlying data page üìÑÔ∏è Integrating Rekapager into a Framework This document explains what you need to do to integrate Rekapager into a üìÑÔ∏è Known Issues SelectableAdapter ","version":"Next","tagName":"h2"},{"title":"Batch Processing","type":0,"sectionRef":"#","url":"/rekapager/batch-processing","content":"","keywords":"","version":"Next"},{"title":"Prerequisites‚Äã","type":1,"pageTitle":"Batch Processing","url":"/rekapager/batch-processing#prerequisites","content":" When using the library only for batch processing, you only need to install the adapters you need. Framework integration is not required.  ","version":"Next","tagName":"h2"},{"title":"Batch Processing‚Äã","type":1,"pageTitle":"Batch Processing","url":"/rekapager/batch-processing#batch-processing","content":" To iterate over a large amount of data, you can use the following pattern:  use Doctrine\\ORM\\EntityManagerInterface; use Rekalogika\\Rekapager\\PageableInterface; /** @var PageableInterface $pageable */ /** @var EntityManagerInterface $entityManager */ foreach ($pageable-&gt;withItemsPerPage(1000)-&gt;getPages() as $page) { foreach ($page as $item) { // Do something with the item } // Do something after each page here // With Doctrine, you'd usually want to flush() and clear() here $entityManager-&gt;flush(); // if required $entitymanager-&gt;clear(); }   Protip You should always use keyset pagination for batch processing large amounts of data residing in a database. ","version":"Next","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/rekapager/installation","content":"Installation You need to install the integration package for the framework you are using. Currently, there are Symfony integration andAPI Platform integration. Then, install one or more adapters that you need for your project. Protip If you are using this library only for batch processing, then installing only the adapters you need is sufficient.","keywords":"","version":"Next"},{"title":"Known Issues","type":0,"sectionRef":"#","url":"/rekapager/known-issues","content":"","keywords":"","version":"Next"},{"title":"SelectableAdapter‚Äã","type":1,"pageTitle":"Known Issues","url":"/rekapager/known-issues#selectableadapter","content":" There is a Doctrine bug involving -&gt;matching()-&gt;count(). If the Criteria has a maxResults, then it will be disregarded and the count() will return the total number of items as if the maxResults were not set.  issue #9951issue #10766PR #10767  We work around this bug by fetching the items and counting them manually. This is suboptimal, but it works. If performance is critical, use a small proximity and a small page size. Or, use QueryBuilderAdapter instead. ","version":"Next","tagName":"h2"},{"title":"Integrating Rekapager into a Framework","type":0,"sectionRef":"#","url":"/rekapager/integrating","content":"","keywords":"","version":"Next"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"Integrating Rekapager into a Framework","url":"/rekapager/integrating#dependencies","content":" The integration package should depend on:  rekalogika/rekapager-contractsrekalogika/rekapager-core  ","version":"Next","tagName":"h2"},{"title":"Implement PageIdentifierEncoderLocatorInterface‚Äã","type":1,"pageTitle":"Integrating Rekapager into a Framework","url":"/rekapager/integrating#implement-pageidentifierencoderlocatorinterface","content":" It takes the class name of a page identifier object, and returns an instance ofPageIdentifierEncoderInterface that will be used to encode and decode the page identifier.  Rekapager ships with two pageable types: KeysetPageable and OffsetPageable(PagerfantaPageable is a wrapper around OffsetPageable, so it doesn't apply here). The packages already have the encoders, all you need to do is to wire their dependencies, and implement the locator.  ","version":"Next","tagName":"h2"},{"title":"Implement PageUrlGeneratorInterface‚Äã","type":1,"pageTitle":"Integrating Rekapager into a Framework","url":"/rekapager/integrating#implement-pageurlgeneratorinterface","content":" It takes a page identifier already converted into a string, and returns a URL containing the string.  ","version":"Next","tagName":"h2"},{"title":"Create a Pager Factory‚Äã","type":1,"pageTitle":"Integrating Rekapager into a Framework","url":"/rekapager/integrating#create-a-pager-factory","content":" This factory should do the following:  Take a PageableInterface object from the caller.Determine the page identifier string from the URL. If not found, use the first page as the current page.Transform the string into a page identifier object. You can use the same locator that you implemented earlier. To get the identifier class, you can call the static method getPageIdentifierClass() on the pageable object.Call getPageByIdentifier() on the pageable object to get the current page.Instantiate Pager, and return it.  ","version":"Next","tagName":"h2"},{"title":"Create a Pager Renderer (optional)‚Äã","type":1,"pageTitle":"Integrating Rekapager into a Framework","url":"/rekapager/integrating#create-a-pager-renderer-optional","content":" This class should take a PagerInterface object, and render the pagination control in the user interface, which is probably the final result that most people are looking for. ","version":"Next","tagName":"h2"},{"title":"Pager and PagerItem","type":0,"sectionRef":"#","url":"/rekapager/pager-pageritem","content":"Pager and PagerItem A PagerInterface represents navigation through a collection of items. A view layer can use it to render a pagination control. A pager works at a higher level than a PageableInterface. It needs to be able to determine the current page from the context of the request, and to be able to generate URLs for each page. A framework integration will give you a way to transform a PageableInterface object into a PagerInterface object. A pager has many pager items. A pager item is an extended page object that contains a URL.","keywords":"","version":"Next"},{"title":"Pageables and Pages","type":0,"sectionRef":"#","url":"/rekapager/pageable-page","content":"","keywords":"","version":"Next"},{"title":"Pageable Implementations‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#pageable-implementations","content":" ","version":"Next","tagName":"h2"},{"title":"KeysetPageable‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#keysetpageable","content":" The KeysetPageable is a pageable that supports keyset pagination. It is available with the rekalogika/rekapager-keyset-pagination package.  It takes an implementation of KeysetPaginationAdapterInterface as its argument. The library currently provides two implementations:  SelectableAdapterQueryBuilderAdapter  ","version":"Next","tagName":"h3"},{"title":"OffsetPageable‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#offsetpageable","content":" The OffsetPageable is a pageable that supports offset pagination. It is available with the rekalogika/rekapager-offset-pagination package.  It takes an implementation of OffsetPaginationAdapterInterface as its argument. The library currently provides three implementations:  CollectionAdapterSelectableAdapterPagerfantaAdapterAdapter  PagerfantaAdapterAdapter allows the use of the existing Pagerfanta adapters.  ","version":"Next","tagName":"h3"},{"title":"PagerfantaPageable‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#pagerfantapageable","content":" Takes a Pagerfanta object and turns it into a PageableInterface. It is available with the rekalogika/rekapager-pagerfanta-adapter package.  ","version":"Next","tagName":"h3"},{"title":"Pageable Properties‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#pageable-properties","content":" All PageableInterface implementations should have the following properties.  ","version":"Next","tagName":"h2"},{"title":"Number of items per page‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#number-of-items-per-page","content":" In OffsetPageable &amp; KeysetPageable, the number of items per page is set in the constructor parameter $itemsPerPage, with the default value of 50. InPagerfantaPageable, it is taken from the underlying Pagerfanta object.  The value can be altered post-instantiation using the withItemsPerPage()wither method, or rather you get a new instance with a different number of items per page.  use Rekalogika\\Contracts\\Rekapager\\PageableInterface; /** @var PageableInterface $pageable */ $pageableWith10ItemsPerPage = $pageable-&gt;withItemsPerPage(10);   ","version":"Next","tagName":"h3"},{"title":"The count strategy‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#the-count-strategy","content":" There are three strategies for counting the total number of items: ignore (and assume the count is unknown), fetch the count from the underlying data, or supplied by the caller. By default, all implementations use 'ignore' because it is the safest option.  All pageables accepts the $count parameter in the constructor. The parameter accepts integer or bool. false means the count is unknown, true means the count is fetched from the underlying data, and an integer is the count value supplied by the caller.  ","version":"Next","tagName":"h3"},{"title":"Page limit‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#page-limit","content":" The maximum page number that can be navigated to. Beyond the limit, the page is disabled. By default, the limit is 100.  Only applicable to OffsetPageable and PagerfantaPageable. Does not make sense with KeysetPageable, so the option is not provided there.  ","version":"Next","tagName":"h3"},{"title":"Example Usage‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#example-usage","content":" use Rekalogika\\Contracts\\Rekapager\\PageableInterface; /** @var PageableInterface $pageable */ // Getting the first page $firstPage = $pageable-&gt;getFirstPage(); // Getting the last page. Some pageable does not support seeking to the last // page, and will return null. $lastPage = $pageable-&gt;getLastPage(); // Getting the second page, or the page after the first page $secondPage = $firstPage-&gt;getNextPage(); // Getting three pages after the first page $nextPages = $firstPage-&gt;getNextPages(3); // All pages are instances of PageInterface. // Every page has an identifier object, which we can use to get the page later. $pageIdentifier = $secondPage-&gt;getIdentifier(); // Getting a page by its identifier $alsoSecondPage = $pageable-&gt;getPageByIdentifier($pageIdentifier);   ","version":"Next","tagName":"h2"},{"title":"Page Identifiers‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#page-identifiers","content":" Every page has an identifier object, that can be used to get the page later. The class of this identifier object is determined by the implementation of thePageableInterface. Keyset pagination uses the KeysetPageIdentifier class, while offset pagination uses the PageNumber class.  Each of these page identifier classes is accompanied by aPageIdentifierEncoderInterface which is used to encode and decode the identifier object from and to a string. This string is used as query string parameter in the URL.  The PageNumber object is encoded as a simple integer.  The rekapager/rekapager-keyset-pagination package ships with two encoders:  SerializeSecretKeysetPageIdentifierEncoder which uses PHP's serialize() andunserialize() functions. It is protected by checksums to prevent tampering.SymfonySerializerKeysetPageIdentifierEncoder which uses Symfony'sSerializer component to serialize and unserialize the object.  Our Symfony integration uses the latter encoder. ","version":"Next","tagName":"h2"},{"title":"Symfony Integration","type":0,"sectionRef":"#","url":"/rekapager/symfony","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/symfony#installation","content":" Preinstallation checklists:  Make sure Composer is installed globally, as explained in the installation chapter of the Composer documentation. Run composer about to verify.Make sure your project has Symfony Flex installed and enabled (it is enabled by default). Run composer why symfony/flex to verify.  Open a command console, enter your project directory, and execute:  composer require rekalogika/rekapager-bundle   ","version":"Next","tagName":"h2"},{"title":"Transforming a Pageable into a Pager‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/symfony#transforming-a-pageable-into-a-pager","content":" Before we can render a pagination control in the UI, we need to transform thePageableInterface into a PagerInterface object. To do that, wire thePagerFactoryInterface service, and use the createPager() method.  Example with a Symfony Controller:  use Rekalogika\\Rekapager\\Bundle\\Contracts\\PagerFactoryInterface; use Rekalogika\\Rekapager\\Bundle\\PagerOptions; use Symfony\\Component\\HttpFoundation\\Request; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; class MyController extends AbstractController { public function index( PagerFactoryInterface $pagerFactory, Request $request ): Response { $pageable = ...; // Create a PageableInterface object $pager = $pagerFactory-&gt;createPager( pageable: $pageable, request: $request, options: new PagerOptions( proximity: 3, ) ); return $this-&gt;render('my_template.html.twig', [ 'pager' =&gt; $pager, ]); } }   Available options:  pageParameterName: The query string parameter name for the page number. The default is page.proximity: The number of pages to show before and after the current page. The default is 2.routeName: The route name to generate the URL. The default is the current route.routeParameters: The route parameters. The default is the current route parameters.urlReferenceType: The type of URL reference, seeUrlGeneratorInterface::generate() for more information. The default isUrlGeneratorInterface::ABSOLUTE_PATH.itemsPerPage: The number of items per page. The default is 50.pageLimit: The maximum number of pages to show in the pagination control. The default is the effective value in the pageable object.  ","version":"Next","tagName":"h2"},{"title":"Rendering the Pager‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/symfony#rendering-the-pager","content":" In Twig template, you can use the rekapager() function to render the pager.  {# Outputs the item from the current page #} &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Date&lt;/th&gt; &lt;th&gt;Content&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; {# Optionally enables infinite scrolling #} &lt;tbody {{ rekapager_infinite_scrolling_content() }}&gt; {% for post in pager.currentPage %} &lt;tr&gt; &lt;td&gt;{{ post.id }}&lt;/td&gt; &lt;td&gt;{{ post.title }}&lt;/td&gt; &lt;td&gt;{{ post.date|date('Y-m-d') }}&lt;/td&gt; &lt;td&gt;{{ post.content }}&lt;/td&gt; &lt;/tr&gt; {% endfor %} &lt;/tbody&gt; &lt;/table&gt; {# Render the pager #} {{ rekapager(pager, template=&quot;@RekalogikaRekapager/bootstrap5.html.twig&quot;) }}   Available options:  template: The template to use for rendering the pager. The default is@RekalogikaRekapager/default.html.twig.proximity: Override the number of pages to show before and after the current page.locale: Override the current locale for translations.  All options are optional.  tip Wants to see the pager in your language? Feel free to submit your translation.  List of currently available templates:  @RekalogikaRekapager/default.html.twig@RekalogikaRekapager/bootstrap5.html.twig  ","version":"Next","tagName":"h2"},{"title":"Infinite Scrolling‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/symfony#infinite-scrolling","content":" Because infinite scrolling is such a common feature in modern web applications, we provide a helper function to enable it. To enable infinite scrolling, simply add {{ rekapager_infinite_scrolling_content() }} to the element that contains the items; if you are using a table, it should be the tbody element.  Infinite scrolling will be activated if the width of the page is less than 768px (equivalent to Bootstrap's xs and sm breakpoints) when the page is loaded. It will find the pagination element (.pagination), take note of the next page URL (from [rel=&quot;next&quot;]), and remove the pagination element.  When the user scrolls to the bottom of the page, it will fetch the next page, parse the document, get the new items, and appends them to the same element in the current page.  ","version":"Next","tagName":"h2"},{"title":"Default Options‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/symfony#default-options","content":" The global defaults can be set in the bundle configuration file.  config/packages/rekapager.yaml rekalogika_rekapager: default_template: '@RekalogikaRekapager/default.html.twig' default_page_parameter_name: page default_proximity: 2  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/rekapager/intro","content":"","keywords":"","version":"Next"},{"title":"Keyset Pagination (or Cursor-Based Pagination)‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#keyset-pagination-or-cursor-based-pagination","content":" Keyset pagination is a method of pagination that uses the last row of the current page as an anchor for the next page. This method has these advantages compared to the traditional offset-based pagination:  It is more efficient because it leverages the index. It does not require the database to scan all rows from the beginning to reach the desired page.It is more resilient to data changes. The data will not drift when rows are inserted or deleted.  ","version":"Next","tagName":"h2"},{"title":"Identifying Pages‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#identifying-pages","content":" Instead of using page numbers, a page identifier object is used to reference a page. This identifier is encoded into a string and passed as a single query parameter.  Because it requires only a single query parameter, it works similarly on the surface with offset pagination. Migrating from offset pagination to keyset pagination will be straightforward. The difference is that instead of having page numbers in the URL, we'll be getting an 'ugly' identifier, which is opaque to the user, but meaningful to the application.  It also easily allows us to keep the pagination job separate from the filtering and sorting logic. The library does not require a specific way to filter or sort your data.  ","version":"Next","tagName":"h3"},{"title":"Queries‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#queries","content":" This library supports queries with multiple sort columns.  The required query for performing keyset pagination is complex, especially if more than one column is used for sorting. This library handles that task automatically. The only requirement is that the query needs to have a deterministic sort order.  ","version":"Next","tagName":"h3"},{"title":"Bidirectional Navigation and Page Skipping‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#bidirectional-navigation-and-page-skipping","content":" Bidirectional navigation is supported. The user will be able to navigate forward and backward from the current page. It also supports offset seeking, allowing the user to skip the immediate next or previous page up to the configured proximity setting.  In the user interface, the pager will look like a regular pagination control:    The page number is informational only, and carried over from the start page.  ","version":"Next","tagName":"h3"},{"title":"Jumping to the Last Page‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#jumping-to-the-last-page","content":" Seeking to the last page is possible. And with keyset pagination, it will be as fast as seeking to the first page:    ","version":"Next","tagName":"h3"},{"title":"Page Numbers and Counting‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#page-numbers-and-counting","content":" Negative page numbers shown above indicate the page numbers from the end. The last page is -1, the second to last is -2, and so on. It is done this way because by default the pager does not fetch the total count from the underlying data, which is another common performance issue involving pagination.  The pager can work without knowing the total count, but if the count is available, the pager will use it:    It can query the count from the underlying data, or the caller can supply the count. The count can also be an approximation, and the pager will work without an exact count.  ","version":"Next","tagName":"h3"},{"title":"Offset Pagination‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#offset-pagination","content":" The library also supports the traditional offset pagination method with several important improvements. First, it can paginate without the total count of the data. If the count is not available, the pager won't allow the user to navigate to the last page:    It also limits the maximum page number that can be navigated to. By default, the limit is 100. The UI will indicate that the disabled page exists, but the user is not allowed to navigate to it:    ","version":"Next","tagName":"h2"},{"title":"Secure by Default‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#secure-by-default","content":" By not counting by default, and limiting pages in offset pagination, the library is secure by default. It prevents denials of service, either maliciously or accidentally. In most cases, a real user won't have a good reason for accessing page 56267264, but doing so can cause a denial of service to the web server, application, and the database.  ","version":"Next","tagName":"h3"},{"title":"Pagerfanta Interoperability‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#pagerfanta-interoperability","content":" For interoperability, the library supports offset pagination using any of the existing Pagerfanta adapters, as well as adapting a Pagerfanta instance into anOffsetPageableInterface instance.  ","version":"Next","tagName":"h3"},{"title":"Supported Underlying Data Types‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#supported-underlying-data-types","content":" Doctrine ORM QueryBuilderDoctrine Collections Selectable and CollectionPagerfanta adapters  ","version":"Next","tagName":"h2"},{"title":"Framework Integrations‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#framework-integrations","content":" SymfonyAPI Platform  ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#usage","content":" ","version":"Next","tagName":"h2"},{"title":"Transforming the underlying data into a PageableInterface object‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#transforming-the-underlying-data-into-a-pageableinterface-object","content":" This part is framework-independent.  use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\EntityRepository; use Rekalogika\\Rekapager\\Doctrine\\ORM\\QueryBuilderAdapter; use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; // The underlying data in this example is a Doctrine ORM QueryBuilder /** @var EntityRepository $postRepository */ $queryBuilder = $postRepository -&gt;createQueryBuilder('p') -&gt;where('p.group = :group') -&gt;setParameter('group', $group) -&gt;addOrderBy('p.date', 'DESC') -&gt;addOrderBy('p.title', 'ASC') -&gt;addOrderBy('p.id', 'ASC'); // The adapter provides an uniform interface for the different types of // underlying data collection $adapter = new QueryBuilderAdapter( queryBuilder: $queryBuilder, typeMapping: [ 'p.date' =&gt; Types::DATE_MUTABLE ] ), // A pageable represents something that can be partitioned into pages. This // example uses KeysetPageable, which is a pageable that supports keyset // pagination. $pageable = new KeysetPageable( adapter: $adapter, itemsPerPage: $itemsPerPage, count: $count, );   ","version":"Next","tagName":"h3"},{"title":"Transforming the PageableInterface into a PagerInterface object‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#transforming-the-pageableinterface-into-a-pagerinterface-object","content":" In this phase, we start involving the framework used in the application. The example below uses Symfony integration provided byrekalogika/rekapager-bundle.  use Rekalogika\\Rekapager\\Bundle\\Contracts\\PagerFactoryInterface; use Symfony\\Component\\HttpFoundation\\Request; /** @var PagerFactoryInterface $pagerFactory */ /** @var Request $request */ // The pager factory is a service that creates a PagerInterface from a // PageableInterface $pager = $pagerFactory-&gt;createFromPageable( pageable: $pageable, request: $request, options: new PagerOptions( proximity: 3, ) ); $currentPage = $pager-&gt;getCurrentPage(); foreach ($currentPage as $item) { // Do something with the item }   ","version":"Next","tagName":"h3"},{"title":"Rendering the Pager‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#rendering-the-pager","content":" The PagerInterface object contains all the necessary information to render the pagination control in the user interface. The example below uses the Twig integration provided by rekalogika/rekapager-bundle.  {# Outputs the item from the current page #} &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Date&lt;/th&gt; &lt;th&gt;Content&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody {{ rekapager_infinite_scrolling_content() }}&gt; {% for post in pager.currentPage %} &lt;tr&gt; &lt;td&gt;{{ post.id }}&lt;/td&gt; &lt;td&gt;{{ post.title }}&lt;/td&gt; &lt;td&gt;{{ post.date|date('Y-m-d') }}&lt;/td&gt; &lt;td&gt;{{ post.content }}&lt;/td&gt; &lt;/tr&gt; {% endfor %} &lt;/tbody&gt; &lt;/table&gt; {# Render the pager #} {{ rekapager(pager) }}   ","version":"Next","tagName":"h3"},{"title":"Batch Processing‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#batch-processing","content":" A PageableInterface object can also be used for batch processing a large amount of underlying data. The example below demonstrates how to do batch processing using Doctrine.  use Doctrine\\ORM\\EntityManagerInterface; use Rekalogika\\Rekapager\\PageableInterface; /** @var PageableInterface $pageable */ /** @var EntityManagerInterface $entityManager */ foreach ($pageable-&gt;withItemsPerPage(1000)-&gt;getPages() as $page) { foreach ($page as $item) { // Do something with the item } // Do something after each page here $entityManager-&gt;flush(); // if required $entitymanager-&gt;clear(); }   ","version":"Next","tagName":"h2"},{"title":"Demo‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#demo","content":" You can try the demo by running the following command:  docker run --rm -p 8187:80 ghcr.io/rekalogika/rekapager:main   Then access the demo at http://localhost:8187.  ","version":"Next","tagName":"h2"},{"title":"Acknowledgements‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#acknowledgements","content":" Use the Index, LukePagerfantaPagerWavefast-doctrine-paginator  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#contributing","content":" This framework consists of multiple repositories split from a monorepo. Be sure to submit issues and pull requests to therekalogika/rekapager monorepo. ","version":"Next","tagName":"h2"},{"title":"rekalogika/temporary-url-bundle","type":0,"sectionRef":"#","url":"/temporary-url-bundle","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony Flex Open a command console, enter your project directory, and execute: composer config extra.symfony.allow-contrib true composer require rekalogika/temporary-url-bundle   If you're using WebpackEncore, install your assets and restart Encore (not needed if you're using AssetMapper):  YarnNPM yarn install --force yarn watch   ","version":"Next","tagName":"h2"},{"title":"Creating a Resource Class‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#creating-a-resource-class","content":" Create a class that describes your resource. There is no particular requirement for this class, except that it must be serializable.  class MyData { public function __construct(private string $name) { } public function getName(): string { return $this-&gt;name; } }   Protip You can reuse your existing event, message, DTO, value objects, or other similar classes for this purpose.  ","version":"Next","tagName":"h2"},{"title":"Creating a Resource Server‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#creating-a-resource-server","content":" Then create a server class or method that transforms the resource into an HTTP response. Use the AsTemporaryUrlServer attribute to mark the method as a temporary URL server. If the attribute is attached to the class, then the method is assumed to be __invoke(). The method must accept the resource as its first argument, and return a Response object.  use Rekalogika\\TemporaryUrl\\Attribute\\AsTemporaryUrlServer; use Symfony\\Component\\HttpFoundation\\Response; class MyDataServer { #[AsTemporaryUrlServer] public function respond(MyData $data): Response { return new Response('My name is ' . $data-&gt;getName()); } }   ","version":"Next","tagName":"h2"},{"title":"Generating a Temporary URL‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#generating-a-temporary-url","content":" To generate a temporary URL, use the TemporaryUrlGeneratorInterface service.  use Rekalogika\\TemporaryUrl\\TemporaryUrlGeneratorInterface; /** @var TemporaryUrlGeneratorInterface $temporaryUrlGenerator */ $resource = new MyData('123'); $url = $temporaryUrlGenerator-&gt;generateUrl($resource);   The TemporaryUrlGeneratorInterface::generateUrl() offers additional options:  $ttl (int or DateInterval): The time-to-live of the URL. Defaults to 30 minutes.$pinSession (bool): Whether to pin the URL to the session. Pinned URLs can only be accessed by the same user that generated them. Defaults to false.$referenceType (int): The type of reference to be generated (one of theUrlGeneratorInterface::ABSOLUTE_* constants). Defaults toUrlGeneratorInterface::ABSOLUTE_PATH.  ","version":"Next","tagName":"h2"},{"title":"In Twig Templates‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#in-twig-templates","content":" In a Twig template, you can use the filter temporary_url to generate a temporary URL. Use the function temporary_url_autoexpire on links to make them unclickable after the URL expires.  {# my_data here is a resource object #} &lt;a href=&quot;{{ my_data|temporary_url }}&quot; {{ temporary_url_autoexpire() }}&gt; Click here to download my data &lt;/a&gt;   The filter accepts the same options as the generateUrl() method above.  ","version":"Next","tagName":"h2"},{"title":"Dealing With Unserializable Resources‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#dealing-with-unserializable-resources","content":" If your resource is not serializable, you can create a resource transformer method that converts your resource into an intermediate serializable object.  use Rekalogika\\TemporaryUrl\\Attribute\\AsTemporaryUrlResourceTransformer; use Rekalogika\\TemporaryUrl\\Attribute\\AsTemporaryUrlServer; use Symfony\\Component\\HttpFoundation\\Response; class MyDataServer { /** * This method transforms the resource into a serializable object. */ #[AsTemporaryUrlResourceTransformer] public function transform(MyUnserializableData $data): MySerializableData { return new MySerializableData($data); } ./** * This uses the transformed data and send it to the client. */ #[AsTemporaryUrlServer] public function respond(MySerializableData $data): Response { return new Response('My name is ' . $data-&gt;getName()); } }   Using the above example, you will be able to generate a temporary URL toMyUnserializableData. The framework will automatically transformMyUnserializableData to MySerializableData behind the scenes.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#contributing","content":" Issues and pull requests should be filed in the GitHub repositoryrekalogika/temporary-url-bundle. ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}