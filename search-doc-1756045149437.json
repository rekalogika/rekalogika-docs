{"searchDocs":[{"title":"Aggregate Functions","type":0,"sectionRef":"#","url":"/analytics/aggregate-function","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"Aggregate Functions","url":"/analytics/aggregate-function#sections","content":" üìÑÔ∏è Count, Sum, Max, Min These are self-decomposable aggregation functions, which are the simplest form üìÑÔ∏è Average Average calculates the average value of a specified property. It requires üìÑÔ∏è Count Distinct Count Distinct is an aggregate function that counts the number of distinct üìÑÔ∏è Standard Deviation StdDev is an aggregate function that calculates the standard deviation of a üìÑÔ∏è To-Many Joins Are Not Yet Supported While our property paths fully supports one-to-many and many-to-many joins, it üìÑÔ∏è Creating Aggregate Functions To create an aggregate function, you need to create an implementation of ","version":"Next","tagName":"h2"},{"title":"rekalogika/analytics","type":0,"sectionRef":"#","url":"/analytics","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/analytics","url":"/analytics#sections","content":" üìÑÔ∏è Introduction Creates and maintains pre-aggregated summary tables for Doctrine entities. üìÑÔ∏è Quick Start TBD üóÉÔ∏è Summary Entity 4 items üìÑÔ∏è Housekeeping Maintaining a summary table involves ensuring that the data in the summary table üóÉÔ∏è Queries 3 items üóÉÔ∏è Value Resolvers 4 items üóÉÔ∏è Aggregate Functions 6 items üóÉÔ∏è Dimension Hierarchy 1 item üóÉÔ∏è Time Dimension 2 items üóÉÔ∏è Metadata 1 item üóÉÔ∏è User Interface 5 items üìÑÔ∏è Serialization TBD üóÉÔ∏è Internals 3 items ","version":"Next","tagName":"h2"},{"title":"Count Distinct","type":0,"sectionRef":"#","url":"/analytics/aggregate-function/count-distinct","content":"Count Distinct Count Distinct is an aggregate function that counts the number of distinct values in a specified property. Analytics requires thepostgresql-hll extension to be installed in the database to use this function. Example: use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\PostgreSQLHll\\AggregateFunction\\CountDistinct; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\ValueResolver\\IdentifierValue; class OrderSummary extends Summary implements HasQueryBuilderModifier { #[ORM\\Column(type: 'rekalogika_hll')] #[Analytics\\Measure( function: new CountDistinct(new IdentifierValue('customer')), )] private ?int $uniqueCustomers = null; } warning As with other implementations of Count Distinct in data warehousing and parallel computing, this function uses the Hyperloglog algorithm to return an approximate count of distinct values, not an exact count.","keywords":"","version":"Next"},{"title":"Average","type":0,"sectionRef":"#","url":"/analytics/aggregate-function/average","content":"","keywords":"","version":"Next"},{"title":"Example‚Äã","type":1,"pageTitle":"Average","url":"/analytics/aggregate-function/average#example","content":" use Doctrine\\ORM\\Mapping as ORM; use Doctrine\\ORM\\Types\\Types; use Rekalogika\\Analytics\\Core\\AggregateFunction\\Average; use Rekalogika\\Analytics\\Core\\AggregateFunction\\Count; use Rekalogika\\Analytics\\Core\\AggregateFunction\\Sum; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\Entity\\BaseSummary; use Rekalogika\\Analytics\\Core\\ValueResolver\\PropertyValue; class OrderSummary extends BaseSummary { #[ORM\\Column(type: Types::INTEGER)] #[Analytics\\Measure( function: new Sum(new PropertyValue('item.price'), )] private ?int $price = null; #[ORM\\Column(type: Types::INTEGER)] #[Analytics\\Measure( function: new Count('id'), )] private ?int $count = null; #[Analytics\\Measure( function: new Average( sumProperty: 'price', countProperty: 'count', ), )] private ?int $averageOrderValue = null; }   In this example, the Average function uses the previously defined price andcount measures to compute the average order value. The sumProperty andcountProperty parameters specify which properties to use for the sum and count calculations, respectively.  note It is not necessary to store the average value in the database, and therefore the property does not need the ORM\\Column attribute. ","version":"Next","tagName":"h2"},{"title":"Count, Sum, Max, Min","type":0,"sectionRef":"#","url":"/analytics/aggregate-function/count-sum-max-min","content":"","keywords":"","version":"Next"},{"title":"Example‚Äã","type":1,"pageTitle":"Count, Sum, Max, Min","url":"/analytics/aggregate-function/count-sum-max-min#example","content":" use Doctrine\\ORM\\Mapping as ORM; use Doctrine\\ORM\\Types\\Types; use Rekalogika\\Analytics\\Core\\AggregateFunction\\Count; use Rekalogika\\Analytics\\Core\\AggregateFunction\\Sum; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\Entity\\BaseSummary; use Rekalogika\\Analytics\\Core\\ValueResolver\\PropertyValue; class OrderSummary extends BaseSummary { #[ORM\\Column(type: Types::INTEGER)] #[Analytics\\Measure( function: new Sum(new PropertyValue('item.price'), )] private ?int $price = null; #[ORM\\Column(type: Types::INTEGER)] #[Analytics\\Measure( function: new Count('id'), )] private ?int $count = null; }  ","version":"Next","tagName":"h2"},{"title":"To-Many Joins Are Not Yet Supported","type":0,"sectionRef":"#","url":"/analytics/aggregate-function/to-many-joins","content":"To-Many Joins Are Not Yet Supported While our property paths fully supports one-to-many and many-to-many joins, it requires subqueries in the resulting SQL query. This is not yet supported by Analytics. Doing so right now will result in the wrong results being returned. Specifically, aggregation functions in the source entity will get the same field multiple times, resulting in a higher result than the correct one.","keywords":"","version":"Next"},{"title":"Creating Aggregate Functions","type":0,"sectionRef":"#","url":"/analytics/aggregate-function/creating-aggregate-functions","content":"","keywords":"","version":"Next"},{"title":"Interfaces‚Äã","type":1,"pageTitle":"Creating Aggregate Functions","url":"/analytics/aggregate-function/creating-aggregate-functions#interfaces","content":"   ","version":"Next","tagName":"h2"},{"title":"AggregateFunction Interface‚Äã","type":1,"pageTitle":"Creating Aggregate Functions","url":"/analytics/aggregate-function/creating-aggregate-functions#aggregatefunction-interface","content":" namespace Rekalogika\\Analytics\\Contracts\\Summary; use Rekalogika\\Analytics\\Contracts\\Context\\SummaryQueryContext; interface AggregateFunction { public function getAggregateToResultExpression( string $inputExpression, SummaryQueryContext $context, ): string; }   Implement AggregateFunction if the function does not read any data from the source directly, but gets its input from other aggregate functions. Example: theAverage aggregate function, it takes the sum and count from other aggregate functions and uses them to calculate the average.  ","version":"Next","tagName":"h3"},{"title":"SummarizableAggregateFunction Interface‚Äã","type":1,"pageTitle":"Creating Aggregate Functions","url":"/analytics/aggregate-function/creating-aggregate-functions#summarizableaggregatefunction-interface","content":" namespace Rekalogika\\Analytics\\Contracts\\Summary; use Rekalogika\\Analytics\\Contracts\\Context\\SourceQueryContext; interface SummarizableAggregateFunction extends AggregateFunction { public function getSourceToAggregateExpression( SourceQueryContext $context, ): string; public function getAggregateToAggregateExpression( string $inputExpression, ): string; /** * @return list&lt;string&gt; */ public function getInvolvedProperties(): array; }   Implement SummarizableAggregateFunction if the function reads data from the source entity. You need to supply these logics using DQL expressions:  getSourceToAggregateExpression() - How to transform a field from multiple source entities into a single aggregate value.getAggregateToAggregateExpression() - How to combine multiple aggregate values into a single aggregate value.getAggregateToResultExpression() - How to transform an aggregate value into the final result value.  ","version":"Next","tagName":"h3"},{"title":"Division Consideration‚Äã","type":1,"pageTitle":"Creating Aggregate Functions","url":"/analytics/aggregate-function/creating-aggregate-functions#division-consideration","content":" When creating an aggregate function that involves division, you should consider the case when the denominator is zero. To avoid division by zero, use the DQL expression NULLIF(&lt;denominator&gt;, 0). This will return NULL if the denominator is zero, which is a safe way to handle division in DQL.  ","version":"Next","tagName":"h2"},{"title":"User Value Transformer‚Äã","type":1,"pageTitle":"Creating Aggregate Functions","url":"/analytics/aggregate-function/creating-aggregate-functions#user-value-transformer","content":" The aggregate function can provide a way to transform the raw result value (as returned by Doctrine) into a user-friendly object. This is done by implementing the UserValueTransformer interface. The following is an example done for theCountDistinct aggregate function.  use Rekalogika\\Analytics\\Contracts\\Context\\ValueTransformerContext; use Rekalogika\\Analytics\\Contracts\\Summary\\SummarizableAggregateFunction; use Rekalogika\\Analytics\\Contracts\\Summary\\UserValueTransformer; /** * @implements UserValueTransformer&lt;int,ApproximateCount&gt; */ final readonly class CountDistinct implements SummarizableAggregateFunction, UserValueTransformer { // ... #[\\Override] public function getUserValue( mixed $rawValue, ValueTransformerContext $context, ): mixed { if ($rawValue === null) { return null; } return new ApproximateCount($rawValue); } }   Then in the summary class, the user will be able to do something like this:  use Doctrine\\ORM\\Mapping as ORM; use Doctrine\\ORM\\Types\\Types; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\Entity\\BaseSummary; #[ORM\\Entity()] #[Analytics\\Summary( sourceClass: Order::class, )] class OrderSummary extends BaseSummary { #[ORM\\Column(type: 'rekalogika_hll')] #[Analytics\\Measure( function: new CountDistinct(new IdentifierValue('customer')), )] private ?int $uniqueCustomers = null; public function getUniqueCustomers(): ?ApproximateCount { return $this-&gt;getContext()-&gt;getUserValue( property: 'uniqueCustomers', class: ApproximateCount::class, ); } }  ","version":"Next","tagName":"h2"},{"title":"Dimension Hierarchy","type":0,"sectionRef":"#","url":"/analytics/dimension-hierarchy","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"Dimension Hierarchy","url":"/analytics/dimension-hierarchy#sections","content":" üìÑÔ∏è Structure TBD ","version":"Next","tagName":"h2"},{"title":"Standard Deviation","type":0,"sectionRef":"#","url":"/analytics/aggregate-function/standard-deviation","content":"","keywords":"","version":"Next"},{"title":"Example‚Äã","type":1,"pageTitle":"Standard Deviation","url":"/analytics/aggregate-function/standard-deviation#example","content":" use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\Core\\AggregateFunction\\Count; use Rekalogika\\Analytics\\Core\\AggregateFunction\\StdDev; use Rekalogika\\Analytics\\Core\\AggregateFunction\\Sum; use Rekalogika\\Analytics\\Core\\AggregateFunction\\SumSquare; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; class OrderSummary extends Summary { #[ORM\\Column(type: Types::INTEGER)] #[Analytics\\Measure( function: new Sum('item.price'), )] private ?int $price = null; #[ORM\\Column(type: Types::FLOAT)] #[Analytics\\Measure( function: new SumSquare('item.price'), hidden: true, )] private ?float $priceSumSquare = null; #[ORM\\Column(type: Types::INTEGER)] #[Analytics\\Measure( function: new Count('id'), )] private ?int $count = null; #[Analytics\\Measure( function: new StdDev( sumSquareProperty: 'priceSumSquare', countProperty: 'count', sumProperty: 'price', ), )] private ?int $priceStdDev = null; }   note It is not necessary to store the standard deviation value in the database, and therefore the property does not need the ORM\\Column attribute.  ","version":"Next","tagName":"h2"},{"title":"SumSquare Function‚Äã","type":1,"pageTitle":"Standard Deviation","url":"/analytics/aggregate-function/standard-deviation#sumsquare-function","content":" The SumSquare function is used to calculate the sum of the squares of the specified property values. It is a building block for many statistical functions, including StdDev. However, the end users are probably not interested in the result of the SumSquare function itself, and you can hide it from the UI by using the hidden parameter in the Measure attribute like in the example above. ","version":"Next","tagName":"h2"},{"title":"Structure","type":0,"sectionRef":"#","url":"/analytics/dimension-hierarchy/structure","content":"Structure TBD","keywords":"","version":"Next"},{"title":"Internals","type":0,"sectionRef":"#","url":"/analytics/internals","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"Internals","url":"/analytics/internals#sections","content":" üìÑÔ∏è Partitioning Why? üìÑÔ∏è Refresh Mechanism DirtyFlag üìÑÔ∏è Current To-do List Bugs ","version":"Next","tagName":"h2"},{"title":"Housekeeping","type":0,"sectionRef":"#","url":"/analytics/housekeeping","content":"","keywords":"","version":"Next"},{"title":"Refreshing Manually from the Command Line‚Äã","type":1,"pageTitle":"Housekeeping","url":"/analytics/housekeeping#refreshing-manually-from-the-command-line","content":" You can refresh the summary table manually from the command line. Usually you would do this once after the summary table is created.  php bin/console rekalogika:analytics:refresh 'App\\Entity\\SomeSummary' \\ [start key [end key]]   Optional arguments:  start key is the start key for the range of entities to refresh. This is the partitioning key as described in thepartitioning documentation.end key is the end key that marks the end of the range of entities to refresh.  Optional options:  --resume=&lt;resume ID&gt;. If you interrupt the refresh process usingCtrl-C, it will tell you the resume ID. You can use this option to resume the refresh process from where it left off. Note that you need to make sure the rest of the arguments and options are the same as when you started the refresh process, otherwise the resume won't work.--batch-size=&lt;batch size&gt;. The number of partitions to refresh in a single roll up query. The default is 1. Increasing this may speed up or slow down the refresh process. ","version":"Next","tagName":"h2"},{"title":"Refresh Mechanism","type":0,"sectionRef":"#","url":"/analytics/internals/refresh","content":"","keywords":"","version":"Next"},{"title":"DirtyFlag‚Äã","type":1,"pageTitle":"Refresh Mechanism","url":"/analytics/internals/refresh#dirtyflag","content":" A DirtyFlag is an entity indicating a dirty partition, which is a partition in a summary table that needs to be refreshed. DirtyFlag should be persisted and flushed at the same time as the rest of the entities, during the onFlushevent. So if the flush fails, the flag will not be saved.  A DirtyFlag can have null partition information. In this case, it means there are new persisted entities that need to be summarized. New entities need to be handled differently because they are not guaranteed to have an ID before flush.  ","version":"Next","tagName":"h2"},{"title":"SourceEntityListener‚Äã","type":1,"pageTitle":"Refresh Mechanism","url":"/analytics/internals/refresh#sourceentitylistener","content":" Listens on Doctrine's onFlush event. For every pending entities, it checks the change set and determines if the change affects any summary tables. If a property is changed, and that would affect one or more summary tables, it creates the corresponding DirtyFlag objects for each of the partition that needs to be refreshed.  warning This automatic detection works only for simple cases: it only detects the change of the properties in the entity itself. If the change that would affect the summary is in a related entity, the framework cannot detect that.  At the end of a flush, the listener will dispatch a NewDirtyFlagEvent event for each of the created DirtyFlag objects, and also a DirtySummaryEventfor each of the summary tables that need to be refreshed.  ","version":"Next","tagName":"h2"},{"title":"DirtySummaryEventListener‚Äã","type":1,"pageTitle":"Refresh Mechanism","url":"/analytics/internals/refresh#dirtysummaryeventlistener","content":" Listens on the DirtySummaryEvent event. It callsRefreshAgentRunner::refresh() to run the refresh agent for the summary table, if one is not already running. ","version":"Next","tagName":"h2"},{"title":"Partitioning","type":0,"sectionRef":"#","url":"/analytics/internals/partitioning","content":"","keywords":"","version":"Next"},{"title":"Why?‚Äã","type":1,"pageTitle":"Partitioning","url":"/analytics/internals/partitioning#why","content":" Partitioning lets the framework update the summary table incrementally. Without partitioning, processing a source table with billions of records might probably take days or even weeks to finish.  Because an RDBMS is ACID compliant, it will also need to store both old and new records of the source table while the processing is ongoing, which will take up a lot of space and may cause fragmentation.  ","version":"Next","tagName":"h2"},{"title":"How It Works‚Äã","type":1,"pageTitle":"Partitioning","url":"/analytics/internals/partitioning#how-it-works","content":" The following table shows how the records are partitioned using the hypotheticalIntegerPartition with 1-2-3-4-5-6 bits of partitioning width. The leftmost column indicates the level. Other cells are the partitions of that level. Numbers in the cells indicate the partitioning key range that are rolled-up in the partition.  L6\t0-63 L5\t0-31\t32-63 L4\t0-15\t16-31\t32-47\t48-63 L3\t0-7\t8-15\t16-23\t24-31\t32-39\t40-47\t48-55\t56-63 L2\t0-3\t4-7\t8-11\t12-15\t16-19\t20-23\t24-27\t28-31\t32-35\t36-39\t40-43\t44-47\t48-51\t52-55\t56-59\t60-63 L1\t0-1\t2-3\t4-5\t6-7\t8-9\t10-11\t12-13\t14-15\t16-17\t18-19\t20-21\t22-23\t24-25\t26-27\t28-29\t30-31\t32-33\t34-35\t36-37\t38-39\t40-41\t42-43\t44-45\t46-47\t48-49\t50-51\t52-53\t54-55\t56-57\t58-59\t60-61\t62-63  ","version":"Next","tagName":"h2"},{"title":"Example of Partitioning‚Äã","type":1,"pageTitle":"Partitioning","url":"/analytics/internals/partitioning#example-of-partitioning","content":" With the above partitioning scheme above, now suppose our source entity has the following records:  ID\tValue8\t2 9\t3 10\t6 11\t7 12\t10 13\t5 14\t4 15\t1  The framework will roll up those records into the following level 1 partitions:  Level\tKey\tSum of ValueL1\t8\t5 L1\t10\t13 L1\t12\t15 L1\t14\t5  Then, in turn those level 1 partitions will be rolled up into level 2 partitions:  Level\tKey\tSum of ValueL2\t8\t18 L2\t12\t20  Then, again, those level 2 partitions will be rolled up into level 3 partitions:  Level\tKey\tSum of ValueL3\t8\t38  And so forth until we reach the top level.  info In the summary table, a partition is identified by its level and key. With our integer partition, the key is the same as the first possible source ID in the partition.  ","version":"Next","tagName":"h2"},{"title":"Queries‚Äã","type":1,"pageTitle":"Partitioning","url":"/analytics/internals/partitioning#queries","content":" If we currently have 21 records already rolled-up, these are the partition that we will have. If we were to perform a query, the framework will union the records from the highlighted partitions to get the result:  L6 L5 L4\t0-15 L3\t0-7\t8-15 L2\t0-3\t4-7\t8-11\t12-15\t16-19 L1\t0-1\t2-3\t4-5\t6-7\t8-9\t10-11\t12-13\t14-15\t16-17\t18-19\t20-21  ","version":"Next","tagName":"h2"},{"title":"Updates‚Äã","type":1,"pageTitle":"Partitioning","url":"/analytics/internals/partitioning#updates","content":" Now suppose the framework knows that the record #11 has been updated. It will refresh the partition L1 10-11. Afterward, it will refresh its parent partition, which is the partition L2 8-11, and so on until it reaches the top level.  These are the partitions that will get updated when that happens:  L6 L5 L4\t0-15 L3\t0-7\t8-15 L2\t0-3\t4-7\t8-11\t12-15\t16-19 L1\t0-1\t2-3\t4-5\t6-7\t8-9\t10-11\t12-13\t14-15\t16-17\t18-19\t20-21  ","version":"Next","tagName":"h2"},{"title":"In the Real World‚Äã","type":1,"pageTitle":"Partitioning","url":"/analytics/internals/partitioning#in-the-real-world","content":" Having a partitioning scheme with 1-bit width as above is useful for explanation, but will be pretty inefficient. Our default integer partition is using 11-22-33-44-55 bits of partitioning width. This means that the first level contains the data rolled-up from up to 2048 records, the second level contains 4 millions records that are rolled-up from the first level, and so on. ","version":"Next","tagName":"h2"},{"title":"Current To-do List","type":0,"sectionRef":"#","url":"/analytics/internals/todo","content":"","keywords":"","version":"Next"},{"title":"Bugs‚Äã","type":1,"pageTitle":"Current To-do List","url":"/analytics/internals/todo#bugs","content":" Currently none.  ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"Current To-do List","url":"/analytics/internals/todo#features","content":" Support for MS SQL ServerConfigurable event timing (RefreshClassPropertiesResolver)Allow customized generation of dirty flag (see DirtyFlagGenerator)It should be possible for DirtyFlagGenerator to generate dirty partition signals for non-IDENTITY entities, bypassing 'new entity' phase.Binning value resolverSubtotalsFrom a result, create a Collection containing entities from source.Auto-dashboardLower &amp; upper bound limit in queries.  ","version":"Next","tagName":"h2"},{"title":"Performance‚Äã","type":1,"pageTitle":"Current To-do List","url":"/analytics/internals/todo#performance","content":" Metadata caching  ","version":"Next","tagName":"h2"},{"title":"Limitations‚Äã","type":1,"pageTitle":"Current To-do List","url":"/analytics/internals/todo#limitations","content":" Postgres GROUP BY maximum grouping set limit of 4096, can be circumvented by using multiple queries.to-many joins are not yet supported. It can be implemented using subselects in the SELECT clause (not very efficient), or subselects in the LEFT JOIN clause (not supported by Doctrine, needs a custom output walker).  ","version":"Next","tagName":"h2"},{"title":"Spinoffs‚Äã","type":1,"pageTitle":"Current To-do List","url":"/analytics/internals/todo#spinoffs","content":" Spin off pivot table to its own package.Spin off UI to its own package (including DistinctValuesResolver)SimpleQueryBuilder  ","version":"Next","tagName":"h2"},{"title":"Tests‚Äã","type":1,"pageTitle":"Current To-do List","url":"/analytics/internals/todo#tests","content":" Currently too many to list. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/analytics/intro","content":"","keywords":"","version":"Next"},{"title":"Advantages‚Äã","type":1,"pageTitle":"Introduction","url":"/analytics/intro#advantages","content":" Works directly on the entities. Does not use intermediate fact tables. Does not require any additional ETL processes.  Optimized for incremental updates. (TBD explain)  Better logistics. No need to pass data to and from external systems. No need to maintain additional infrastructure.  A simpler and cheaper alternative to modern analytical solutions. Less sophisticated but probably good enough for many use cases.  Sometimes things can be more challenging legally and politically, rather than technically. This framework does not require you to send data to the cloud, so it complies with the 'no-cloud' policy if you happen to be bound by it.  Architecturally sensible if the result of the analytical query will be used as an input of a business process in the same application, as opposed to being used for external reporting purposes only.  Understands Doctrine's metadata, unlike external solutions that work directly with the database. No need to duplicate the knowledge about your database schema between your application and the external analytical system.  Detects if an entity is added, modified, or deleted. It can then automatically update the summary table accordingly. No need to devise a way to signal an external system that the data has changed. Or even to blindly recalculate all data up to 5 years ago periodically, just because you fear some process might have changed records that old, but you can't know for certain.  ","version":"Next","tagName":"h2"},{"title":"Requirements‚Äã","type":1,"pageTitle":"Introduction","url":"/analytics/intro#requirements","content":" Only works with PostgreSQL for now. Only the usage under Symfony is supported for now.  ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Introduction","url":"/analytics/intro#installation","content":" Install the bundle using Composer:  composer require rekalogika/analytics-bundle   Configure Symfony Messenger routing configuration. For example:  config/packages/messenger.yaml framework: messenger: routing: Rekalogika\\Analytics\\Engine\\RefreshAgent\\RefreshAgentStartCommand: async   ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction","url":"/analytics/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/analytics/intro#contributing","content":" This framework consists of multiple repositories split from a monorepo. Be sure to submit issues and pull requests to therekalogika/analytics monorepo. ","version":"Next","tagName":"h2"},{"title":"Metadata","type":0,"sectionRef":"#","url":"/analytics/metadata","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"Metadata","url":"/analytics/metadata#sections","content":" üìÑÔ∏è Summary Metadata Summary Metadata ","version":"Next","tagName":"h2"},{"title":"Summary Metadata","type":0,"sectionRef":"#","url":"/analytics/metadata/summary","content":"Summary Metadata","keywords":"","version":"Next"},{"title":"Queries","type":0,"sectionRef":"#","url":"/analytics/query","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"Queries","url":"/analytics/query#sections","content":" üìÑÔ∏è Querying To work with the summary entities, we interact with the service üìÑÔ∏è Data Cube Result To get the result in the data cube format, call the getCube() method on the üìÑÔ∏è Table Result TBD ","version":"Next","tagName":"h2"},{"title":"Table Result","type":0,"sectionRef":"#","url":"/analytics/query/table-result","content":"Table Result TBD","keywords":"","version":"Next"},{"title":"Serialization","type":0,"sectionRef":"#","url":"/analytics/serialization","content":"Serialization TBD","keywords":"","version":"Next"},{"title":"Querying","type":0,"sectionRef":"#","url":"/analytics/query/querying","content":"","keywords":"","version":"Next"},{"title":"Querying the Summary‚Äã","type":1,"pageTitle":"Querying","url":"/analytics/query/querying#querying-the-summary","content":" You can query the summary entity using the createQuery method. The method returns an instance of Query that you can use to build your query.  use Doctrine\\Common\\Collections\\Criteria; use Rekalogika\\Analytics\\Contracts\\SummaryManager; /** @var SummaryManager $summaryManager */ $result = $summaryManager -&gt;createQuery() -&gt;from(OrderSummary::class) // the summary entity class name -&gt;groupBy('time.year', 'customerCountry') // property names of the dimension -&gt;select('price', 'count') // property names of the measures -&gt;where(Criteria::expr()-&gt;eq('time.year', 2023)) -&gt;getResult();   The result is an instance of Result. It presents the query result in two shapes, for user convenience:  Data cube formatTable format.  ","version":"Next","tagName":"h2"},{"title":"Query Methods‚Äã","type":1,"pageTitle":"Querying","url":"/analytics/query/querying#query-methods","content":" The methods of the Query object are modeled after the Doctrine QueryBuildermethods. The methods are chainable, so you can write the query in a fluent style.  ","version":"Next","tagName":"h2"},{"title":"from‚Äã","type":1,"pageTitle":"Querying","url":"/analytics/query/querying#from","content":" The from method is used to specify the summary entity class that you want to query.  ","version":"Next","tagName":"h3"},{"title":"groupBy and addGroupBy‚Äã","type":1,"pageTitle":"Querying","url":"/analytics/query/querying#groupby-and-addgroupby","content":" The groupBy method is used to specify the dimensions of the query. The dimension name is the same as the property name of your summary class. The order in groupBy is important, and will be used to determine the order of the dimensions in the result.  ","version":"Next","tagName":"h3"},{"title":"select and addSelect‚Äã","type":1,"pageTitle":"Querying","url":"/analytics/query/querying#select-and-addselect","content":" The select method is used to specify the measures of the query. Again, the measure name is the name of the property in the summary class.  ","version":"Next","tagName":"h3"},{"title":"where and andWhere‚Äã","type":1,"pageTitle":"Querying","url":"/analytics/query/querying#where-and-andwhere","content":" The where method is used to filter the data. The method accepts a Doctrine Criteria Expression object.  ","version":"Next","tagName":"h3"},{"title":"The Result Object‚Äã","type":1,"pageTitle":"Querying","url":"/analytics/query/querying#the-result-object","content":" The Result object provides the user with methods to get the data in the user's preferred format.  use Rekalogika\\Analytics\\Contracts\\Result\\Result; /** @var Result $result */ // Get the result in the data cube format $tree = $result-&gt;getCube(); // Get the result in the table format $table = $result-&gt;getTable();  ","version":"Next","tagName":"h2"},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/analytics/quickstart","content":"Quick Start TBD","keywords":"","version":"Next"},{"title":"Summary Entity","type":0,"sectionRef":"#","url":"/analytics/summary-entity","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"Summary Entity","url":"/analytics/summary-entity#sections","content":" üìÑÔ∏è Summary Class A summary entity is an entity that contains pre-aggregated data from the source üìÑÔ∏è Partitioning For performance and to facilitate incremental updates, the summary table is üìÑÔ∏è Dimensions A summary table can have one or more dimensions. Dimensions are properties of üìÑÔ∏è Measures Measures are quantitative values that are aggregated in a summary table. In SQL, ","version":"Next","tagName":"h2"},{"title":"Data Cube Result","type":0,"sectionRef":"#","url":"/analytics/query/cube-result","content":"","keywords":"","version":"Next"},{"title":"Class Diagram‚Äã","type":1,"pageTitle":"Data Cube Result","url":"/analytics/query/cube-result#class-diagram","content":"   ","version":"Next","tagName":"h2"},{"title":"Definition‚Äã","type":1,"pageTitle":"Data Cube Result","url":"/analytics/query/cube-result#definition","content":" A CubeCell contains a tuple and measures. A tuple is a collection of dimensions, each of which is a property of the summary entity. Measures are the properties that represent the aggregated values, such as count, price.  Example: A CubeCell may contain a tuple with dimensions like:  time.year = 2023country = DEcategory = electronics  In such a CubeCell, the measures might contain values of:  count = 20price = 1000.00  It means that in the year 2023, there were 20 orders from Germany in the electronics category, with a total price of 1000.00.  info The dimensions in the tuple are not in a particular order. The order of dimensions in the tuple does not matter.  ","version":"Next","tagName":"h2"},{"title":"Example Query‚Äã","type":1,"pageTitle":"Data Cube Result","url":"/analytics/query/cube-result#example-query","content":" use Doctrine\\Common\\Collections\\Criteria; use Rekalogika\\Analytics\\Contracts\\SummaryManager; /** @var SummaryManager $summaryManager */ $apexCube = $summaryManager -&gt;createQuery() -&gt;from(OrderSummary::class) // the summary entity class name -&gt;groupBy('time.year', 'country', 'category') // dimensions -&gt;select('price', 'count') // measures -&gt;getResult() -&gt;getCube();   The getCube() method of the query result returns the apex CubeCell that aggregates the entire data cube. The apex CubeCell has no dimensions in its tuple. You can then drill down or slice to get more specific cube cells.  ","version":"Next","tagName":"h2"},{"title":"drillDown() method‚Äã","type":1,"pageTitle":"Data Cube Result","url":"/analytics/query/cube-result#drilldown-method","content":" The drillDown() method allows you to drill down into a specific dimension. It adds a new dimension to the tuple and returns all the possible CubeCell, each with a unique value for the specified dimension.  use Rekalogika\\Analytics\\Contracts\\Result\\CubeCell; /** @var CubeCell $year2025 */ $year2025Count = $year2025-&gt;getMeasures()-&gt;get('count')-&gt;getValue(); // e.g. 20 $year2025InCountries = $year2025-&gt;drillDown('customerCountry'); $totalCount = 0; foreach ($year2025InCountries as $year2025InACountry) { $totalCount += $year2025InACountry-&gt;getMeasures()-&gt;get('count')-&gt;getValue(); } assert($totalCount === $year2025Count);   In the above example, if the $year2025Cube contains the number 20 as the count value, the $year2025InCountries might contain several CubeCell objects, each having a different country, such as DE, US, and FR, with their count values adding to exactly 20.    ","version":"Next","tagName":"h2"},{"title":"rollUp() method‚Äã","type":1,"pageTitle":"Data Cube Result","url":"/analytics/query/cube-result#rollup-method","content":" The rollUp() method is the reverse of drillDown(). It allows you to roll up the data cube to a higher level of aggregation. It returns the CubeCell that represents the rolled-up data. rollUp() basically removes the specified dimension from the tuple and aggregates the measures accordingly.  use Rekalogika\\Analytics\\Contracts\\Result\\CubeCell; /** @var CubeCell $year2025InGermany */ $germany = $year2025InGermany-&gt;rollUp('time.year');     ","version":"Next","tagName":"h2"},{"title":"slice() method‚Äã","type":1,"pageTitle":"Data Cube Result","url":"/analytics/query/cube-result#slice-method","content":" The slice() method allows you to slice the data cube by a specific dimension and member. It adds a new dimension to the tuple and returns the correspondingCubeCell.  use Rekalogika\\Analytics\\Contracts\\Result\\CubeCell; /** @var CubeCell $year2025 */ /** @var Country $france */ $year2025InFrance = $year2025-&gt;slice('country', $france);     ","version":"Next","tagName":"h2"},{"title":"fuzzySlice() method‚Äã","type":1,"pageTitle":"Data Cube Result","url":"/analytics/query/cube-result#fuzzyslice-method","content":" fuzzySlice() is similar to slice(), but it matches the value using a &quot;fuzzy&quot;, non-exact comparison.  use Rekalogika\\Analytics\\Contracts\\Result\\CubeCell; /** @var CubeCell $year2025 */ $year2025InFrance = $year2025-&gt;fuzzySlice('country', 'fr');   In the above example, the entity Country has its __toString() method defined to return the country code. Therefore, the fuzzySlice() method will match the value 'fr' to the Country entity representing France. ","version":"Next","tagName":"h2"},{"title":"Partitioning","type":0,"sectionRef":"#","url":"/analytics/summary-entity/partitioning","content":"","keywords":"","version":"Next"},{"title":"Best Practices, or TLDR;‚Äã","type":1,"pageTitle":"Partitioning","url":"/analytics/summary-entity/partitioning#best-practices-or-tldr","content":" If the source entity uses an auto-incrementing integer primary key, use this partitioning scheme:  use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\Entity\\BaseSummary; use Rekalogika\\Analytics\\Partition\\DefaultIntegerPartition; use Rekalogika\\Analytics\\Core\\ValueResolver\\PropertyValue; class YourSummary extends BaseSummary { #[ORM\\Embedded()] #[Analytics\\Partition(new PropertyValue('id'))] private DefaultIntegerPartition $partition; }   If your source entity uses UUIDv7 (or ULID) as the primary key, use this partitioning scheme:  use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\Partition\\UuidV7IntegerPartition; use Rekalogika\\Analytics\\Core\\Entity\\BaseSummary; use Rekalogika\\Analytics\\Core\\ValueResolver\\UuidToTruncatedInteger; class YourSummary extends BaseSummary { #[ORM\\Embedded()] #[Analytics\\Partition(new UuidToTruncatedInteger('id'))] private UuidV7IntegerPartition $partition; }   ","version":"Next","tagName":"h2"},{"title":"Concepts‚Äã","type":1,"pageTitle":"Partitioning","url":"/analytics/summary-entity/partitioning#concepts","content":" A property of the source entity is designated the partitioning key. The key is used to partition the data. The key is usually the primary key of the source entity, but not necessarily so. The key must be monotonic, or always increasing, but not necessarily unique. And the key must be permanent, it must not change in the lifetime of the entity.  Partitioning is divided into levels. Each level consists of multiplepartition of the same length, one after the other. Levels are indicated by a number. A lower level has a shorter length than a higher level.  A partition is indicated by the level and the key. A partition of a level consists of several partitions of the lower level, except the lowermost level.  Records from the source entity are grouped by a specific lowest level partition according to the partitioning key, and rolled up into that partition. Then, eventually, the lowest level accumulates enough partitions, and in turn they are rolled up into the next higher level partition. And so on, until the highest level is reached.  If new source entities are added, they will be rolled up to the newest lowest level partition, and the framework does not need to reprocess the entire summary table.  If changes are detected in the old records, the lowest partition is marked as dirty. The framework will reprocess the dirty partition, then mark the higher level partition as dirty, and so on, until it bubbles up to the highest level. Again, the framework does not need to reprocess the entire summary table.  ","version":"Next","tagName":"h2"},{"title":"Available Partitioning Strategies‚Äã","type":1,"pageTitle":"Partitioning","url":"/analytics/summary-entity/partitioning#available-partitioning-strategies","content":" ","version":"Next","tagName":"h2"},{"title":"DefaultIntegerPartition‚Äã","type":1,"pageTitle":"Partitioning","url":"/analytics/summary-entity/partitioning#defaultintegerpartition","content":" Suitable for partitioning auto-incrementing integer primary keys. It partitions using 11, 22, 33, 44, and 55 bits of width. A 11-bit partition aggregates up to 2048 records.  ","version":"Next","tagName":"h3"},{"title":"UuidV7IntegerPartition‚Äã","type":1,"pageTitle":"Partitioning","url":"/analytics/summary-entity/partitioning#uuidv7integerpartition","content":" Suitable for partitioning UUIDv7 (also ULID) primary keys. It should be coupled by a UuidToTruncatedInteger value resolver that truncates the 128-bit UUID to a 48-bit integer.  UUIDv7 (and ULID) stores the creation time in the first 48 bits. So, the widths of each level correspond to the following intervals:  22 bits: corresponds to 1.165 hour interval27 bits: corresponds to 1.6 days interval32 bits: corresponds to 50 days interval37 bits: corresponds to 4.3 years interval  It means the lowest level will contain rolled-up records of those created within 1.165 hour interval. The second level will contain rolled-up records of those created within 1.6 days interval, and so on.  ","version":"Next","tagName":"h3"},{"title":"Custom Integer Partition‚Äã","type":1,"pageTitle":"Partitioning","url":"/analytics/summary-entity/partitioning#custom-integer-partition","content":" You can create a custom integer partition by extending IntegerPartition.  ","version":"Next","tagName":"h3"},{"title":"Custom Non-Integer Partition‚Äã","type":1,"pageTitle":"Partitioning","url":"/analytics/summary-entity/partitioning#custom-non-integer-partition","content":" You might be able to create your own non-integer partition by implementing thePartition interface, but currently this is untested and unsupported. ","version":"Next","tagName":"h3"},{"title":"Dimensions","type":0,"sectionRef":"#","url":"/analytics/summary-entity/dimensions","content":"","keywords":"","version":"Next"},{"title":"Dimension Definition‚Äã","type":1,"pageTitle":"Dimensions","url":"/analytics/summary-entity/dimensions#dimension-definition","content":" In a summary table, a dimension is marked by the #[Analytics\\Dimension]attribute.  use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\ValueResolver\\PropertyValue; use Symfony\\Component\\Translation\\TranslatableMessage; class YourSummary extends Summary { #[ORM\\Column(type: Types::STRING)] #[Analytics\\Dimension( source: new PropertyValue('status'), label: new TranslatableMessage('Status'), )] private ?string $status = null; }   Arguments:  source: A ValueResolver or a string that defines how to get the value from the source entity. A string will be converted to aPropertyValue internally.label: A label for the dimension. An output renderer will be able to use it as a column header or a chart legend. It can be a string or aTranslatableInterface instance, which allows it to be translated into different languages.orderBy: Can be Order::Ascending or Order::Descending. This defines how the dimension values are ordered in the summary table. If not specified, the default order is ascending. If the property is a relation, you can specify an array of Order instead, where the key is the property name of the relation and the value is the order direction.nullLabel: Describes the dimension value when the source value is null, so the final output can be made more readable.  ","version":"Next","tagName":"h2"},{"title":"Hierarchical Dimensions‚Äã","type":1,"pageTitle":"Dimensions","url":"/analytics/summary-entity/dimensions#hierarchical-dimensions","content":" A dimension can be hierarchical. A common example is the time dimension. Thetime dimension can be further divided into year, month, day, and more. The caller will then be able to decide whether to group the time by year,month, or day, etc.  A hierarchical dimension is represented by a Doctrine embeddable. The following example uses a TimeDimensionHierarchy.  use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\Core\\Entity\\BaseSummary; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\ValueResolver\\PropertyValue; use Rekalogika\\Analytics\\Time\\Dimension\\System\\GregorianDateWithHour; class YourSummary extends BaseSummary { #[ORM\\Embedded()] #[Analytics\\Dimension( source: new PropertyValue('time'), )] private GregorianDateWithHour $time; }   Read more about hierarchical dimensions in the Dimension Hierarchy section, and specifically about the time dimensions in the Time Dimensions section. ","version":"Next","tagName":"h2"},{"title":"Measures","type":0,"sectionRef":"#","url":"/analytics/summary-entity/measures","content":"","keywords":"","version":"Next"},{"title":"Aggregate Functions‚Äã","type":1,"pageTitle":"Measures","url":"/analytics/summary-entity/measures#aggregate-functions","content":" The most important argument in the #[Analytics\\Measure] attribute is thefunction argument. This argument is used to define the aggregation function.  use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\Core\\AggregateFunction\\Sum; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; class YourSummary extends Summary { #[ORM\\Column(type: Types::INTEGER)] #[Analytics\\Measure( function: new Sum('price'), )] private ?int $price = null; }   The above measure will sum the price property of the source entity.  Read more about aggregate functions in the aggregate functions section. ","version":"Next","tagName":"h2"},{"title":"Time Dimension","type":0,"sectionRef":"#","url":"/analytics/time-dimension","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"Time Dimension","url":"/analytics/time-dimension#sections","content":" üìÑÔ∏è Dimension Groups If you need to summarize your data by time, most of the time you will want to üìÑÔ∏è Dimensions To summarize a source time field to a single time dimension, you can use the ","version":"Next","tagName":"h2"},{"title":"User Interface","type":0,"sectionRef":"#","url":"/analytics/user-interface","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"User Interface","url":"/analytics/user-interface#sections","content":" üìÑÔ∏è Table Renderer To transform the query result into a table or a pivot table, you can use the üìÑÔ∏è Chart Generator To render the query result as a chart, you can use the ChartGenerator service. üìÑÔ∏è Spreadsheet Renderer To render the query result as a spreadsheet, you can use the üìÑÔ∏è Pivot Table Panel TBD üìÑÔ∏è Formatter Services Formatter services are utility services that transforms values in the query ","version":"Next","tagName":"h2"},{"title":"Chart Generator","type":0,"sectionRef":"#","url":"/analytics/user-interface/chart-generator","content":"Chart Generator To render the query result as a chart, you can use the ChartGenerator service. It returns a Chart instance from the symfony/ux-chartjs package. ChartGenerator is meant to be a simple service that tries to automatically build a chart from a query result without requiring too much configuration. While it is convenient, it is also not very flexible. Example: use Rekalogika\\Analytics\\Contracts\\SummaryManager; use Rekalogika\\Analytics\\Frontend\\Chart\\ChartGenerator; use Rekalogika\\Analytics\\Frontend\\Chart\\ChartType; /** @var SummaryManager $summaryManager */ /** @var ChartGenerator $chartGenerator */ $result = $summaryManager -&gt;createQuery() // ... -&gt;getResult(); $chart = $chartGenerator-&gt;createChart( result: $result, chartType: ChartType::Auto, ); Then, in your Twig template, you can render the chart using the render_chart()function provided by the symfony/ux-chartjs package: {{ render_chart(chart) }} ","keywords":"","version":"Next"},{"title":"Dimension Groups","type":0,"sectionRef":"#","url":"/analytics/time-dimension/dimension-groups","content":"","keywords":"","version":"Next"},{"title":"Example‚Äã","type":1,"pageTitle":"Dimension Groups","url":"/analytics/time-dimension/dimension-groups#example","content":" use Doctrine\\Common\\Collections\\Order; use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\Entity\\BaseSummary; use Rekalogika\\Analytics\\Core\\ValueResolver\\PropertyValue; use Rekalogika\\Analytics\\Time\\Dimension\\System\\GregorianDateWithHour; use Symfony\\Component\\Translation\\TranslatableMessage; class OrderSummary extends BaseSummary { #[ORM\\Embedded()] #[Analytics\\Dimension( source: new PropertyValue('time'), label: new TranslatableMessage('Placed Time'), orderBy: Order::Ascending, )] #[TimeProperties( sourceTimeZone: new \\DateTimeZone('UTC'), summaryTimeZone: new \\DateTimeZone('Asia/Jakarta'), )] private GregorianDateWithHour $time; }   In this example, the property $time in the OrderSummary class will be summarized into the GregorianDateWithHour dimension group. You will be able to select the time using the notation time.year.year, time.month.month,time.month.monthOfYear, time.date.date, etc.  ","version":"Next","tagName":"h2"},{"title":"Available Dimension Groups‚Äã","type":1,"pageTitle":"Dimension Groups","url":"/analytics/time-dimension/dimension-groups#available-dimension-groups","content":" You can use any of these pre-made dimension groups in your summaries, or use these as a base to create your own custom dimension groups.    note In the diagram above, inheritance is conceptual, and implemented using a trait. Doctrine does not support inheritance in embedded objects, so any inheritance must be done using traits and interfaces. ","version":"Next","tagName":"h2"},{"title":"Dimensions","type":0,"sectionRef":"#","url":"/analytics/time-dimension/dimensions","content":"","keywords":"","version":"Next"},{"title":"Usage Inside a Dimension Group‚Äã","type":1,"pageTitle":"Dimensions","url":"/analytics/time-dimension/dimensions#usage-inside-a-dimension-group","content":" If you want to use the time dimension inside a dimension group, you can do the same as above with these changes:  You don't need to supply the input parameter in the TimeBinValueResolver, as it will get the value from upstream.You should omit the TimeProperties attribute, so the user will be able to specify the time zone in the summary class. ","version":"Next","tagName":"h2"},{"title":"Pivot Table Panel","type":0,"sectionRef":"#","url":"/analytics/user-interface/pivot-table-panel","content":"Pivot Table Panel TBD","keywords":"","version":"Next"},{"title":"Formatter Services","type":0,"sectionRef":"#","url":"/analytics/user-interface/formatter-services","content":"","keywords":"","version":"Next"},{"title":"Example: MoneyNumberifier‚Äã","type":1,"pageTitle":"Formatter Services","url":"/analytics/user-interface/formatter-services#example-moneynumberifier","content":" This is the numberifier for the Money object of the brick/money package. TheMoney::__toString() does not return a number, but a string with the currency code, so the framework cannot automatically convert it to a number. This is how you can implement the Numberifier for the Money object:  use Brick\\Money\\Money; use Rekalogika\\Analytics\\Frontend\\Formatter\\Numberifier; use Rekalogika\\Analytics\\Frontend\\Formatter\\ValueNotSupportedException; final class MoneyNumberifier implements Numberifier { #[\\Override] public function toNumber(mixed $input): float { if (!$input instanceof Money) { throw new ValueNotSupportedException(); } return $input-&gt;getAmount()-&gt;toFloat(); } }   ","version":"Next","tagName":"h2"},{"title":"Example: CountryWithFlagHtmlifier‚Äã","type":1,"pageTitle":"Formatter Services","url":"/analytics/user-interface/formatter-services#example-countrywithflaghtmlifier","content":" Suppose you have a Country object, and it would be nice to render it with a flag emoji. You can implement the Htmlifier for the Country object like this:  use Rekalogika\\Analytics\\Frontend\\Formatter\\Htmlifier; use Rekalogika\\Analytics\\Frontend\\Formatter\\ValueNotSupportedException; use Rekalogika\\Analytics\\Tests\\App\\Entity\\Country; final class CountryHtmlifier implements Htmlifier { #[\\Override] public function toHtml(mixed $input): string { if (!$input instanceof Country) { throw new ValueNotSupportedException(); } $emoji = $this-&gt;countryCodeToEmojiFlag($input-&gt;getCode()); return \\sprintf( '%s %s', $emoji, $input-&gt;getName() ?? '', ); } /** * @see https://nick.blog/2018/07/27/php-display-country-flag-emoji-from-iso-3166-1-alpha-2-country-codes/ */ private function countryCodeToEmojiFlag(string $countryCode): string { $countryCode = strtoupper($countryCode); // Ensure uppercase $flag = ''; foreach (str_split($countryCode) as $char) { /** @psalm-suppress PossiblyFalseOperand */ $flag .= mb_convert_encoding('&amp;#' . (127397 + \\ord($char)) . ';', 'UTF-8', 'HTML-ENTITIES'); } return $flag; } }  ","version":"Next","tagName":"h2"},{"title":"Spreadsheet Renderer","type":0,"sectionRef":"#","url":"/analytics/user-interface/spreadsheet-renderer","content":"Spreadsheet Renderer To render the query result as a spreadsheet, you can use theSpreadsheetRenderer::render() method. It returns an instance of Spreadsheetfrom the phpoffice/phpspreadsheet package. use Rekalogika\\Analytics\\Contracts\\SummaryManager; use Rekalogika\\Analytics\\Frontend\\Spreadsheet\\SpreadsheetRenderer; /** @var SummaryManager $summaryManager */ /** @var SpreadsheetRenderer $spreadsheetRenderer */ $result = $summaryManager -&gt;createQuery() // ... -&gt;getResult(); $spreadsheet = $spreadsheetRenderer-&gt;render($result); Then, you can save the spreadsheet to a file or output it to the browser: use PhpOffice\\PhpSpreadsheet\\Writer\\Xlsx; use Symfony\\Component\\HttpFoundation\\StreamedResponse; $writer = new Xlsx($spreadsheet); // Save to a file $writer-&gt;save('path/to/file.xlsx'); // Or output to the browser $response = new StreamedResponse( function () use ($writer) { $writer-&gt;save('php://output'); }, 200, [ 'Content-Type' =&gt; 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'Content-Disposition' =&gt; 'attachment; filename=&quot;report.xlsx&quot;', ] ); ","keywords":"","version":"Next"},{"title":"Table Renderer","type":0,"sectionRef":"#","url":"/analytics/user-interface/table-renderer","content":"","keywords":"","version":"Next"},{"title":"Rendering a Pivot Table or Regular Table‚Äã","type":1,"pageTitle":"Table Renderer","url":"/analytics/user-interface/table-renderer#rendering-a-pivot-table-or-regular-table","content":" The render() method will return a pivot table in HTML string that you can use in your view. If the query does not have a hierarchical ordering, then it is not possible to render to a pivot table. Instead, render will fall back to a regular table.  There are also the renderPivotTable() and renderTable() methods, which allow you to explicitly render the result to a pivot table or regular table, respectively, without autodetection done by render().  use Rekalogika\\Analytics\\Contracts\\SummaryManager; use Rekalogika\\Analytics\\Frontend\\Exception\\AnalyticsFrontendException; use Rekalogika\\Analytics\\Frontend\\Html\\TableRenderer; use Symfony\\Contracts\\Translation\\TranslatorInterface; /** @var SummaryManager $summaryManager */ /** @var TableRenderer $tableRenderer */ /** @var TranslatorInterface $translator */ $result = $summaryManager -&gt;createQuery() // ... -&gt;getResult(); // renderPivotTable() returns a pivot table (or throws an exception if it cannot) $table = $tableRenderer-&gt;renderPivotTable( result: $result, pivotedDimensions: ['@values'] ); // renderTable() returns a regular table $table = $tableRenderer-&gt;renderTable( result: $result, ); // render() autodetects whether to render a pivot table or a regular table $table = $tableRenderer-&gt;render( result: $result, pivotedDimensions: ['@values'] );   The pivotedDimensions parameter is an array of dimension names that you want to pivot into columns. @values is a special dimension value that represents the measures of the query.  ","version":"Next","tagName":"h2"},{"title":"Exception Handling‚Äã","type":1,"pageTitle":"Table Renderer","url":"/analytics/user-interface/table-renderer#exception-handling","content":" By default, any error message will be rendered in the resulting HTML. If you want to handle exceptions yourself, you can add the argument throwException: true to the render(), renderPivotTable(), or renderTable() methods.  The rendering methods may throw an AnalyticsFrontendException if the rendering fails. AnalyticsFrontendException is guaranteed to have a user-friendly, translatable error message that can be safely displayed to the user. Other exceptions are not guaranteed to have a user-friendly message, and should not be displayed to the user directly.  ","version":"Next","tagName":"h2"},{"title":"Changing the Theme‚Äã","type":1,"pageTitle":"Table Renderer","url":"/analytics/user-interface/table-renderer#changing-the-theme","content":" By default, these methods will use a plain table output. To have a themed table, you can change the default theme in the configuration:  config/packages/rekalogika_analytics.yaml rekalogika_analytics: table_theme: &quot;@RekalogikaAnalyticsFrontend/bootstrap_5_renderer.html.twig&quot;   Alternatively, the methods above also accept the theme parameter, which allows you to specify a different theme for the table:  use Rekalogika\\Analytics\\Frontend\\Html\\TableRenderer; /** @var TableRenderer $tableRenderer */ $table = $tableRenderer-&gt;render( result: $result, theme: '@RekalogikaAnalyticsFrontend/bootstrap_5_renderer.html.twig' );   ","version":"Next","tagName":"h2"},{"title":"Creating a Custom Theme‚Äã","type":1,"pageTitle":"Table Renderer","url":"/analytics/user-interface/table-renderer#creating-a-custom-theme","content":" You can create a custom theme by extending theRekalogikaAnalyticsFrontend/renderer.html.twig file. Readbootstrap_5_renderer.html.twig for an example of how to do this. ","version":"Next","tagName":"h2"},{"title":"Value Resolvers","type":0,"sectionRef":"#","url":"/analytics/value-resolver","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"Value Resolvers","url":"/analytics/value-resolver#sections","content":" üìÑÔ∏è Basic Value Resolvers Most of the time, we use either PropertyValue or IdentifierValue to get the üìÑÔ∏è Custom Expression The CustomExpression value resolver allows you to define a custom DQL üìÑÔ∏è Property Path Some ValueResolvers accept property path as their argument. This allows you to üìÑÔ∏è Creating Value Resolvers A ValueResolver basically returns a DQL expression. Usually, we need to take ","version":"Next","tagName":"h2"},{"title":"Summary Class","type":0,"sectionRef":"#","url":"/analytics/summary-entity/summary-class","content":"","keywords":"","version":"Next"},{"title":"Example Source Entity‚Äã","type":1,"pageTitle":"Summary Class","url":"/analytics/summary-entity/summary-class#example-source-entity","content":" This is the example of an entity that we would like to analyze. Here, we have anOrder:  use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity()] class Order { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column] private ?int $id = null; #[ORM\\ManyToOne()] private ?Item $item = null; #[ORM\\ManyToOne()] private ?Customer $customer = null; #[ORM\\Column(type: Types::DATETIME_MUTABLE)] private ?\\DateTimeInterface $time = null; // setters, getters and other logic are omitted for brevity }   The source entity must have a key field that has the following properties:  Permanent, the value never changes in the lifetime of the entity.Monotonic, always increases.  Most of the time, you should be able to use the primary key of the entity as the key field.  ","version":"Next","tagName":"h2"},{"title":"The Summary Entity‚Äã","type":1,"pageTitle":"Summary Class","url":"/analytics/summary-entity/summary-class#the-summary-entity","content":" This is an example summary entity for the above Order entity. A summary table is a standard Doctrine entity with additional attributes that define how the data is rolled up from the source entity:  use Brick\\Money\\Money; use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\Core\\AggregateFunction\\Count; use Rekalogika\\Analytics\\Core\\AggregateFunction\\Sum; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\Partition\\DefaultIntegerPartition; use Rekalogika\\Analytics\\Core\\Entity\\BaseSummary; use Rekalogika\\Analytics\\Core\\ValueResolver\\IdentifierValue; use Rekalogika\\Analytics\\Core\\ValueResolver\\PropertyValue; use Rekalogika\\Analytics\\Time\\Dimension\\System\\GregorianDateWithHour use Rekalogika\\Analytics\\Time\\Metadata\\TimeProperties; use Symfony\\Component\\Translation\\TranslatableMessage; #[ORM\\Entity()] #[Analytics\\Summary( sourceClass: Order::class, label: new TranslatableMessage('Orders'), )] class OrderSummary extends BaseSummary { // 1. Partition #[ORM\\Embedded()] #[Analytics\\Partition(new PropertyValue('id'))] private DefaultIntegerPartition $partition; // 2. Dimensions #[ORM\\Embedded()] #[Analytics\\Dimension( source: new PropertyValue('time'), label: new TranslatableMessage('Time'), )] #[TimeProperties( sourceTimeZone: new \\DateTimeZone('UTC'), summaryTimeZone: new \\DateTimeZone('Asia/Jakarta'), )] private GregorianDateWithHour $time; #[ORM\\ManyToOne()] #[Analytics\\Dimension( source: new IdentifierValue('customer.country'), label: new TranslatableMessage('Customer Country'), )] private ?Country $customerCountry = null; #[ORM\\ManyToOne()] #[Analytics\\Dimension( source: new IdentifierValue('customer.country.region'), label: new TranslatableMessage('Customer Region'), )] private ?Region $customerRegion = null; #[ORM\\Column(enumType: Gender::class, nullable: true)] #[Analytics\\Dimension( source: new PropertyValue('customer.gender'), label: new TranslatableMessage('Customer Gender'), )] private ?Gender $customerGender = null; // 3. Measures #[ORM\\Column(type: Types::INTEGER)] #[Analytics\\Measure( function: new Sum('item.price'), label: new TranslatableMessage('Price'), )] private ?int $price = null; #[ORM\\Column(type: Types::INTEGER)] #[Analytics\\Measure( function: new Count('id'), label: new TranslatableMessage('Count'), )] private ?int $count = null; // 4. An example getter with business logic public function getPrice(): ?Money { if ($this-&gt;price === null) { return null; } return Money::ofMinor($this-&gt;price, 'EUR'); } }   ","version":"Next","tagName":"h2"},{"title":"Sections‚Äã","type":1,"pageTitle":"Summary Class","url":"/analytics/summary-entity/summary-class#sections","content":" ","version":"Next","tagName":"h2"},{"title":"1. Partition‚Äã","type":1,"pageTitle":"Summary Class","url":"/analytics/summary-entity/summary-class#1-partition","content":" The partition attribute is used to define how the data is partitioned. The default DefaultIntegerPartition here should be sufficient for auto-incrementing primary key of the source entity.  Read more about partitions in the partitioning section.  ","version":"Next","tagName":"h3"},{"title":"2. Dimensions‚Äã","type":1,"pageTitle":"Summary Class","url":"/analytics/summary-entity/summary-class#2-dimensions","content":" These are the properties that have distinct, descriptive values. You will use these properties to filter and group the data. Using SQL as an analogy, these are the fields that you would use in a GROUP BY and/or WHERE clause.  All dimensions are indicated by the #[Analytics\\Dimension] attribute. The most important argument is the source argument. This argument is used to resolve the value of the dimension from the source entity. A PropertyValuepoints to the value of a property in the source entity. An IdentifierValuepoints to a related entity.  A dimension can be hierarchical, like the time dimension above. A hierarchical dimension is modeled using a Doctrine embeddable. Inside the class, the time dimension is further divided into year, month, day, and more.  Read more about dimensions in the dimensions section.  ","version":"Next","tagName":"h3"},{"title":"3. Measures‚Äã","type":1,"pageTitle":"Summary Class","url":"/analytics/summary-entity/summary-class#3-measures","content":" These are the properties that you want to aggregate. Using SQL as an analogy, you would use these fields in a SUM, COUNT, and other aggregate functions.  Measures are indicated by the #[Analytics\\Measure] attribute. The most important argument is the function argument. It is used to define the aggregation function.  Read more about measures in the measures section.  ","version":"Next","tagName":"h3"},{"title":"4. Getters‚Äã","type":1,"pageTitle":"Summary Class","url":"/analytics/summary-entity/summary-class#4-getters","content":" Just like a regular Doctrine entity, you can define getters in the summary entity. You can also have simple business logic in these getters. For example, the getPrice() getter above converts the price to a Money object.  ","version":"Next","tagName":"h2"},{"title":"Labels and Translations‚Äã","type":1,"pageTitle":"Summary Class","url":"/analytics/summary-entity/summary-class#labels-and-translations","content":" All the items in the summary entity have a label attribute that accepts a string or a TranslatableInterface. These labels are used in the user interface to identify the item, for example in a table header or a chart legend.  If a TranslatableInterface is used, the label will be translated using the Symfony translation component.  ","version":"Next","tagName":"h2"},{"title":"Indexing‚Äã","type":1,"pageTitle":"Summary Class","url":"/analytics/summary-entity/summary-class#indexing","content":" The framework automatically creates indexes for the summary table. You don't need to create any indexes manually.  ","version":"Next","tagName":"h2"},{"title":"Changing Summary Entity‚Äã","type":1,"pageTitle":"Summary Class","url":"/analytics/summary-entity/summary-class#changing-summary-entity","content":" A summary entity should not be changed after it is created and populated.  If you need to change the summary entity, you should create a new one, refresh the data and wait until it is completed, and then retire the old one. If you anticipate that you will have to change the summary entity, we suggest date-coding the summary entity class name, for example OrderSummary20250115.  ","version":"Next","tagName":"h2"},{"title":"Summary Entity is an Entity but not an Entity‚Äã","type":1,"pageTitle":"Summary Class","url":"/analytics/summary-entity/summary-class#summary-entity-is-an-entity-but-not-an-entity","content":" A summary entity is defined as a Doctrine entity. But it is mainly for defining the structure of the summary table and the summarization behavior. You will never interact with a real instance of the summary entity. Instead, you query the summary table using the SummaryManager, and get the result not in the form of a summary entity.  An event listener is installed to prevent you from accidentally persisting, updating, or deleting a summary entity.  ","version":"Next","tagName":"h2"},{"title":"HasQueryBuilderModifier‚Äã","type":1,"pageTitle":"Summary Class","url":"/analytics/summary-entity/summary-class#hasquerybuildermodifier","content":" The framework works by creating a QueryBuilder to roll-up the data from the source table to the summary table. If you need to modify this QueryBuilder, you can make the summary entity implement the HasQueryBuilderModifier interface.  use Doctrine\\ORM\\QueryBuilder; use Rekalogika\\Analytics\\Contracts\\Summary\\HasQueryBuilderModifier; class OrderSummary extends Summary implements HasQueryBuilderModifier { // ... public function modifyQueryBuilder(QueryBuilder $queryBuilder): void { $queryBuilder-&gt;andWhere('o.id &gt; 100000'); } // ... }   With the above example, the resulting summary table will only consider the orders with an ID greater than 100000. ","version":"Next","tagName":"h2"},{"title":"Custom Expression","type":0,"sectionRef":"#","url":"/analytics/value-resolver/custom-expression","content":"Custom Expression The CustomExpression value resolver allows you to define a custom DQL expression to get the value from the source entity. This is useful when you need to perform complex calculations to get the value. use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\ValueResolver\\CustomExpression; #[ORM\\Entity()] #[Analytics\\Summary( sourceClass: Order::class, )] class OrderSummary extends Summary { #[ORM\\Column(enumType: Gender::class, nullable: true)] #[Analytics\\Dimension( source: new CustomExpression(&quot; CASE WHEN [customer.*] INSTANCE OF Rekalogika\\Analytics\\Tests\\App\\Entity\\IndividualCustomer THEN [customer(Rekalogika\\Analytics\\Tests\\App\\Entity\\IndividualCustomer).gender] ELSE NULLIF('a','a') END &quot;), )] private ?Gender $customerGender = null; } With the above code, if the customer is an IndividualCustomer, it will record their gender. Otherwise, gender is not applicable, and we set it to null. The expressions enclosed in square brackets [...] are property paths, and will be replaced by the real DQL expression.","keywords":"","version":"Next"},{"title":"Basic Value Resolvers","type":0,"sectionRef":"#","url":"/analytics/value-resolver/basic-value-resolvers","content":"","keywords":"","version":"Next"},{"title":"PropertyValue‚Äã","type":1,"pageTitle":"Basic Value Resolvers","url":"/analytics/value-resolver/basic-value-resolvers#propertyvalue","content":" PropertyValue is used to get the value of a property. Example:  use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\ValueResolver\\PropertyValue; #[ORM\\Entity()] #[Analytics\\Summary( sourceClass: Order::class, )] class OrderSummary extends Summary { #[ORM\\Column(type: Types::STRING)] #[Analytics\\Dimension( source: new PropertyValue('status'), )] private ?string $status = null; }   ","version":"Next","tagName":"h2"},{"title":"IdentifierValue‚Äã","type":1,"pageTitle":"Basic Value Resolvers","url":"/analytics/value-resolver/basic-value-resolvers#identifiervalue","content":" IdentifierValue is used to get the identifier of an entity. It must be used if the value is not a simple property, but a related entity.  use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\ValueResolver\\IdentifierValue; #[ORM\\Entity()] #[Analytics\\Summary( sourceClass: Order::class, )] class OrderSummary extends Summary { #[ORM\\ManyToOne()] #[Analytics\\Dimension( source: new IdentifierValue('country'), )] private ?Country $country = null; }   ","version":"Next","tagName":"h2"},{"title":"IntegerValue‚Äã","type":1,"pageTitle":"Basic Value Resolvers","url":"/analytics/value-resolver/basic-value-resolvers#integervalue","content":" IntegerValue is like PropertyValue, but implements PartitionValueResolverand returns an integer value. Usually, it is used in partitions where the source property key is an integer.  use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\Partition\\DefaultIntegerPartition; #[ORM\\Entity()] #[Analytics\\Summary( sourceClass: Order::class, )] class OrderSummary extends Summary { #[ORM\\Embedded()] #[Analytics\\Partition(new IntegerValue('id'))] private DefaultIntegerPartition $partition; }  ","version":"Next","tagName":"h2"},{"title":"rekalogika/api-lite","type":0,"sectionRef":"#","url":"/api-lite","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/api-lite","url":"/api-lite#sections","content":" üìÑÔ∏è Introduction A set of tools to simplify working with [API üìÑÔ∏è Components Overview These are the components involved in building an API Platform-based project üìÑÔ∏è Design Considerations &amp; Decisions Some of our design considerations and decisions based on our experience. These üìÑÔ∏è AbstractState Base class for our providers and processors. üìÑÔ∏è Usage Without AbstractState If you don't want your state providers and processors to extend AbstractState, üìÑÔ∏è Mapping By separating the entity and the ApiResource DTO, mapping between the two üìÑÔ∏è Pagination The mapCollection() method automates the task of handling collection results, üìÑÔ∏è Filtering Filtering support is planned, but it is going to take some time. üóÉÔ∏è Use Cases: Basic Endpoints 7 items üóÉÔ∏è Use Cases: Subresource 4 items ","version":"Next","tagName":"h2"},{"title":"Property Path","type":0,"sectionRef":"#","url":"/analytics/value-resolver/property-path","content":"","keywords":"","version":"Next"},{"title":"Example of Using a Property Path in a Dimension‚Äã","type":1,"pageTitle":"Property Path","url":"/analytics/value-resolver/property-path#example-of-using-a-property-path-in-a-dimension","content":" This is how you can use a property path in a dimension:  use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\ValueResolver\\PropertyValue; #[ORM\\Entity()] #[Analytics\\Summary( sourceClass: Order::class, )] class OrderSummary extends Summary { #[ORM\\Column(type: Types::STRING)] #[Analytics\\Dimension( source: new PropertyValue('customer.country.name'), )] private ?string $countryName = null; }   In this example, from the root Order object, we traverse the customerrelation, and then the country relation to get the name property.  In the following sections, we will only include how to use property paths inValueResolver objects, omitting the rest of the code for brevity.  ","version":"Next","tagName":"h2"},{"title":"Resolve to a Property‚Äã","type":1,"pageTitle":"Property Path","url":"/analytics/value-resolver/property-path#resolve-to-a-property","content":" The most common usage is to resolve to a property:  use Rekalogika\\Analytics\\Core\\ValueResolver\\PropertyValue; $valueResolver = new PropertyValue('customer.country.name');   ","version":"Next","tagName":"h2"},{"title":"Resolve to the Identifier of the Current Entity‚Äã","type":1,"pageTitle":"Property Path","url":"/analytics/value-resolver/property-path#resolve-to-the-identifier-of-the-current-entity","content":" You can resolve to the identifier of the current entity using the special __idproperty:  use Rekalogika\\Analytics\\Core\\ValueResolver\\PropertyValue; // This will resolve to the identifier of the root entity $valueResolver = new PropertyValue('__id'); // This will resolve to the identifier of the customer entity, e.g. Customer.id $valueResolver = new PropertyValue('customer.__id');   ","version":"Next","tagName":"h2"},{"title":"Getting the Alias of a Related Entity‚Äã","type":1,"pageTitle":"Property Path","url":"/analytics/value-resolver/property-path#getting-the-alias-of-a-related-entity","content":" Some DQL clauses expect the alias of a related entity to be passed as an argument, including the INSTANCE OF clause. You can use the * symbol to get the alias of a related entity:  use Rekalogika\\Analytics\\Core\\ValueResolver\\CustomExpression; $valueResolver = new CustomExpression(&quot; CASE WHEN [customer.*] INSTANCE OF App\\Entity\\IndividualCustomer THEN [customer(App\\Entity\\IndividualCustomer).gender] ELSE NULLIF('a','a') END &quot;);   ","version":"Next","tagName":"h2"},{"title":"Casting to a Class‚Äã","type":1,"pageTitle":"Property Path","url":"/analytics/value-resolver/property-path#casting-to-a-class","content":" It is possible to cast a related entity to a specific class using parentheses. This is useful if you need to access a property that is not defined in the root entity. This is an advanced feature, and probably only makes sense if you are using CustomExpression.  use Rekalogika\\Analytics\\Core\\ValueResolver\\CustomExpression; $valueResolver = new CustomExpression(&quot; CASE WHEN [customer.*] INSTANCE OF App\\Entity\\IndividualCustomer THEN [customer(App\\Entity\\IndividualCustomer).gender] ELSE NULLIF('a','a') END &quot;);   info To implement the class casting, the framework will create an additional join using the WITH clause: use Doctrine\\ORM\\QueryBuilder; /** @var QueryBuilder $queryBuilder */ $queryBuilder -&gt;from(Order::class, '_a0') -&gt;leftJoin('_a0.customer', '_a1') // Customer::class -&gt;leftJoin( IndividualCustomer::class, '_a2', 'WITH', '_a2.id = _a1.id', );  ","version":"Next","tagName":"h2"},{"title":"AbstractState","type":0,"sectionRef":"#","url":"/api-lite/abstractstate","content":"","keywords":"","version":"Next"},{"title":"map()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#map","content":" Maps an object to another object. Useful for mapping an entity to its API resource DTO.  /** @var Book $book */ $bookDto = $this-&gt;map($book, BookDto::class); // also works with an existing object $bookDto = new BookDto(); $this-&gt;map($book, $bookDto);   ","version":"Next","tagName":"h2"},{"title":"mapCollection()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#mapcollection","content":" Takes a supported collection object, and returns a PaginatorInterface with its items mapped to the specified class. It also respects the current page and items per page of the endpoint.  /** @var Book $book */ // returns a paginator of `ReviewDto` return $this-&gt;mapCollection( collection: $book-&gt;getReviews(), target: BookDto::class, operation: $operation, // operation from the `provide()` method context: $context, // context from the `provide()` method );   If the target is null, mapCollection() skips the mapping, it only does the pagination.  ","version":"Next","tagName":"h2"},{"title":"getUser()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#getuser","content":" Returns the current user according to the security system.  $user = $this-&gt;getUser();   ","version":"Next","tagName":"h2"},{"title":"isGranted()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#isgranted","content":" Checks if the attribute is granted against the current authentication token and the supplied subject.  if (!$this-&gt;isGranted('view', $book)) { throw $this-&gt;createAccessDeniedException(); }   ","version":"Next","tagName":"h2"},{"title":"denyAccessUnlessGranted()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#denyaccessunlessgranted","content":" Throws an AccessDeniedException if the attribute is not granted against the current authentication token and optionally the supplied subject.  $this-&gt;denyAccessUnlessGranted('view', $book);   ","version":"Next","tagName":"h2"},{"title":"createAccessDeniedException()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#createaccessdeniedexception","content":" Creates an AccessDeniedException.  ","version":"Next","tagName":"h2"},{"title":"createNotFoundException()‚Äã","type":1,"pageTitle":"AbstractState","url":"/api-lite/abstractstate#createnotfoundexception","content":" Creates a NotFoundException. ","version":"Next","tagName":"h2"},{"title":"Creating Value Resolvers","type":0,"sectionRef":"#","url":"/analytics/value-resolver/creating-value-resolvers","content":"","keywords":"","version":"Next"},{"title":"Interfaces‚Äã","type":1,"pageTitle":"Creating Value Resolvers","url":"/analytics/value-resolver/creating-value-resolvers#interfaces","content":"   ","version":"Next","tagName":"h2"},{"title":"Implementing ValueResolver‚Äã","type":1,"pageTitle":"Creating Value Resolvers","url":"/analytics/value-resolver/creating-value-resolvers#implementing-valueresolver","content":" To create a value resolver, you need to implement the ValueResolver interface.  namespace Rekalogika\\Analytics\\Contracts\\Summary; use Rekalogika\\Analytics\\Contracts\\Context\\SourceQueryContext; interface ValueResolver { public function getExpression(SourceQueryContext $context): string; /** * @return list&lt;string&gt; */ public function getInvolvedProperties(): array; }   ","version":"Next","tagName":"h2"},{"title":"Hierarchy Awareness‚Äã","type":1,"pageTitle":"Creating Value Resolvers","url":"/analytics/value-resolver/creating-value-resolvers#hierarchy-awareness","content":" If you need the value resolver to be usable in a hierarchy context, you also need to implement the HierarchyAware interface. It allows the framework to inject the input ValueResolver defined in the parent summary object.  namespace Rekalogika\\Analytics\\Contracts\\Hierarchy; use Rekalogika\\Analytics\\Contracts\\Summary\\ValueResolver; interface HierarchyAware { public function withInput(ValueResolver $input): static; }   ","version":"Next","tagName":"h2"},{"title":"Usage in Partitions‚Äã","type":1,"pageTitle":"Creating Value Resolvers","url":"/analytics/value-resolver/creating-value-resolvers#usage-in-partitions","content":" A partition also uses a value resolver. If you want to use your value resolver for a partition, you need to implement the PartitionValueResolver interface.  namespace Rekalogika\\Analytics\\Contracts\\Summary; interface PartitionValueResolver extends ValueResolver { public function getInvolvedProperties(): array; public function transformSourceValueToSummaryValue(mixed $value): int; public function transformSummaryValueToSourceValue(int $value): mixed; }   ","version":"Next","tagName":"h2"},{"title":"Context Object‚Äã","type":1,"pageTitle":"Creating Value Resolvers","url":"/analytics/value-resolver/creating-value-resolvers#context-object","content":" The SourceQueryContext object is passed to the getExpression() method. It contains the context of the query, including the metadata, and the resolve()method to access the source entity properties.  The resolve() method takes a property path as its argument and returns the DQL expression for that property. Read more about property paths in theProperty Paths section.  ","version":"Next","tagName":"h2"},{"title":"User Value Transformer‚Äã","type":1,"pageTitle":"Creating Value Resolvers","url":"/analytics/value-resolver/creating-value-resolvers#user-value-transformer","content":" After a query, the framework will instantiate the summary entity using the result values. Rather than getting the value as returned by Doctrine, the user has the option to create a getter method that transforms the value into a format more suitable for the caller.  However, doing that manually can be a very tedious task. You have the option to streamline this process by embedding the logic into the value resolver itself, so the user can use the same logic every time they use the same value resolver. To achieve that, you need to make your value resolver implement theUserValueTransformer interface.  use Rekalogika\\Analytics\\Contracts\\Summary\\ValueResolver; use Rekalogika\\Analytics\\Contracts\\Summary\\UserValueTransformer; use Rekalogika\\Analytics\\Contracts\\Context\\SourceQueryContext; final readonly class QualityValueResolver implements ValueResolver, UserValueTransformer { public function getExpression(SourceQueryContext $context): string { // ... } public function getInvolvedProperties(): array { // ... } public function transformUserValue(mixed $value): mixed { // $value is the value returned by Doctrine return new Quality($value); } }   Then in the summary class, the user will be able to do something like this:  use Doctrine\\ORM\\Mapping as ORM; use Doctrine\\ORM\\Types\\Types; use Rekalogika\\Analytics\\Core\\Metadata as Analytics; use Rekalogika\\Analytics\\Core\\Entity\\BaseSummary; #[ORM\\Entity()] #[Analytics\\Summary( sourceClass: Order::class, )] class OrderSummary extends BaseSummary { #[ORM\\Column(type: Types::INTEGER)] #[Analytics\\Dimension( source: new QualityValueResolver('quality'), )] private ?int $quality = null; public function getQuality(): ?Quality { return $this-&gt;getContext()-&gt;getUserValue( property: 'quality', class: Quality::class, ); } }  ","version":"Next","tagName":"h2"},{"title":"Use Cases: Basic Endpoints","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints","content":"Use Cases: Basic Endpoints üìÑÔ∏è Objects Used in the Examples üìÑÔ∏è GET Collection Endpoint üìÑÔ∏è GET Endpoint üìÑÔ∏è POST Endpoint for Entity Creation üìÑÔ∏è PATCH and PUT Endpoint for Entity Update The properties in the input DTO are uninitialized. This is important for PATCH üìÑÔ∏è DELETE Endpoint üìÑÔ∏è POST Endpoint for an Action Without Input","keywords":"","version":"Next"},{"title":"GET Endpoint","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/get","content":"GET Endpoint API ResourceState Provider src/ApiResource/Admin/BookDto.php namespace App\\ApiResource\\Admin; use App\\ApiState\\Admin\\Book\\BookProvider; use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Get; #[ApiResource( shortName: 'Admin/Book', routePrefix: '/admin', operations: [ // ... new Get( uriTemplate: '/books/{id}', provider: BookProvider::class, ), // ... ] )] class BookDto { // ... } ","keywords":"","version":"Next"},{"title":"DELETE Endpoint","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/delete","content":"DELETE Endpoint API ResourceState Processor src/ApiResource/Admin/BookDto.php use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Patch; use App\\ApiInput\\BookInputDto; use App\\ApiState\\Admin\\Book\\BookRemoveProcessor; #[ApiResource( shortName: 'Admin/Book', routePrefix: '/admin', operations: [ // ... new Delete( uriTemplate: '/books/{id}', processor: BookRemoveProcessor::class ), // ... ] )] class BookDto { // ... } ","keywords":"","version":"Next"},{"title":"GET Collection Endpoint","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/get-collection","content":"GET Collection Endpoint API ResourceState Provider src/ApiResource/Admin/BookDto.php namespace App\\ApiResource\\Admin; use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\GetCollection; use App\\ApiState\\Admin\\Book\\BookCollectionProvider; #[ApiResource( shortName: 'Admin/Book', routePrefix: '/admin', // // Uncomment the following to enable keyset-pagination: // extraProperties: [ // 'api_lite_rekapager' =&gt; true // ] operations: [ // ... new GetCollection( uriTemplate: '/books', provider: BookCollectionProvider::class, ), // ... ] )] class BookDto { // ... } ","keywords":"","version":"Next"},{"title":"PATCH and PUT Endpoint for Entity Update","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/patch-put-update","content":"PATCH and PUT Endpoint for Entity Update API ResourceInput DTOState Processor src/ApiResource/Admin/BookDto.php use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Patch; use App\\ApiInput\\BookInputDto; use App\\ApiState\\Admin\\Book\\BookProvider; use App\\ApiState\\Admin\\Book\\BookUpdateProcessor; #[ApiResource( shortName: 'Admin/Book', routePrefix: '/admin', operations: [ // ... new Patch( uriTemplate: '/books/{id}', input: BookInputDto::class, processor: BookUpdateProcessor::class, read: false, ), new Put( uriTemplate: '/books/{id}', input: BookInputDto::class, processor: BookUpdateProcessor::class, read: false, ), // ... ] )] class BookDto { // ... } ","keywords":"","version":"Next"},{"title":"Components Overview","type":0,"sectionRef":"#","url":"/api-lite/components","content":"","keywords":"","version":"Next"},{"title":"Components Defined by Your Application‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#components-defined-by-your-application","content":" ","version":"Next","tagName":"h2"},{"title":"Domain Layer‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#domain-layer","content":" The heart of your software. The domain layer describes the business logic and rules. It consists of entities, value objects, domain services, and other supporting classes.  In most Symfony and API Platform projects, Doctrine is used to manage the persistence of the domain layer. However, it can be anything &amp; our API layer does not care about how the domain layer is persisted and managed.  ","version":"Next","tagName":"h3"},{"title":"API Resource DTOs‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#api-resource-dtos","content":" These are the data transfer objects (DTOs) that are used to represent the resources in the API. In our projects, we will be using these DTOs as theApiResource classes. Unlike most of the API Platform examples and demos you will find on the Internet, we will not be adding the ApiResource attribute to our entities.  These DTOs will usually mirror the domain entities. They usually contain a subset of the properties, but without the domain logic. And like the entities, these DTOs will usually form a rich, interconnected graph of objects.  These DTOs act as the output of the endpoints.  An entity can be mapped to one or more DTOs if we need different API representations of a specific entity. For example, we can use a specific DTO for a class of user, and a different DTO for another class or user.  ","version":"Next","tagName":"h3"},{"title":"Input DTOs‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#input-dtos","content":" The DTOs representing the input data for operations that require an input, like POST, PUT, and PATCH.  ","version":"Next","tagName":"h3"},{"title":"Components Defined by API Platform‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#components-defined-by-api-platform","content":" ","version":"Next","tagName":"h2"},{"title":"State Provider‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#state-provider","content":" Used to get the output of a GET operations. Using our guidelines, you will implement a state provider for every GET operation that you define. The state provider will be responsible for fetching the entity from the domain layer, mapping it to the DTO, and returning it.  ","version":"Next","tagName":"h3"},{"title":"State Processor‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#state-processor","content":" Modifies the state of the entity. Used by the POST, PUT, PATCH, and DELETE operations. Using our guidelines, you will implement a state processor for every operation that modifies the state of the entity.  ","version":"Next","tagName":"h3"},{"title":"Paginator‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#paginator","content":" A paginator is an API Platform interface used to paginate the results of a GET operations. If your endpoint is a GET operation that is supposed to return a collection of objects, you should return a paginator object instead of an array or a collection. By doing so, you will get proper paging of the results.  ","version":"Next","tagName":"h3"},{"title":"Components Defined By rekalogika/api-lite‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#components-defined-by-rekalogikaapi-lite","content":" ","version":"Next","tagName":"h2"},{"title":"Mapper‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#mapper","content":" Maps an object to another object. The functionality is provided byrekalogika/mapper behind the scenes. It can be used to map between entities and DTOs. This mapper provides several critical features for our purposes, including handling circular references and lazy-loading target objects. Therefore, we can have interconnected DTOs and API Platform should be able to generate IRIs without causing the hydration of the entire object graph.  ","version":"Next","tagName":"h3"},{"title":"Paginator Applier‚Äã","type":1,"pageTitle":"Components Overview","url":"/api-lite/components#paginator-applier","content":" A service provided by rekalogika/api-lite to automatically transform a collection of objects to a paginator. It ships with paginator appliers for Doctrine Collection, Selectable, Query, QueryBuilder, as well as Pagerfanta and Pagerfanta adapter.. ","version":"Next","tagName":"h3"},{"title":"POST Endpoint for Entity Creation","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/post-create","content":"POST Endpoint for Entity Creation API ResourceInput DTOState Processor src/ApiResource/Admin/BookDto.php use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Post; use ApiPlatform\\Metadata\\Put; use App\\ApiInput\\BookInputDto; use App\\ApiState\\Admin\\Book\\BookCreateProcessor; #[ApiResource( shortName: 'Admin/Book', routePrefix: '/admin', operations: [ // ... new Post( uriTemplate: '/books', input: BookInputDto::class, processor: BookCreateProcessor::class ), // ... ] )] class BookDto { // ... } ","keywords":"","version":"Next"},{"title":"POST Endpoint for an Action Without Input","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/post-without-input","content":"POST Endpoint for an Action Without Input API ResourceState Processor src/ApiResource/Admin/BookDto.php use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Patch; use ApiPlatform\\OpenApi\\Model\\Operation; use ApiPlatform\\OpenApi\\Model\\RequestBody; use App\\ApiInput\\BookInputDto; use App\\ApiState\\Admin\\Book\\BookCheckProcessor; #[ApiResource( shortName: 'Admin/Book', routePrefix: '/admin', operations: [ // ... new Post( uriTemplate: '/books/{id}/check', processor: BookCheckProcessor::class, input: false, openapi: new Operation( summary: 'Check the book\\'s condition', description: 'Tells us that the book condition has been checked.', ) ), // ... ] )] class BookDto { // ... } ","keywords":"","version":"Next"},{"title":"Objects Used in the Examples","type":0,"sectionRef":"#","url":"/api-lite/basic-endpoints/objects","content":"Objects Used in the Examples BookReviewBookDtoReviewDto src/Entity/Book.php namespace App\\Entity; use App\\Repository\\BookRepository; use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\Mapping as ORM; use Symfony\\Bridge\\Doctrine\\Types\\UuidType; use Symfony\\Component\\Uid\\Uuid; #[ORM\\Entity(repositoryClass: BookRepository::class)] class Book extends \\stdClass { #[ORM\\Id] #[ORM\\Column(type: UuidType::NAME, unique: true, nullable: false)] private Uuid $id; #[ORM\\Column] private ?string $title = null; #[ORM\\Column(type: Types::TEXT)] private ?string $description = null; #[ORM\\Column(type: Types::DATETIME_IMMUTABLE, nullable: true)] private ?\\DateTimeInterface $lastChecked = null; /** * @var Collection&lt;array-key,Review&gt; */ #[ORM\\OneToMany( targetEntity: Review::class, mappedBy: 'book', cascade: ['persist', 'remove'], orphanRemoval: true, fetch: 'EXTRA_LAZY', indexBy: 'id', )] private Collection $reviews; public function __construct() { $this-&gt;id = Uuid::v7(); $this-&gt;reviews = new ArrayCollection(); } /** * We want to check our books' conditions every now and then. */ public function check(): void { $this-&gt;lastChecked = new \\DateTimeImmutable(); } public function getId(): Uuid { return $this-&gt;id; } public function getTitle(): ?string { return $this-&gt;title; } public function setTitle(?string $title): self { $this-&gt;title = $title; return $this; } public function getDescription(): ?string { return $this-&gt;description; } public function setDescription(?string $description): self { $this-&gt;description = $description; return $this; } /** * @return Collection&lt;array-key,Review&gt; */ public function getReviews(): Collection { return $this-&gt;reviews; } public function addReview(Review $review): self { if (!$this-&gt;reviews-&gt;contains($review)) { $this-&gt;reviews[] = $review; $review-&gt;setBook($this); } return $this; } public function removeReview(Review $review): self { if ($this-&gt;reviews-&gt;removeElement($review)) { // set the owning side to null (unless already changed) if ($review-&gt;getBook() === $this) { $review-&gt;setBook(null); } } return $this; } public function getLastChecked(): ?\\DateTimeInterface { return $this-&gt;lastChecked; } } ","keywords":"","version":"Next"},{"title":"Design Considerations & Decisions","type":0,"sectionRef":"#","url":"/api-lite/design","content":"","keywords":"","version":"Next"},{"title":"Component Decoupling‚Äã","type":1,"pageTitle":"Design Considerations & Decisions","url":"/api-lite/design#component-decoupling","content":" API Platform must not implicitly interact with Doctrine or other persistence layer behind the scenes. You can do that by not attaching #[ApiResource] to any Doctrine entities. But to make sure this is the case, you can add these options to your configuration:  config/packages/api_platform.yaml api_platform: doctrine: enabled: false doctrine_mongodb_odm: enabled: false   ","version":"Next","tagName":"h2"},{"title":"DTOs as the ApiResource‚Äã","type":1,"pageTitle":"Design Considerations & Decisions","url":"/api-lite/design#dtos-as-the-apiresource","content":" Domain entities are not designated ApiResource. Instead, we create a DTO for the purpose. Then, in the state providers and processors, we will map the entity to the DTO, and return the DTO.  ","version":"Next","tagName":"h2"},{"title":"No Serialization Groups‚Äã","type":1,"pageTitle":"Design Considerations & Decisions","url":"/api-lite/design#no-serialization-groups","content":" Serialization groups are not scalable. They can start becoming unwieldy as the project grows. Instead, if we need a different API representation of the same entity, we explicitly create multiple DTOs that act as the ApiResource. These different DTOs should get a different URL and a different shortName.  ","version":"Next","tagName":"h2"},{"title":"Separate Input and Output DTOs‚Äã","type":1,"pageTitle":"Design Considerations & Decisions","url":"/api-lite/design#separate-input-and-output-dtos","content":" Avoid using the same DTO as both input and output, and using serialization groups to define the differences between the two. Instead, we use a separate DTO for input and output.  The ApiResource DTOs defines the output data structure. In POST, PUT, and PATCH endpoints, we create another DTO to represent the input data structure. In the ApiResource DTO, we use the input argument to point to the input DTO.  ","version":"Next","tagName":"h2"},{"title":"Provider-less Operations‚Äã","type":1,"pageTitle":"Design Considerations & Decisions","url":"/api-lite/design#provider-less-operations","content":" ApiResource and all of its operations do not get assigned a provider, except for Get and GetCollection. All processors get their data directly from the repository. We find this degree of explicitness helps with DX, readability, and flexibility.  Get and GetCollection also gets a separate provider each for more explicitness.  Put, Patch, and Delete will require a read: false option to prevent404 error.  ","version":"Next","tagName":"h2"},{"title":"Authorization‚Äã","type":1,"pageTitle":"Design Considerations & Decisions","url":"/api-lite/design#authorization","content":" Because of the nature of our provider-less operations above, the securityproperty in ApiResource and its operations will be less useful, as objectwill either be null or points to the DTO, not the entity.  Instead, our AbstractState provides isGranted() anddenyAccessUnlessGranted() methods that most of us are already familiar. Security checks involving an action toward an object should be done next to the action anyway, not in a separate class. Otherwise, it reduces readability, and can easily lead to coding errors. ","version":"Next","tagName":"h2"},{"title":"Filtering","type":0,"sectionRef":"#","url":"/api-lite/filtering","content":"Filtering info Filtering support is planned, but it is going to take some time.","keywords":"","version":"Next"},{"title":"Use Cases: Subresource","type":0,"sectionRef":"#","url":"/api-lite/subresource","content":"Use Cases: Subresource üìÑÔ∏è GET Collection Endpoint for Subresources üìÑÔ∏è Referencing a Collection of Subresources Using a Collection of IRIs üìÑÔ∏è GET Endpoint for a Subresource üìÑÔ∏è Referencing a Subresource Using the IRI of the resource","keywords":"","version":"Next"},{"title":"Mapping","type":0,"sectionRef":"#","url":"/api-lite/mapping","content":"","keywords":"","version":"Next"},{"title":"When To Use the Mapper and When Not To‚Äã","type":1,"pageTitle":"Mapping","url":"/api-lite/mapping#when-to-use-the-mapper-and-when-not-to","content":" When you need to map an entity to a DTO, then the mapper is almost always the tool for the job. It handles circular references and supports lazy-loading, things that are difficult to do manually. The mapper should work most of the time. And when it doesn't, it is only a simple matter to extend it.  However, when you need to map a DTO to an entity, it requires more consideration. Your domain model might mandate a specific way to do things, which might be different from than just calling the setters. If you can rely too much on the mapper, it might indicate that your domain model is anemic, and you should look into that. The integrity of your domain model should not suffer just because using the mapper is convenient.  ","version":"Next","tagName":"h2"},{"title":"Lazy Loading‚Äã","type":1,"pageTitle":"Mapping","url":"/api-lite/mapping#lazy-loading","content":" The mapper supports lazy loading on regular objects and collection objects. So, you are free to add relations among your DTOs as much as you need. You can have your DTOs mirror the relations of your domain entities as closely as you want without worrying about excessive Doctrine queries.  These are what you need to keep in mind:  The DTOs must not be final. Otherwise, lazy loading will not work.You should type hint collection properties using CollectionInterface. Plain arrays cannot support lazy loading.Your DTOs must use the same identifier as your entities. Otherwise, the DTO might cause unwanted hydration of the source entity.  Protip Mapper has a panel in Symfony Profiler. You can use it to debug the mapper if you have a mapping problem.  ","version":"Next","tagName":"h2"},{"title":"Lazy-Loading Collection Example‚Äã","type":1,"pageTitle":"Mapping","url":"/api-lite/mapping#lazy-loading-collection-example","content":" With the following example, API platform will turn the reviews property to the IRI of the collection:  use ApiPlatform\\Core\\Annotation\\ApiProperty; use Rekalogika\\Mapper\\CollectionInterface; class BookDto { /** * @var ?CollectionInterface&lt;int,ReviewDto&gt; */ #[ApiProperty(uriTemplate: '/books/{bookId}/reviews')] public ?CollectionInterface $reviews = null; }   In this case, the serializer will not read the content of the reviewsproperty, and therefore Doctrine won't hydrate the source collection.  ","version":"Next","tagName":"h3"},{"title":"Lazy-Loading Object Example‚Äã","type":1,"pageTitle":"Mapping","url":"/api-lite/mapping#lazy-loading-object-example","content":" With the following example, the book property below will be turned into the IRI of the BookDto resource:  use ApiPlatform\\Core\\Annotation\\ApiProperty; class ReviewDto { #[ApiProperty(readableLink: false)] public ?BookDto $book = null; }   To generate the IRI, API Platform requires only the identifier. Doctrine will not hydrate the entity if all we are getting from it is the identifier. Mapper's proxy is smart enough to determine the identifier of the Doctrine entity, and won't try to map the other properties.  Therefore, generating an IRI won't cost you a Doctrine query, as long as you make sure both the DTO and the Doctrine entity use the same identifier property.  Protip Just use id as the identifier property everywhere, and be done with it.  ","version":"Next","tagName":"h3"},{"title":"The Mapper Remembers...‚Äã","type":1,"pageTitle":"Mapping","url":"/api-lite/mapping#the-mapper-remembers","content":" The mapper remembers the previous mappings it has done in the same request, and will take note of the reverse of the mappings.  If the client sent an IRI in the request, like/user/books/018dda4b-1884-76ab-af9d-71ab512a0c84, API Platform will resolve the IRI using a State Provider having the same URL pattern. If you are using the same pattern elaborated in this document, then your State Provider will get the entity from the database, map it to its DTO, and returns the DTO.  Once API Platform has the DTO, it will pass it as part of the input of your State Processor. So you are getting the DTO, not the entity you need. How would you get the entity? You map the DTO to the entity class. It will return you the entity because you once mapped the entity to the DTO in the State Provider. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/api-lite/intro","content":"","keywords":"","version":"Next"},{"title":"Motivation‚Äã","type":1,"pageTitle":"Introduction","url":"/api-lite/intro#motivation","content":" API Platform documentation encourages developers to use plain old PHP objects (POPOs) or data transfer objects (DTOs) as the models for API communication, instead of using domain entities directly for this purpose. But it does not establish a practical working patterns for that approach.  Practically all the examples and demos we find on the Internet still attach ApiResource to Doctrine entities.  Sometimes API Platform can feel very rigid. It can be difficult to figure out how to accomplish things outside its conventions. There are ways around any problem, just not always immediately obvious. It can feel like that we just want to express what we need by writing a PHP code, not by figuring out the correct combination of attributes to use.  Those coming from Symfony controllers might find API Platform's approach very different, but it does not have to be.  ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Introduction","url":"/api-lite/intro#installation","content":" composer require rekalogika/api-lite   ","version":"Next","tagName":"h2"},{"title":"Synopsis‚Äã","type":1,"pageTitle":"Introduction","url":"/api-lite/intro#synopsis","content":" use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\ApiLite\\State\\AbstractProvider; use Rekalogika\\Mapper\\CollectionInterface; #[ApiResource( shortName: 'Book', operations: [ new Get( uriTemplate: '/books/{id}', provider: BookProvider::class ), ] )] class BookDto { public ?Uuid $id = null; public ?string $title = null; public ?string $description = null; /** * @var ?CollectionInterface&lt;int,ReviewDto&gt; */ public ?CollectionInterface $reviews = null; } /** * @extends AbstractProvider&lt;BookDto&gt; */ class BookProvider extends AbstractProvider { public function __construct( private BookRepository $bookRepository ) { } public function provide( Operation $operation, array $uriVariables = [], array $context = [] ): object|array|null { $book = $this-&gt;bookRepository -&gt;find($uriVariables['id'] ?? null) ?? throw new NotFoundException('Book not found'); $this-&gt;denyAccessUnlessGranted('view', $book); return $this-&gt;map($book, BookDto::class); } }   ","version":"Next","tagName":"h2"},{"title":"To-Do List‚Äã","type":1,"pageTitle":"Introduction","url":"/api-lite/intro#to-do-list","content":" Figure out &amp; implement filtering.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction","url":"/api-lite/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/api-lite/intro#contributing","content":" Issues and pull requests should be filed in the GitHub repositoryrekalogika/api-lite. ","version":"Next","tagName":"h2"},{"title":"GET Collection Endpoint for Subresources","type":0,"sectionRef":"#","url":"/api-lite/subresource/get-collection-subresource","content":"GET Collection Endpoint for Subresources API ResourceState Provider src/ApiResource/User/ReviewDto.php namespace App\\ApiResource\\User; use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\GetCollection; use ApiPlatform\\Metadata\\Link; use App\\ApiState\\User\\Review\\BookReviewCollectionProvider; #[ApiResource( shortName: 'User/Review', routePrefix: '/user', operations: [ // ... new GetCollection( uriTemplate: '/books/{bookId}/reviews', uriVariables: [ 'bookId' =&gt; new Link( fromClass: BookDto::class, ), ], provider: BookReviewCollectionProvider::class, paginationItemsPerPage: 10 ), // ... ] )] class ReviewDto { // ... } ","keywords":"","version":"Next"},{"title":"Pagination","type":0,"sectionRef":"#","url":"/api-lite/pagination","content":"","keywords":"","version":"Next"},{"title":"Usage‚Äã","type":1,"pageTitle":"Pagination","url":"/api-lite/pagination#usage","content":" Common usage pattern in a state provider for a GetCollection endpoint:  use ApiPlatform\\Metadata\\Operation; use Rekalogika\\ApiLite\\State\\AbstractProvider; /** * @extends AbstractProvider&lt;SomeObjectDto&gt; */ class CollectionProvider extends AbstractProvider { // ... public function provide( Operation $operation, array $uriVariables = [], array $context = [] ): object|array|null { // get the $collectionObject here return $this-&gt;mapCollection( collection: $collectionObject, target: SomeObjectDto::class, operation: $operation, context: $context ); } }   The highlighted code takes the $collectionObject, pages it according to the paging parameters provided by API Platform, maps each item in the collection to the SomeObjectDto class, and returns the results in a PaginatorInterfaceobject that API Platform expects.  ","version":"Next","tagName":"h2"},{"title":"Supported Collection Objects‚Äã","type":1,"pageTitle":"Pagination","url":"/api-lite/pagination#supported-collection-objects","content":" The mapCollection() method supports the following collection object types:  Doctrine Collection and ReadableCollection.Doctrine Selectable.Doctrine ORM Query and QueryBuilder.Pagerfanta's PagerfantaInterface and PagerfantaAdapterInterface  If you enable Rekapager support to get keyset-based pagination, it supports the following types:  Doctrine ORM QueryBuilder.Doctrine Selectable.  If Rekapager is enabled, but the underlying collection object is not supported, the method will fall back to the default offset-based pagination.  ","version":"Next","tagName":"h2"},{"title":"Keyset Pagination (or Cursor Pagination) using Rekapager‚Äã","type":1,"pageTitle":"Pagination","url":"/api-lite/pagination#keyset-pagination-or-cursor-pagination-using-rekapager","content":" The package supports keyset pagination using our Rekapagerpackage. Its usage is opt-in. By default, paginations will be done using the default offset-based API Platform pagination.  info Learn more about Rekapager and keyset pagination in our Rekapager documentation.  To enable Rekapager support per operation, add the api_lite_rekapager extra property to the operation:  #[ApiResource( extraProperties: [ 'api_lite_rekapager' =&gt; true ] )] class Book { // ... }   To enable it globally, you can set it in API Platform's configuration:  config/packages/api_platform.yaml api_platform: defaults: extra_properties: api_lite_rekapager: true   ","version":"Next","tagName":"h2"},{"title":"Supporting Other Collection Objects‚Äã","type":1,"pageTitle":"Pagination","url":"/api-lite/pagination#supporting-other-collection-objects","content":" If you need to support other collection object types, you can create a class implementing PaginatorApplierInterface.  ","version":"Next","tagName":"h2"},{"title":"Use Case: Doctrine Repository‚Äã","type":1,"pageTitle":"Pagination","url":"/api-lite/pagination#use-case-doctrine-repository","content":" Doctrine repositories implement Selectable, so you can conveniently do the following in the state provider, and avoid the nee d to create queries:  use ApiPlatform\\Metadata\\Operation; use Rekalogika\\ApiLite\\State\\AbstractProvider; /** * @extends AbstractProvider&lt;SomeObjectDto&gt; */ class CollectionProvider extends AbstractProvider { public function __construct( private SomeObjectRepository $someObjectRepository ) { } public function provide( Operation $operation, array $uriVariables = [], array $context = [] ): object|array|null { return $this-&gt;mapCollection( collection: $this-&gt;someObjectRepository, target: SomeObjectDto::class, operation: $operation, context: $context ); } }   To get a default sorting, you can override the matching() method in the repository like this:  use Doctrine\\Common\\Collections\\Criteria; class SomeObjectRepository extends EntityRepository implements Selectable { public function matching(Criteria $criteria): Collection { if (count($criteria-&gt;orderings()) === 0) { $criteria-&gt;orderBy(['createdAt' =&gt; 'DESC']); } return parent::matching($criteria); } }  ","version":"Next","tagName":"h2"},{"title":"Usage Without AbstractState","type":0,"sectionRef":"#","url":"/api-lite/without-abstractstate","content":"Usage Without AbstractState If you don't want your state providers and processors to extend AbstractState, you can wire the services directly. To use map(), you can inject ApiMapperInterface. And to usemapCollection(), you can inject ApiCollectionMapperInterface. The usage is the same as described in the AbstractState section. warning Be sure to use the correct service class ApiMapperInterface, notMapperInterface, which is the plain mapper implementation fromrekalogika/mapper without the remembering feature.","keywords":"","version":"Next"},{"title":"Referencing a Subresource","type":0,"sectionRef":"#","url":"/api-lite/subresource/referencing-subresource","content":"","keywords":"","version":"Next"},{"title":"Using the IRI of the resource‚Äã","type":1,"pageTitle":"Referencing a Subresource","url":"/api-lite/subresource/referencing-subresource#using-the-iri-of-the-resource","content":" By default, API Platform will use IRIs to refer to a resource. But, if you want this style, we recommend setting it explicitly using#[ApiProperty(readableLink: false)].  OutputAPI Resource { &quot;@context&quot;: &quot;/contexts/User/Review&quot;, &quot;@id&quot;: &quot;/user/reviews/018de474-1a23-7494-85f9-e92fb962d2a8&quot;, &quot;@type&quot;: &quot;User/Review&quot;, &quot;id&quot;: &quot;018de474-1a23-7494-85f9-e92fb962d2a8&quot;, &quot;body&quot;: &quot;Occaecati voluptate sed sed suscipit. Voluptas expedita quis molestias quam modi deleniti earum. Voluptas dolorem pariatur iusto quis. Rerum in quisquam nisi neque.&quot;, &quot;rating&quot;: 5, &quot;book&quot;: &quot;/user/books/018de474-1a2a-7975-87bb-5944ee8ee95f&quot; }   ","version":"Next","tagName":"h2"},{"title":"Embed the resource‚Äã","type":1,"pageTitle":"Referencing a Subresource","url":"/api-lite/subresource/referencing-subresource#embed-the-resource","content":" OutputAPI Resource { &quot;@context&quot;: &quot;/contexts/User/Review&quot;, &quot;@id&quot;: &quot;/user/reviewsWithEmbeddedResource/018de474-1a23-7494-85f9-e92fb962d2a8&quot;, &quot;@type&quot;: &quot;User/Review&quot;, &quot;id&quot;: &quot;018de474-1a23-7494-85f9-e92fb962d2a8&quot;, &quot;body&quot;: &quot;Occaecati voluptate sed sed suscipit. Voluptas expedita quis molestias quam modi deleniti earum. Voluptas dolorem pariatur iusto quis. Rerum in quisquam nisi neque.&quot;, &quot;rating&quot;: 5, &quot;book&quot;: { &quot;@id&quot;: &quot;/user/books/018de474-1a2a-7975-87bb-5944ee8ee95f&quot;, &quot;@type&quot;: &quot;User/Book&quot;, &quot;id&quot;: &quot;018de474-1a2a-7975-87bb-5944ee8ee95f&quot;, &quot;title&quot;: &quot;Saepe enim sint culpa fuga.&quot;, &quot;description&quot;: &quot;Ad cupiditate asperiores quas quis non facere nam. Fugit praesentium natus aut error perspiciatis quo. Iusto dolores quaerat quibusdam qui praesentium.&quot;, &quot;reviews&quot;: &quot;/user/books/018de474-1a2a-7975-87bb-5944ee8ee95f/reviews&quot; } }  ","version":"Next","tagName":"h2"},{"title":"rekalogika/collections","type":0,"sectionRef":"#","url":"/collections","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/collections","url":"/collections#sections","content":" üìÑÔ∏è Introduction Pragmatic, opinionated enhancements to Doctrine's Collections library. Improves üìÑÔ∏è Interfaces Interfaces provided by this package. üóÉÔ∏è Implementations 4 items üóÉÔ∏è Behaviors 8 items üóÉÔ∏è Miscellaneous 1 item ","version":"Next","tagName":"h2"},{"title":"GET Endpoint for a Subresource","type":0,"sectionRef":"#","url":"/api-lite/subresource/get-subresource","content":"GET Endpoint for a Subresource API ResourceState Provider src/ApiResource/User/ReviewDto.php namespace App\\ApiResource\\User; use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\GetCollection; use ApiPlatform\\Metadata\\Link; use App\\ApiState\\User\\Review\\BookReviewCollectionProvider; use App\\ApiState\\User\\Review\\BookReviewProvider; #[ApiResource( shortName: 'User/Review', routePrefix: '/user', operations: [ // ... new Get( uriTemplate: '/books/{bookId}/reviews/{id}', provider: BookReviewProvider::class, uriVariables: [ 'bookId' =&gt; new Link( fromClass: BookDto::class, ) ], ), // ... ] )] class ReviewDto { // ... } ","keywords":"","version":"Next"},{"title":"Behaviors","type":0,"sectionRef":"#","url":"/collections/behaviors","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"Behaviors","url":"/collections/behaviors#sections","content":" üìÑÔ∏è Potential Out-of-Memory Handling Problem üìÑÔ∏è Iterating Large Collections Problem üìÑÔ∏è Slow Counting Problem üìÑÔ∏è Selectable Abstraction Leak Problem üìÑÔ∏è Key Type Widening Problem üìÑÔ∏è UI and API Pagination All of our classes implement PageableInterface from our üìÑÔ∏è Class Arguments Our classes accept arguments in their constructors. Different classes may or üìÑÔ∏è Compatibility with Original Doctrine Collection ","version":"Next","tagName":"h2"},{"title":"Referencing a Collection of Subresources","type":0,"sectionRef":"#","url":"/api-lite/subresource/referencing-collection-subresource","content":"","keywords":"","version":"Next"},{"title":"Using a Collection of IRIs‚Äã","type":1,"pageTitle":"Referencing a Collection of Subresources","url":"/api-lite/subresource/referencing-collection-subresource#using-a-collection-of-iris","content":" By default, API Platform will use a collection of the IRI of the subresource objects. But, if you want this style, we recommend setting it explicitly using#[ApiProperty(readableLink: false)].  OutputAPI Resource { &quot;@context&quot;: &quot;/contexts/User/Book&quot;, &quot;@id&quot;: &quot;/user/books/018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot;, &quot;@type&quot;: &quot;User/Book&quot;, &quot;id&quot;: &quot;018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot;, &quot;title&quot;: &quot;Some Book&quot;, &quot;description&quot;: &quot;Eligendi sunt explicabo quae qui omnis expedita et. Et incidunt earum recusandae itaque recusandae. Ipsam id id qui.&quot;, &quot;reviews&quot;: [ &quot;/user/reviews/018dda4b-19a5-7ac7-824d-caa21760643a&quot;, &quot;/user/reviews/018dda4b-19a7-716a-94e0-2d6704a564d5&quot;, &quot;/user/reviews/018dda4b-19aa-7336-af9b-dbaf19d7e744&quot;, ] }   ","version":"Next","tagName":"h2"},{"title":"Using a Collection of Embedded Resources‚Äã","type":1,"pageTitle":"Referencing a Collection of Subresources","url":"/api-lite/subresource/referencing-collection-subresource#using-a-collection-of-embedded-resources","content":" OutputAPI Resource { &quot;@context&quot;: &quot;/contexts/User/Book&quot;, &quot;@id&quot;: &quot;/user/books/018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot;, &quot;@type&quot;: &quot;User/Book&quot;, &quot;id&quot;: &quot;018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot;, &quot;title&quot;: &quot;Some Book&quot;, &quot;description&quot;: &quot;Eligendi sunt explicabo quae qui omnis expedita et. Et incidunt earum recusandae itaque recusandae. Ipsam id id qui.&quot;, &quot;reviews&quot;: [ { &quot;@id&quot;: &quot;/user/reviews/018dda4b-19a5-7ac7-824d-caa21760643a&quot;, &quot;@type&quot;: &quot;User/Review&quot;, &quot;id&quot;: &quot;018dda4b-19a5-7ac7-824d-caa21760643a&quot;, &quot;body&quot;: &quot;Ut esse esse ea qui. Placeat esse deleniti et est. Deserunt est architecto et et.&quot;, &quot;rating&quot;: 3, &quot;book&quot;: &quot;/user/books/018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot; }, // ... ] }   ","version":"Next","tagName":"h2"},{"title":"Using the IRI of the Collection‚Äã","type":1,"pageTitle":"Referencing a Collection of Subresources","url":"/api-lite/subresource/referencing-collection-subresource#using-the-iri-of-the-collection","content":" If your resource has a lot of subresources, you might want to change it to use the IRI of the collection instead.  OutputAPI Resource { &quot;@context&quot;: &quot;/contexts/User/Book&quot;, &quot;@id&quot;: &quot;/user/books/018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot;, &quot;@type&quot;: &quot;User/Book&quot;, &quot;id&quot;: &quot;018dda4b-19be-7ad3-9eb4-b56e253e9c54&quot;, &quot;title&quot;: &quot;Some Book&quot;, &quot;description&quot;: &quot;Eligendi sunt explicabo quae qui omnis expedita et. Et incidunt earum recusandae itaque recusandae. Ipsam id id qui.&quot;, &quot;reviews&quot;: &quot;/user/books/018dda4b-19be-7ad3-9eb4-b56e253e9c54/reviews&quot; }  ","version":"Next","tagName":"h2"},{"title":"Class Arguments","type":0,"sectionRef":"#","url":"/collections/behaviors/class-arguments","content":"","keywords":"","version":"Next"},{"title":"The Arguments‚Äã","type":1,"pageTitle":"Class Arguments","url":"/collections/behaviors/class-arguments#the-arguments","content":" ","version":"Next","tagName":"h2"},{"title":"orderBy‚Äã","type":1,"pageTitle":"Class Arguments","url":"/collections/behaviors/class-arguments#orderby","content":" The orderBy argument is used to sort the collection. It accepts one of the following values:  string means the column name to sort by.array&lt;string,Order&gt;. The key means the column names to sort, the value is the order to sort by.null means use the default order by.  ","version":"Next","tagName":"h3"},{"title":"indexBy‚Äã","type":1,"pageTitle":"Class Arguments","url":"/collections/behaviors/class-arguments#indexby","content":" The indexBy argument is used to determine the field of the object used as the key of the collection. It accepts string, meaning the column name to index by. If null, the default is used. If the default is null, then the collection will be a list.  ","version":"Next","tagName":"h3"},{"title":"itemsPerPage‚Äã","type":1,"pageTitle":"Class Arguments","url":"/collections/behaviors/class-arguments#itemsperpage","content":" The number of items in a page when using pagination. It accepts an integer. It can be overridden post-instantiation using withItemsPerPage().  ","version":"Next","tagName":"h3"},{"title":"count‚Äã","type":1,"pageTitle":"Class Arguments","url":"/collections/behaviors/class-arguments#count","content":" The count strategy to use. Accepts a CountStrategy instance. Read more about count strategies in the Counting section.  ","version":"Next","tagName":"h3"},{"title":"pagination‚Äã","type":1,"pageTitle":"Class Arguments","url":"/collections/behaviors/class-arguments#pagination","content":" The pagination type to use. Either Pagination::Keyset or Pagination::Offset. Defaults to Pagination::Keyset.  You should almost always use Pagination::Keyset. However, there are cases where Pagination::Offset might be required, for example, when paginating a search result ordered by search ranking.  ","version":"Next","tagName":"h3"},{"title":"softLimit and hardLimit‚Äã","type":1,"pageTitle":"Class Arguments","url":"/collections/behaviors/class-arguments#softlimit-and-hardlimit","content":" The softLimit and hardLimit arguments are used to limit the number of results returned. The softLimit is the maximum number of results before the collection will give you a deprecation warning. The hardLimit is the maximum number of results before the collection will throw an exception. Read more about limits in the Potential Out-of-Memory Handling section.  ","version":"Next","tagName":"h3"},{"title":"keyTransformer‚Äã","type":1,"pageTitle":"Class Arguments","url":"/collections/behaviors/class-arguments#keytransformer","content":" Accepts a KeyTransformer object used to transform the key before passing it to the underlying Collection. Read more about it in the Key Type Widening section.  ","version":"Next","tagName":"h3"},{"title":"Changing the Default Argument Values‚Äã","type":1,"pageTitle":"Class Arguments","url":"/collections/behaviors/class-arguments#changing-the-default-argument-values","content":" The default argument values can be changed by setting the static properties ofConfiguration.  To change the default value, for example, you can do it in one of these following places:  In your application's kernel.Using composer.json's files autoloading mechanism.In index.php. ","version":"Next","tagName":"h2"},{"title":"Compatibility with Original Doctrine Collection","type":0,"sectionRef":"#","url":"/collections/behaviors/compatibility","content":"Compatibility with Original Doctrine Collection","keywords":"","version":"Next"},{"title":"Key Type Widening","type":0,"sectionRef":"#","url":"/collections/behaviors/key-type-widening","content":"","keywords":"","version":"Next"},{"title":"Problem‚Äã","type":1,"pageTitle":"Key Type Widening","url":"/collections/behaviors/key-type-widening#problem","content":" warning Previously, this feature is used to convert UUID objects to string before it is used as a key in a Collection. Unfortunately, we found out afterward that Doctrine's behavior regarding UUID keys is undefined and inconsistent. For example, UUID primary keys is converted into 8-4-4-4-12 format with PostgreSQL, but become binary strings with SQLite. We retain this feature because there are other benefits to it.  The keys in Doctrine Collection can only be int|string. On the other hand, Doctrine supports objects, like UUIDs, as primary keys. Therefore, callers need to convert objects to the expected string format before using them as keys in a Collection, especially if strict_types is enabled.  In some cases, passing UUIDs in the wrong format will give us 500 errors because the database doesn't like it. They should be 404 errors instead.  In some cases, the caller cannot know the type of the key, and must perform type checking to ensure it is int|string before using it in a Collection. This result in unnecessary boilerplate code.  ","version":"Next","tagName":"h2"},{"title":"Solution‚Äã","type":1,"pageTitle":"Key Type Widening","url":"/collections/behaviors/key-type-widening#solution","content":" Our interfaces extends Collection and overrides the following methods to widen the key type to mixed:  containsKey($key)get($key)remove($key)set($key, $value)offsetExists($key)offsetGet($key)offsetSet($key, $value)offsetUnset($key)  Then, the object is converted to string and passed to the underlyingCollection. If it is not possible, our classes will throw an exception, which will become a 404 error.  The above is the default behavior as defined in DefaultKeyTransformer. The behavior can be changed using the argument $keyTransformer in any of our classes. The default behavior can be changed by settingConfiguration::$defaultKeyTransformer. A custom behavior can be created by implementing the KeyTransformer interface.  The library also ships with UuidKeyTransformer. It ensures the input is in the correct UUID format before passing it to the underlying Collection. If not in the correct format, it will throw an exception. ","version":"Next","tagName":"h2"},{"title":"Iterating Large Collections","type":0,"sectionRef":"#","url":"/collections/behaviors/iterator","content":"","keywords":"","version":"Next"},{"title":"Problem‚Äã","type":1,"pageTitle":"Iterating Large Collections","url":"/collections/behaviors/iterator#problem","content":" Using foreach() directly on a large collection will trigger full initialization of the collection, and can cause an out-of-memory error.  Doctrine Collection does provide the slice() method to paginate the collection. However it uses offset pagination that has these drawbacks:  With a large collection, it will become slower and slower as you go further away from the start.If the underlying data changes while you are iterating it, the entire set will drift, and the iteration is going to miss or duplicate some records. It basically will only work on static data.slice() is rather low level. You need to supply the iterating logic yourself.  ","version":"Next","tagName":"h2"},{"title":"Solution‚Äã","type":1,"pageTitle":"Iterating Large Collections","url":"/collections/behaviors/iterator#solution","content":" foreach()-ing a collection from this package is subject to $softLimit and$hardLimit checks as described in the Potential Out-of-Memory Handling section. It will stop you before it becomes an out-of-memory problem.  All of our classes implement higher-level PageableInterface from ourrekalogika/rekapager-contracts which add keyset pagination feature to the underlying data. Unlike offset pagination, keyset pagination does not have the aforementioned drawbacks.  To iterate over a large collection, you can simply do this:  use Doctrine\\ORM\\EntityManagerInterface; use Rekalogika\\Rekapager\\PageableInterface; /** @var EntityManagerInterface $entityManager */ // $collection is any collection object from this package foreach ($collection-&gt;withItemsPerPage(1000)-&gt;getPages() as $page) { foreach ($page as $entity) { // Do something with the $entity } // Do something after each page here // With Doctrine, you'd usually want to flush() and clear() here $entityManager-&gt;flush(); // if required $entitymanager-&gt;clear(); }   There is no need to create ad-hoc queries every time you need to perform safe iteration over a large collection.  For more information about batch processing using PageableInterface, seeBatch Processing. ","version":"Next","tagName":"h2"},{"title":"Slow Counting","type":0,"sectionRef":"#","url":"/collections/behaviors/counting","content":"","keywords":"","version":"Next"},{"title":"Problem‚Äã","type":1,"pageTitle":"Slow Counting","url":"/collections/behaviors/counting#problem","content":" If the number of records is large, the database might struggle in counting the records. Consequently, callingcount($collection) or $collection-&gt;count() or collection|length on a large, extra-lazy Doctrine Collection can be very slow because it becomes a COUNT()query behind the scenes.  ","version":"Next","tagName":"h2"},{"title":"Default Behavior‚Äã","type":1,"pageTitle":"Slow Counting","url":"/collections/behaviors/counting#default-behavior","content":" Our classes offer pluggable counting strategy.  The default counting strategy for full classes is SafeDelegatedCountStrategy. It delegates the count to the underlying collection, as with regular collections, with these caveats:  If the result count exceeds 5000, it will give a deprecation warning.If the result count exceeds 50000, it will throw an exception.If the count duration exceeds 2 seconds, it will give a deprecation warning.  The threshold can be changed in Configuration globally, or by providing the arguments in the constructor of the strategy.  Our minimal classes use DisabledCountStrategy. See the corresponding explanation below.  ","version":"Next","tagName":"h2"},{"title":"What to Do After the Threshold is Reached‚Äã","type":1,"pageTitle":"Slow Counting","url":"/collections/behaviors/counting#what-to-do-after-the-threshold-is-reached","content":" ","version":"Next","tagName":"h2"},{"title":"Change the Counting Strategy‚Äã","type":1,"pageTitle":"Slow Counting","url":"/collections/behaviors/counting#change-the-counting-strategy","content":" All of our classes provide pluggable strategy for handling the count()operation. You can change how the count is calculated by switching the strategy, or use your own counting strategy. Read the next section for more information.  ","version":"Next","tagName":"h3"},{"title":"Switch to the Corresponding Minimal Class‚Äã","type":1,"pageTitle":"Slow Counting","url":"/collections/behaviors/counting#switch-to-the-corresponding-minimal-class","content":" As an alternative to switching the counting strategy, you also have the option to switch to the minimal version of the class if you don't really need the count operation.  Our minimal classes do not implement Countable. So, you can run static analysis to easily find out the parts of your code that still call the count()on your collection, and clean them up.  ","version":"Next","tagName":"h3"},{"title":"Changing the Counting Strategy‚Äã","type":1,"pageTitle":"Slow Counting","url":"/collections/behaviors/counting#changing-the-counting-strategy","content":" To change the counting strategy, provide the strategy in the $count argument when creating the collection. Example:  use Rekalogika\\Contracts\\Collections\\Recollection; use Rekalogika\\Domain\\Collections\\Common\\Count\\ZeroCountStrategy; use Rekalogika\\Domain\\Collections\\RecollectionDecorator; class Country { /** * @var Collection&lt;int,Citizen&gt; */ private Collection $citizen; private int $citizenCount = 0; /** * @return Recollection&lt;int,Citizen&gt; */ public function getCitizens(): Recollection { return RecollectionDecorator::create( collection: $this-&gt;citizen, indexBy: 'id', count: new ZeroCountStrategy() ); } }   ","version":"Next","tagName":"h2"},{"title":"Available Counting Strategies‚Äã","type":1,"pageTitle":"Slow Counting","url":"/collections/behaviors/counting#available-counting-strategies","content":" SafeDelegatedCountStrategy: The default, delegates the count to the underlying collection with exceptions described above.DelegatedCountStrategy: Delegates the count to the underlying collection without any checks. This strategy provides the same behavior as the originalCollection.DisabledCountStrategy: Disables the count operation. Throws an exception if the count is called.PrecountingStrategy: Saves and restores the count to another property. See the section below for more information.ZeroCountStrategy: Always returns 0 as the count.  You can create your own counting strategy by implementing the interfaceCountStrategy.  ","version":"Next","tagName":"h2"},{"title":"Precounting Strategy‚Äã","type":1,"pageTitle":"Slow Counting","url":"/collections/behaviors/counting#precounting-strategy","content":" Precounting strategy stores the precounted value in a separate property. If thecount() is called, it will return the precounted value. If therefreshCount() is called, it will recalculate the count from the underlying collection and store it in the property.  Usage example:  use Rekalogika\\Contracts\\Collections\\Recollection; use Rekalogika\\Domain\\Collections\\Common\\Count\\PrecountingStrategy; use Rekalogika\\Domain\\Collections\\RecollectionDecorator; class Country { /** * @var Collection&lt;int,Citizen&gt; */ private Collection $citizen; private int $citizenCount = 0; /** * @return Recollection&lt;int,Citizen&gt; */ public function getCitizens(): Recollection { return RecollectionDecorator::create( collection: $this-&gt;citizen, indexBy: 'id', count: new PrecountingStrategy($this-&gt;citizenCount) ); } }   The caller can count the records like the following, and it will use the number stored in $citizenCount as the result:  /** @var Country $country */ $count = $country-&gt;getCitizens()-&gt;count(); // or $count =count($country-&gt;getCitizens());   When it is necessary to refresh the pre-counted value, you can do this:  use Doctrine\\ORM\\EntityManagerInterface; /** @var EntityManagerInterface $entityManager */ $country-&gt;getCitizens()-&gt;refreshCount(); $entityManager-&gt;flush();   ","version":"Next","tagName":"h2"},{"title":"Pagination is Possible Without the Total Count‚Äã","type":1,"pageTitle":"Slow Counting","url":"/collections/behaviors/counting#pagination-is-possible-without-the-total-count","content":" All of our classes implement PageableInterface from ourrekalogika/rekapager-contracts package. This allows you to paginate the collection for user interface or API output.  Unlike traditional pagination, our PageableInterface does not need the count to perform pagination, and therefore remains performant even with huge collections. You can safely use DisabledCountStrategy on your collection and pagination will still work without any problem.  However, if your collection uses a counting strategy that does provide the count, the pagination will happily use it to improve the user experience.  ","version":"Next","tagName":"h2"},{"title":"Counting in Minimal Classes‚Äã","type":1,"pageTitle":"Slow Counting","url":"/collections/behaviors/counting#counting-in-minimal-classes","content":" Our minimal classes do not implement Countable. So, you cannot do a count()or -&gt;count() on their instances. However, they still retain the counting logic internally. You can use the method getTotalItems() to get the count result. Unlike Countable::count(), getTotalItems() may return null if the count is not known. ","version":"Next","tagName":"h2"},{"title":"UI and API Pagination","type":0,"sectionRef":"#","url":"/collections/behaviors/pagination","content":"","keywords":"","version":"Next"},{"title":"In Symfony Controller‚Äã","type":1,"pageTitle":"UI and API Pagination","url":"/collections/behaviors/pagination#in-symfony-controller","content":" Read more about the Symfony integration in the Symfony Integration section.  ","version":"Next","tagName":"h2"},{"title":"In API Platform State Provider‚Äã","type":1,"pageTitle":"UI and API Pagination","url":"/collections/behaviors/pagination#in-api-platform-state-provider","content":" Read more about the API Platform integration in the API Platform Integration section. ","version":"Next","tagName":"h2"},{"title":"Potential Out-of-Memory Handling","type":0,"sectionRef":"#","url":"/collections/behaviors/oom","content":"","keywords":"","version":"Next"},{"title":"Problem‚Äã","type":1,"pageTitle":"Potential Out-of-Memory Handling","url":"/collections/behaviors/oom#problem","content":" Doctrine ORM offers extra lazy collectionsto handle large sets of data. However, only a few methods are extra-lazy-safe. The following are the safe methods that will not trigger the full initialization of the collection, and won't cause out-of-memory errors with an extra-lazy collection:  contains($entity)containsKey($key) (only if indexBy is set)count()get($key) (only if indexBy is set)slice($offset, $length = null)add($entity)offsetSet($key, $entity) (only if $key is null)offsetExists($key) (only if indexBy is set)offsetGet($key) (only if indexBy is set)matching($criteria)  All the other methods not listed above are not safe. If a non-safe method is called, Doctrine will load the entire collection into memory, potentially causing out-of-memory errors. These errors can be very difficult to debug. It is difficult to catch in CI. And it often gets triggered in seemingly unrelated parts of the application.  And it can be all too easy to call the non-safe methods accidentally, giving us elusive errors that occur only in production, and never in the development environment.  The most common unsafe behaviors include:  Using foreach directly on the collection.Calling toArray().Calling filter(), map() or other similar methods.Calling removeElement($entity). This one is usually accidentally called because Symfony MakerBundle generates remover methods that callremoveElement().  ","version":"Next","tagName":"h2"},{"title":"Solution‚Äã","type":1,"pageTitle":"Potential Out-of-Memory Handling","url":"/collections/behaviors/oom#solution","content":" Our classes will pass the safe methods to the underlying collection unchanged. But if a non-safe method is called, rather than loading the entire set, it adds a LIMIT clause to the query. If the number of results exceeds 500, it gives a deprecation warning. If it exceeds 2000, the classes will throw an exception.  This behavior applies to the following classes:  RecollectionDecoratorCriteriaRecollectionAbstractRepositoryQueryRecollection  The thresholds can be changed by specifying the options $softLimit or$hardLimit in the constructor of the classes that have this behavior.  The default threshold can be changed by setting static properties$defaultSoftLimit and $defaultHardLimit in the Configuration class.  ","version":"Next","tagName":"h2"},{"title":"What to Do After the Threshold is Reached‚Äã","type":1,"pageTitle":"Potential Out-of-Memory Handling","url":"/collections/behaviors/oom#what-to-do-after-the-threshold-is-reached","content":" If you see the warning or exception, it means your code is loading too many entities at once, and you need to use a different approach to the problem.  To start, you can change your code to use the minimal flavor instead:  Change RecollectionDecorator to MinimalRecollectionDecoratorChange CriteriaRecollection to MinimalCriteriaRecollectionChange AbstractRepository to AbstractMinimalRepositoryChange QueryRecollection to QueryPageable  These minimal flavors should never trigger full load of the collection.  Then you can run a static analysis tool to find all the places that still call the non-safe methods. You can then refactor the code to use a different approach. If you need to iterate over it, read the Iterating Large Collections section. ","version":"Next","tagName":"h2"},{"title":"Selectable Abstraction Leak","type":0,"sectionRef":"#","url":"/collections/behaviors/selectable-leak","content":"","keywords":"","version":"Next"},{"title":"Problem‚Äã","type":1,"pageTitle":"Selectable Abstraction Leak","url":"/collections/behaviors/selectable-leak#problem","content":" Doctrine Collections classes implement Selectable interface. This is a powerful feature that allows filtering and sorting the collection. However, it is also an abstraction leak, and a popular one at that.  To use it, the caller might need to know the internal structure of the class. Without restraint, the knowledge about the internal structure of an entity might spread throughout the codebase. And updating the class can potentially break a lot of code.  ","version":"Next","tagName":"h2"},{"title":"Solution‚Äã","type":1,"pageTitle":"Selectable Abstraction Leak","url":"/collections/behaviors/selectable-leak#solution","content":" Our classes do not expose the Selectable interface. Instead, they can be easily extended. We can easily add expressive, higher-level methods to the class to provide the same functionality, but without exposing the inner workings of the class.  ","version":"Next","tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"Selectable Abstraction Leak","url":"/collections/behaviors/selectable-leak#example","content":" The following is an example of the problem. It is a problem because matching()is used outside the entity. It mentions the property 'age', which is almost always private.  /** @var Country $country */ $workingAgeCitizens = $country-&gt;getCitizens()-&gt;matching( Criteria::create() -&gt;where(Criteria::expr()-&gt;gte('age', 15)) -&gt;andWhere(Criteria::expr()-&gt;lte('age', 64)) );   In the future, we might rename the property. If that happens, we would need to scour the codebase to find all the places where 'age' is used, and update them accordingly.  Instead, we should aim to be able to write the above code like this:  /** @var Country $country */ $workingAgeCitizens = $country-&gt;getCitizens()-&gt;inWorkingAge();   To achieve that, we can extend one of our decorator class like this:  use Rekalogika\\Domain\\Collections\\RecollectionDecorator; use Rekalogika\\Contracts\\Collections\\ReadableRecollection; /** * @extends RecollectionDecorator&lt;int,Citizen&gt; */ class CitizenCollection extends RecollectionDecorator { public function inWorkingAge(): ReadableRecollection { $criteria = $this-&gt;matching( Criteria::create() -&gt;where(Criteria::expr()-&gt;gte('age', 15)) -&gt;andWhere(Criteria::expr()-&gt;lte('age', 64)) ); return $this-&gt;createCriteriaRecollection( criteria: $criteria, instanceId: __METHOD__, ); } }   Then, we can use the CitizenCollection class in our Country class:  use Rekalogika\\Contracts\\Collections\\ReadableRecollection; class Country { public function getCitizens(): CitizenCollection { return new CitizenCollection( collection: $this-&gt;citizen, indexBy: 'id' ); } }  ","version":"Next","tagName":"h2"},{"title":"Implementations","type":0,"sectionRef":"#","url":"/collections/implementations","content":"","keywords":"","version":"Next"},{"title":"Summary‚Äã","type":1,"pageTitle":"Implementations","url":"/collections/implementations#summary","content":" Underlying object\tFull flavor\tMinimal flavor\tExtra-Minimal flavorCollection\tRecollectionDecorator\tMinimalRecollectionDecorator Collection + Criteria\tCriteriaRecollection\tMinimalCriteriaRecollection ManagerRegistry\tAbstractRepository\tAbstractMinimalRepository QueryBuilder\tQueryRecollection QueryPageable  ","version":"Next","tagName":"h2"},{"title":"Sections‚Äã","type":1,"pageTitle":"Implementations","url":"/collections/implementations#sections","content":" üìÑÔ∏è Collection Decorators Classes that decorate any Doctrine Collection object and transform it into a üìÑÔ∏è Query-Backed Collection A collection class using Doctrine ORM QueryBuilder as the data source. Unlike üìÑÔ∏è Repository An implementation of the repository pattern. This is an alternative to üìÑÔ∏è ArrayCollection Modification to Doctrine's ArrayCollection, so that it does matching() ","version":"Next","tagName":"h2"},{"title":"ArrayCollection","type":0,"sectionRef":"#","url":"/collections/implementations/array-collection","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"ArrayCollection","url":"/collections/implementations/array-collection#installation","content":" composer require rekalogika/collections-domain   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"ArrayCollection","url":"/collections/implementations/array-collection#usage","content":" Simply substitute Doctrine\\Common\\Collections\\ArrayCollection withRekalogika\\Domain\\Collections\\ArrayCollection:  - use Doctrine\\Common\\Collections\\ArrayCollection; + use Rekalogika\\Domain\\Collections\\ArrayCollection;   It should be safe to do a mass find-and-replace in all of your entities.  ","version":"Next","tagName":"h2"},{"title":"Description‚Äã","type":1,"pageTitle":"ArrayCollection","url":"/collections/implementations/array-collection#description","content":" Doctrine entities usually initialize a Collection using ArrayCollection in their constructors. But when the entity is hydrated from the database, Doctrine ORM will inject a PersistentCollection directly into the property.  If we call matching() against the PersistentCollection, it will be done against the related entities' private properties directly. WhileArrayCollection does it against the return values of the getters.  Therefore, there will be a 'mismatching' in the collection's behavior between when the owning entity is new and not yet persisted, and after it is hydrated from the database.  The problem happens when, for example:  The property does not have a getter, orThe getter returns a different value or different type from the property's value, orThe getter contains business logic, and does not return the property's value as is.  The problem usually happens with new, not-yet-persisted entities, and in unit tests where the tests don't involve the database.  Our ArrayCollection changes the behavior so that it does the matching()against the private properties directly, so that both Collections will have the same behavior.  ","version":"Next","tagName":"h2"},{"title":"Limitation‚Äã","type":1,"pageTitle":"ArrayCollection","url":"/collections/implementations/array-collection#limitation","content":" This problem will also happen when fetch set to EAGER, or when the collection is initialized before the matching() is called. Unfortunately, it is impossible to work around this problem outside Doctrine.  However, if you can afford to fetch the collection eagerly, then you can afford to use filter() instead. Unlike matching(), filter() is always consistent in every cases.  ","version":"Next","tagName":"h2"},{"title":"Example‚Äã","type":1,"pageTitle":"ArrayCollection","url":"/collections/implementations/array-collection#example","content":" The following classes implement the null object pattern. If thenationality property is null, it will return an instance of Statelessinstead of null:  use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; class Country {} class Stateless extends Country {} class Player { public function __construct( private string $name, private Team $team, private ?Country $nationality = null, ) { } public function getName(): string { return $this-&gt;name; } public function getTeam(): Team { return $this-&gt;team; } public function getNationality(): Country { return $this-&gt;country ?? new Stateless(); } } class Team { /** @var Collection&lt;int,Player&gt; */ private Collection $players; public function __construct() { $this-&gt;players = new ArrayCollection(); } /** * @return Collection&lt;int,Player&gt; */ public function getPlayers(): Collection { return $this-&gt;players; } public function getStatelessPlayers(): Collection { return $this-&gt;players-&gt;matching( Criteria::create() -&gt;where(Criteria::expr()-&gt;isNull('nationality')) ); }   If the Team is not yet persisted, the getStatelessPlayers() method will incorrectly return an empty collection every time. But if the Team object is hydrated from the database, it will correctly return the players without a nationality.  Changing the code to use Rekalogika\\Domain\\Collections\\ArrayCollection will resolve the problem. ","version":"Next","tagName":"h2"},{"title":"Query-Backed Collection","type":0,"sectionRef":"#","url":"/collections/implementations/query-collection","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Query-Backed Collection","url":"/collections/implementations/query-collection#installation","content":" composer require rekalogika/collections-orm   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Query-Backed Collection","url":"/collections/implementations/query-collection#usage","content":" use Rekalogika\\Collections\\ORM\\QueryRecollection; $queryBuilder = ... // create a QueryBuilder instance $collection = new QueryRecollection( queryBuilder: $queryBuilder, indexBy: 'id' ); // use $collection like a regular Collection or Recollection   ","version":"Next","tagName":"h2"},{"title":"The Minimal Flavor‚Äã","type":1,"pageTitle":"Query-Backed Collection","url":"/collections/implementations/query-collection#the-minimal-flavor","content":" The minimal version of QueryRecollection is QueryPageable, which implementsPageableRecollection. Simply replace QueryRecollection with QueryPageable in the example above.  ","version":"Next","tagName":"h2"},{"title":"Extending QueryRecollection‚Äã","type":1,"pageTitle":"Query-Backed Collection","url":"/collections/implementations/query-collection#extending-queryrecollection","content":" TBD ","version":"Next","tagName":"h2"},{"title":"Collection Decorators","type":0,"sectionRef":"#","url":"/collections/implementations/decorators","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Collection Decorators","url":"/collections/implementations/decorators#installation","content":" composer require rekalogika/collections-domain   ","version":"Next","tagName":"h2"},{"title":"RecollectionDecorator Usage Example‚Äã","type":1,"pageTitle":"Collection Decorators","url":"/collections/implementations/decorators#recollectiondecorator-usage-example","content":" If you have this in your entity:  use Doctrine\\Common\\Collections\\Collection; class Country { /** * @var Collection&lt;int,Citizen&gt; */ private Collection $citizen; /** * @return Collection&lt;int,Citizen&gt; */ public function getCitizens(): Collection { return $this-&gt;citizen; } }   You can change it to:  use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\Contracts\\Collections\\Recollection; use Rekalogika\\Domain\\Collections\\RecollectionDecorator; class Country { /** * @var Collection&lt;int,Citizen&gt; */ private Collection $citizen; /** * @return Recollection&lt;int,Citizen&gt; */ public function getCitizens(): Recollection { return RecollectionDecorator::create( collection: $this-&gt;citizen, indexBy: 'id' ); } }   ","version":"Next","tagName":"h2"},{"title":"CriteriaRecollection Usage Example‚Äã","type":1,"pageTitle":"Collection Decorators","url":"/collections/implementations/decorators#criteriarecollection-usage-example","content":" If you have this in your entity:  use Doctrine\\Common\\Collections\\Criteria; use Doctrine\\Common\\Collections\\ReadableCollection; class Country { /** * @return ReadableCollection&lt;int,Citizen&gt; */ public function getWorkingAgeCitizens(): ReadableCollection { $criteria = Criteria::create() -&gt;where(Criteria::expr()-&gt;gte('age', 15)) -&gt;andWhere(Criteria::expr()-&gt;lte('age', 64)); return $this-&gt;citizen-&gt;matching($criteria); } }   You can change it to:  use Rekalogika\\Domain\\Collections\\CriteriaRecollection; use Rekalogika\\Contracts\\Collections\\ReadableRecollection; class Country { /** * @return ReadableRecollection&lt;int,Citizen&gt; */ public function getWorkingAgeCitizens(): ReadableRecollection { $criteria = Criteria::create() -&gt;where(Criteria::expr()-&gt;gte('age', 15)) -&gt;andWhere(Criteria::expr()-&gt;lte('age', 64)); return CriteriaRecollection::create( collection: $this-&gt;citizen, criteria: $criteria, indexBy: 'id', instanceId: __METHOD__ ); } }   ","version":"Next","tagName":"h2"},{"title":"The Minimal Flavors‚Äã","type":1,"pageTitle":"Collection Decorators","url":"/collections/implementations/decorators#the-minimal-flavors","content":" If you want to use the minimal version of the decorators, you can substitute:  Recollection with MinimalRecollectionReadableRecollection with MinimalReadableRecollectionRecollectionDecorator with MinimalRecollectionDecoratorCriteriaRecollection with MinimalCriteriaRecollection  ","version":"Next","tagName":"h2"},{"title":"Instance Caching‚Äã","type":1,"pageTitle":"Collection Decorators","url":"/collections/implementations/decorators#instance-caching","content":" The decorator classes cache their instances. If you try to instantiate the decorator the second time with the same arguments, it will return the same instance. Therefore, you don't need to implement the caching yourself.  CriteriaRecollection, MinimalCriteriaRecollection and CriteriaPageable may need the $instanceId argument to distinguish between different instances. If omitted, the classes will use the serialization of the criteria as the instance ID, which might be unreliable if the criteria has a reference to an entity.  ","version":"Next","tagName":"h2"},{"title":"Extending Decorators‚Äã","type":1,"pageTitle":"Collection Decorators","url":"/collections/implementations/decorators#extending-decorators","content":" TBD ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/collections/intro","content":"","keywords":"","version":"Next"},{"title":"Background‚Äã","type":1,"pageTitle":"Introduction","url":"/collections/intro#background","content":" We work with huge datasets that are managed by Doctrine ORM, and have complex business rules. These come with these challenges:  With standard Doctrine, it seems it is too easy to introduce bugs that will accidentally load the entire dataset into memory and cause out-of-memory errors. And these sorts of errors will usually only show up in production, but never in the development environment. Iterating over large datasets with the correct method is difficult and cumbersome. You usually need to devise custom solutions for each use case. Counting the number of records is very slow. Sometimes we can do away with the count, sometimes it is a must, and we need to work around the problem.  Other, non-performance issues include:  Doctrine's Selectable appears to be a prevalent abstraction leak. Coders tend to litter the codebase with internal-revealing Criteria objects, and updating the entity can potentially become a nightmare. No static analysis tool can currently detect this problem. In fact, some exacerbate the problem by assuming a Collection must also be a Selectable.  Previously, we created rekalogika/doctrine-collections-decorator to solve these problems. However, it is still too cumbersome because we need to approach the problem one at a time. We need a more comprehensive solution.  ","version":"Next","tagName":"h2"},{"title":"Components‚Äã","type":1,"pageTitle":"Introduction","url":"/collections/intro#components","content":" Decorator classes that enhance any Doctrine Collections classes.Query-backed collections. Turns a QueryBuilder into a lazy-loading collection.An alternative implementation of the repository pattern that implementsCollection.Modifications to ArrayCollection that does matching() against the private properties directly, to reproduce the same behavior of PersistentCollection.  ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction","url":"/collections/intro#features","content":" Safeguards against potential out-of-memory situations. Throws an exception before it hits harder-to-debug out-of-memory situation.Pluggable counting strategies. Work around long counting times using your own counting strategies.Full versions of the collection classes that offer full compatibility with the original Doctrine Collection. And the minimal flavors that only expose the safe methods.Built in keyset pagination usingrekalogika/rekapager library. Iterate over collections of any size without loading them all into memory. And without having to create ad-hoc queries every time you need to achieve that.Option to use the traditional offset pagination instead of keyset pagination.Keyset pagination can also be used to create pagination for user interfaces and API outputs.Encourages you to create expressive, higher-level methods to provide the same functionality as the Selectable interface, but without exposing the inner workings of the class.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction","url":"/collections/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/collections/intro#contributing","content":" Issues and pull requests should be filed in the GitHub repositoryrekalogika/collections. ","version":"Next","tagName":"h2"},{"title":"Miscellaneous","type":0,"sectionRef":"#","url":"/collections/misc","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"Miscellaneous","url":"/collections/misc#sections","content":" üìÑÔ∏è UUID Primary Keys If you need UUID primary keys, we highly recommend using string-based UUIDs ","version":"Next","tagName":"h2"},{"title":"Repository","type":0,"sectionRef":"#","url":"/collections/implementations/repository","content":"","keywords":"","version":"Next"},{"title":"Why?‚Äã","type":1,"pageTitle":"Repository","url":"/collections/implementations/repository#why","content":" Why not? A repository is essentially a collection of entities. It makes sense to implement it as just another collection, having the same behavior as any other collection.  Your CitizenRepository will work practically the same way as$country-&gt;getCitizens(), except that the former contains all citizens, while the latter contains citizens of a specific country.  ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Repository","url":"/collections/implementations/repository#installation","content":" composer require rekalogika/collections-orm   ","version":"Next","tagName":"h2"},{"title":"Creating a Repository‚Äã","type":1,"pageTitle":"Repository","url":"/collections/implementations/repository#creating-a-repository","content":" Repository interface:  use Rekalogika\\Contracts\\Collections\\Repository; /** * @extends Repository&lt;int,Citizen&gt; */ interface CitizenRepository extends Repository { // you may wish to add custom methods here }   Repository implementation:  use Rekalogika\\Collections\\ORM\\AbstractRepository; use Rekalogika\\Collections\\ORM\\Configuration\\RepositoryConfiguration; /** * @extends AbstractRepository&lt;int,Citizen&gt; */ class CitizenRepositoryImplementation extends AbstractRepository implements CitizenRepository { public function __construct(ManagerRegistry $managerRegistry) { parent::__construct( managerRegistry: $managerRegistry, class: Citizen::class, ); } // you may wish to add custom methods here }   info Technically, it is not strictly required to create the interface for the repository. You can just create the implementation class. Creating the interface is a common practice in domain-driven design (DDD). The interface belongs to the domain layer, while the implementation belongs to the infrastructure layer. Other components of the application work with the interface, not the implementation directly.  ","version":"Next","tagName":"h2"},{"title":"The Minimal Flavor‚Äã","type":1,"pageTitle":"Repository","url":"/collections/implementations/repository#the-minimal-flavor","content":" If you want to use the minimal version of the repository, you can substitute:  Repository with MinimalRepositoryAbstractRepository with AbstractMinimalRepositoryRepositoryConfiguration with MinimalRepositoryConfiguration  ","version":"Next","tagName":"h2"},{"title":"Convenience Methods‚Äã","type":1,"pageTitle":"Repository","url":"/collections/implementations/repository#convenience-methods","content":" The base AbstractRepository class provides convenience methods to be called by the methods in the concrete repository implementation:  getEntityManager()createQueryBuilder()getDoctrineRepository()createCriteriaRecollection()createCriteriaPageable()createQueryRecollection()createQueryPageable()  ","version":"Next","tagName":"h2"},{"title":"Migrating from Doctrine's Repository‚Äã","type":1,"pageTitle":"Repository","url":"/collections/implementations/repository#migrating-from-doctrines-repository","content":" ","version":"Next","tagName":"h2"},{"title":"Persisting an entity‚Äã","type":1,"pageTitle":"Repository","url":"/collections/implementations/repository#persisting-an-entity","content":"  use Doctrine\\ORM\\EntityManagerInterface; /** * @var EntityRepository $repository This is an implementation of the repository * mentioned in this document. */ /** @var EntityManagerInterface $entityManager */ $entity = new Entity(); - $entityManager-&gt;persist($entity); + $repository-&gt;add($entity); $entityManager-&gt;flush();   ","version":"Next","tagName":"h3"},{"title":"Retrieving an entity‚Äã","type":1,"pageTitle":"Repository","url":"/collections/implementations/repository#retrieving-an-entity","content":"  use Doctrine\\ORM\\EntityManagerInterface; use Doctrine\\ORM\\EntityRepository; /** * @var EntityRepository $repository This is an implementation of the repository * mentioned in this document. */ /** @var EntityManagerInterface $entityManager */ /** @var EntityRepository&lt;Entity&gt; $doctrineRepository */ - $entity = $entityManager-&gt;find(Entity::class, $id); - // or - $entity = $doctrineRepository-&gt;find($id); + $entity = $repository-&gt;get($id); + // alternative that throws an exception if the entity is not found: + $entity = $repository-&gt;fetch($id);   ","version":"Next","tagName":"h3"},{"title":"Removing an entity‚Äã","type":1,"pageTitle":"Repository","url":"/collections/implementations/repository#removing-an-entity","content":"  use Doctrine\\ORM\\EntityManagerInterface; /** * @var EntityRepository $repository This is an implementation of the repository * mentioned in this document. */ /** @var EntityManagerInterface $entityManager */ /** @var Entity $entity */ - $entityManager-&gt;remove($entity); + $repository-&gt;removeElement($entity); $entityManager-&gt;flush();   ","version":"Next","tagName":"h3"},{"title":"Iterating All Entities‚Äã","type":1,"pageTitle":"Repository","url":"/collections/implementations/repository#iterating-all-entities","content":"  use Doctrine\\ORM\\EntityManagerInterface; use Doctrine\\ORM\\EntityRepository; /** * @var EntityRepository $repository This is an implementation of the repository * mentioned in this document. */ /** @var EntityManagerInterface $entityManager */ /** @var EntityRepository&lt;Entity&gt; $doctrineRepository */ - $entities = $doctrineRepository-&gt;findAll(); - foreach ($entities as $entity) { - // do something - } + // non-minimal flavor only: + foreach ($repository as $entity) { + // do something + } + + // all flavors, iterating in batches, should never trigger out-of-memory + // situation: + foreach ($repository-&gt;withItemsPerPage(1000)-&gt;getPages() as $page) { + foreach ($page as $entity) { + // do something + } + $entityManager-&gt;clear(); + }   ","version":"Next","tagName":"h3"},{"title":"Coexisting with Doctrine's Standard Repository‚Äã","type":1,"pageTitle":"Repository","url":"/collections/implementations/repository#coexisting-with-doctrines-standard-repository","content":" It should be technically possible to implement this repository in the same class as Doctrine's standard repository, but we don't have an implementation for that yet.  If you no longer use the default Doctrine's repository, you can safely remove the 'repository' argument in your entity configuration, and remove Doctrine's repository class to reduce confusion. The default Doctrine's repository is still available by calling $entityManager-&gt;getRepository(Entity::class), it is just you no longer have the option to add custom methods to it.  This implementation of repository sits above Doctrine's Entity Manager. The entity manager does not have the knowledge of the repository. ","version":"Next","tagName":"h2"},{"title":"Interfaces","type":0,"sectionRef":"#","url":"/collections/interfaces","content":"","keywords":"","version":"Next"},{"title":"Recollection‚Äã","type":1,"pageTitle":"Interfaces","url":"/collections/interfaces#recollection","content":" This package enhances Doctrine Collections by extending the Collectioninterface with additional methods. We call this new interface Recollection.    In Doctrine Collection, the following methods accept int|string as the argument. In Recollection, they are overridden, and these arguments are widened to mixed:  containsKey($key)get($key)remove($key)set($key, $value)  The widening can remove some boilerplate code because the caller no longer needs to perform type checking and conversion. It will be done by our classes instead.  Recollection adds these new methods:  fetch($key): Similar to get($key), but throws an exception if the object is not found. If uncaught in a web application, this exception will automatically be converted to a 404 response, which will further avoid boilerplate code.refreshCount(): Recalculates the count of the collection. The exact behavior depends on the provided counting strategy.  It also extends PageableInterface which enables pagination support.  ","version":"Next","tagName":"h2"},{"title":"MinimalRecollection‚Äã","type":1,"pageTitle":"Interfaces","url":"/collections/interfaces#minimalrecollection","content":" A minimal version of Recollection that does not extend Doctrine Collectionbut retains its safe methods with compatible signature. These are the methods that should never trigger full initialization of an extra-lazy Collection.  The idea is that if a collection becomes too large, you can simply switch to the corresponding minimal version, run static analysis, and refactor the parts of your code that still call non-safe methods.    warning This interface will be updated if Doctrine adds new safe methods in the future. Currently, the glaring omissions are the remove and removeElement methods. We expect them to be added to Doctrine ORM eventually.  ","version":"Next","tagName":"h2"},{"title":"PageableRecollection‚Äã","type":1,"pageTitle":"Interfaces","url":"/collections/interfaces#pageablerecollection","content":" An extra-minimal version of Recollection that only extends PageableInterface.    ","version":"Next","tagName":"h2"},{"title":"Repository‚Äã","type":1,"pageTitle":"Interfaces","url":"/collections/interfaces#repository","content":" An alternative implementation of the repository pattern using the Recollectioninterface. You can treat the repository like a regular collection.    It adds one new method:  reference($key): Creates a reference, or a proxy object, to the object identified by the given key. This method has the same function as theEntityManagerInterface::getReference() method.  ","version":"Next","tagName":"h2"},{"title":"MinimalRepository‚Äã","type":1,"pageTitle":"Interfaces","url":"/collections/interfaces#minimalrepository","content":" The minimal flavor of Repository above.    It adds these new methods:  reference($key): Creates a reference, or a proxy object, to the object identified by the given key. This method has the same function as theEntityManagerInterface::getReference() method.remove($key): Removes the object identified by the given key.removeElement($element): Removes the given element from the repository. ","version":"Next","tagName":"h2"},{"title":"UUID Primary Keys","type":0,"sectionRef":"#","url":"/collections/misc/uuid","content":"UUID Primary Keys If you need UUID primary keys, we highly recommend using string-based UUIDs primary key instead of object-based UUIDs (like Symfony or Ramsey's UuidType). Note that it does not mean you are storing the UUIDs as CHAR(36) in the database. It means your entity uses string instead of Uuid as the type of its ID property. Example: use Doctrine\\ORM\\Mapping as ORM; use Symfony\\Component\\Uid\\UuidV7; use Symfony\\Component\\Uid\\Uuid; abstract class AbstractEntity { #[ORM\\Id] #[ORM\\Column(type: 'guid')] private readonly string $id; public function __construct() { $this-&gt;id = (new UuidV7())-&gt;toRfc4122(); } // with PHP &gt;= 8.3 only: public function __clone() { $this-&gt;id = (new UuidV7())-&gt;toRfc4122(); } final public function getId(): string { return $this-&gt;id; } final public function getUuid(): Uuid { return new Uuid($this-&gt;id); } } This way, you retain all the benefits of using UUID primary keys, with all the best practices, but without the headaches: You still have compact, binary UUIDs in the database.You still have time-ordered UUIDs.You still have the means to work with object-based UUIDs in your PHP code using the getUuid() method.You don't need to change how you work with QueryBuilder's setParameter().The keys in a Collection with indexBy are now usable. You will be able to reliably call $collection-&gt;get($id). You no longer need to choose whether to use toRfc4122() or toBinary() depending on the database driver, or even depending on whether the Collection is lazily loaded or not.If you previously used object-based UUIDs, it should not be difficult to migrate to string-based UUIDs.By generating the UUID in the constructor, new entities already have the ID before flush(), which is an often overlooked advantage of using UUID primary keys in the first place.","keywords":"","version":"Next"},{"title":"rekalogika/direct-property-access","type":0,"sectionRef":"#","url":"/direct-property-access","content":"","keywords":"","version":"Next"},{"title":"Synopsis‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#synopsis","content":" use Rekalogika\\DirectPropertyAccess\\DirectPropertyAccessor; class Person { private string $name = 'Jane'; } $propertyAccessor = new DirectPropertyAccessor(); $name = $propertyAccessor-&gt;getValue($person, 'name'); // Jane $propertyAccessor-&gt;setValue($person, 'name', 'John');   ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony FlexNon-Symfony Projects Open a command console, enter your project directory, and execute: composer require rekalogika/direct-property-access   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#usage","content":" In Symfony projects, you can autowire DirectPropertyAccessor. In other projects, you can simply instantiate it.  Read Symfony's PropertyAccess documentationfor more information on how to use it. The difference is thatDirectPropertyAccessor does not call any of the object's methods, but reads and writes directly to the object's properties, even if they are private.  ","version":"Next","tagName":"h2"},{"title":"Caveats‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#caveats","content":" Currently does not support arrays and paths beyond one level deep.  ","version":"Next","tagName":"h2"},{"title":"Credits‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#credits","content":" This project took inspiration from the following projects.  Symfony Property Accesskwn/reflection-property-accessnelmio/alice  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"rekalogika/direct-property-access","url":"/direct-property-access#contributing","content":" Issues and pull requests should be filed in the GitHub repositoryrekalogika/direct-property-access. ","version":"Next","tagName":"h2"},{"title":"Class Diagram","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/class-diagram","content":"Class Diagram Bird's-eye view of Doctrine Collection and the parent interfaces. Those with asterisks are interfaces that we have a decorating trait for.","keywords":"","version":"Next"},{"title":"rekalogika/doctrine-collections-decorator","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/doctrine-collections-decorator","url":"/doctrine-collections-decorator#sections","content":" üìÑÔ∏è Introduction &amp; Installation Lets you easily create decorator classes to modify the behaviors of Doctrine üìÑÔ∏è Creating a Decorator Class This chapter will show you how to use this library. üìÑÔ∏è Decorator Classes and Traits This chapter will describe all the available classes and traits in this package. üìÑÔ∏è Class Diagram Bird's-eye view of Doctrine Collection and the parent interfaces. Those with üóÉÔ∏è Cookbook 6 items ","version":"Next","tagName":"h2"},{"title":"Decorator Classes and Traits","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/classes","content":"","keywords":"","version":"Next"},{"title":"Ready-to-use Decorator Classes‚Äã","type":1,"pageTitle":"Decorator Classes and Traits","url":"/doctrine-collections-decorator/classes#ready-to-use-decorator-classes","content":" The package ships with ready-to-use decorator classes for common use cases:  ExtraLazyCollection: Prevent collection loading in extra-lazy associations.LazyMatchingCollection: Chained matchingoptimization, if you need to call matching() on the result of anothermatching().  ","version":"Next","tagName":"h2"},{"title":"Decorator Classes‚Äã","type":1,"pageTitle":"Decorator Classes and Traits","url":"/doctrine-collections-decorator/classes#decorator-classes","content":" All of our classes come in four flavors:  Those that implement CollectionThose that implement ReadableCollectionThose that implement Collection and SelectableThose that implement ReadableCollection and Selectable  Most people probably want to extend one of the high-level decorator classes. These will simply forward all method calls to the wrapped collection.  CollectionDecoratorReadableCollectionDecoratorSelectableCollectionDecoratorSelectableReadableCollectionDecorator  Also available the 'reject' decorator classes, which will throw an exception when any of the methods is called:  CollectionRejectDecoratorReadableCollectionRejectDecoratorSelectableCollectionRejectDecoratorSelectableReadableCollectionRejectDecorator  ","version":"Next","tagName":"h2"},{"title":"Abstract Decorator Classes‚Äã","type":1,"pageTitle":"Decorator Classes and Traits","url":"/doctrine-collections-decorator/classes#abstract-decorator-classes","content":" Also available are abstract classes for Collection and ReadableCollection, with and without Selectable, if you prefer a slightly low-level approach:  AbstractCollectionDecoratorAbstractReadableCollectionDecoratorAbstractSelectableCollectionDecoratorAbstractSelectableReadableCollectionDecorator  And the 'reject' flavors:  AbstractCollectionRejectDecoratorAbstractReadableCollectionRejectDecoratorAbstractSelectableCollectionRejectDecoratorAbstractSelectableReadableCollectionRejectDecorator  ","version":"Next","tagName":"h2"},{"title":"Decorator Traits‚Äã","type":1,"pageTitle":"Decorator Classes and Traits","url":"/doctrine-collections-decorator/classes#decorator-traits","content":" There are traits for each of the involved interfaces:  ArrayAccessDecoratorTraitIteratorAggregateDecoratorTraitCountableDecoratorTraitReadableCollectionDecoratorTraitCollectionDecoratorTraitSelectableDecoratorTrait  And the 'reject' traits that will throw BadMethodCallException when any of the methods is called.  ArrayAccessRejectDecoratorTraitIteratorAggregateRejectDecoratorTraitCountableRejectDecoratorTraitReadableCollectionRejectDecoratorTraitCollectionRejectDecoratorTraitSelectableRejectDecoratorTrait  All traits require the method getWrapped() which returns the wrapped collection.  ","version":"Next","tagName":"h2"},{"title":"Convenience Trait‚Äã","type":1,"pageTitle":"Decorator Classes and Traits","url":"/doctrine-collections-decorator/classes#convenience-trait","content":" There is one convenience trait ArrayAccessDecoratorDxTrait which forwardsArrayAccess methods not to the wrapped collection, but to other methods of the decorator.  The idea is that you only need to override containsKey(), get(), set(), and remove(); and the methods offsetExists(), offsetGet(), offsetSet(), and offsetUnset() will forward calls to the aforementioned methods. ","version":"Next","tagName":"h2"},{"title":"rekalogika/doctrine-advanced-group-by","type":0,"sectionRef":"#","url":"/doctrine-advanced-group-by","content":"","keywords":"","version":"Next"},{"title":"Supported Databases‚Äã","type":1,"pageTitle":"rekalogika/doctrine-advanced-group-by","url":"/doctrine-advanced-group-by#supported-databases","content":" Only PostgreSQL is currently supported. MS SQL Server support is possible in the future. Other Doctrine-supported databases do not have the functionality and cannot be supported, at least not completely.  ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"rekalogika/doctrine-advanced-group-by","url":"/doctrine-advanced-group-by#installation","content":" composer require rekalogika/doctrine-advanced-group-by   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"rekalogika/doctrine-advanced-group-by","url":"/doctrine-advanced-group-by#usage","content":" use Doctrine\\ORM\\QueryBuilder; use Rekalogika\\DoctrineAdvancedGroupBy\\GroupBy; use Rekalogika\\DoctrineAdvancedGroupBy\\GroupingSet; use Rekalogika\\DoctrineAdvancedGroupBy\\FieldSet; use Rekalogika\\DoctrineAdvancedGroupBy\\Field; /** @var QueryBuilder $queryBuilder */ $queryBuilder -&gt;from(SomeEntity::class, 'e') -&gt;select('e.a AS a') -&gt;addSelect('e.b AS b') -&gt;addSelect('e.c AS c') -&gt;addSelect('e.d AS d'); $groupBy = new GroupBy( new GroupingSet( new FieldSet( new Field('a'), new Field('b'), ), new FieldSet( new Field('c'), new Field('d'), ), ), ); $query = $queryBuilder-&gt;getQuery(); $groupBy-&gt;apply($query); $result = $query-&gt;getResult();   ","version":"Next","tagName":"h2"},{"title":"Class Diagram‚Äã","type":1,"pageTitle":"rekalogika/doctrine-advanced-group-by","url":"/doctrine-advanced-group-by#class-diagram","content":"   ","version":"Next","tagName":"h2"},{"title":"Flattening‚Äã","type":1,"pageTitle":"rekalogika/doctrine-advanced-group-by","url":"/doctrine-advanced-group-by#flattening","content":" It is possible to flatten a GroupBy object into another instance of GroupBywith a single level of grouping sets.  $groupBy1 = new GroupBy( new RollUp( new Field('a'), new Field('b'), ), ); $groupBy2 = new GroupBy( new GroupingSet( new FieldSet(), new FieldSet( new Field('a'), ), new FieldSet( new Field('a'), new Field('b'), ), ), );   In the example above, $groupBy2 is the flattened version of $groupBy1. You can transform $groupBy1 into $groupBy2 using the flatten method.  $flattened = $groupBy1-&gt;flatten();   This is useful if you need to know if the GroupBy generates more than 4096 grouping sets, which is the limit of the database. Or, you can use it to split the query into multiple smaller queries.  ","version":"Next","tagName":"h2"},{"title":"Limitations‚Äã","type":1,"pageTitle":"rekalogika/doctrine-advanced-group-by","url":"/doctrine-advanced-group-by#limitations","content":" Works using a custom SQL walker; therefore it is not possible if you need to use a custom SQL walker for another purpose.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"rekalogika/doctrine-advanced-group-by","url":"/doctrine-advanced-group-by#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"rekalogika/doctrine-advanced-group-by","url":"/doctrine-advanced-group-by#contributing","content":" Issues and pull requests should be filed in the GitHub repository rekalogika/doctrine-advanced-group-by. ","version":"Next","tagName":"h2"},{"title":"Cookbook","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook","content":"","keywords":"","version":"Next"},{"title":"Use Cases‚Äã","type":1,"pageTitle":"Cookbook","url":"/doctrine-collections-decorator/cookbook#use-cases","content":" üìÑÔ∏è Type Safety We can use collection decoration to ensure that the items in a collection are of üìÑÔ∏è Record Precounting Database servers can be [slow in counting üìÑÔ∏è Selectable Abstraction Doctrine ORM uses collection objects that also implement the Selectable üìÑÔ∏è Decorating Member Objects We can use a collection decorator to dynamically decorate the members of the üìÑÔ∏è Loading Prevention in Extra Lazy Collections Suppose you have an entity that has a one-to-many relation with a million of üìÑÔ∏è Lazy Chained Matching If you call matching() on a PersistentCollection, it will immediately query ","version":"Next","tagName":"h2"},{"title":"Loading Prevention in Extra Lazy Collections","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook/extra-lazy-load-prevention","content":"","keywords":"","version":"Next"},{"title":"The Decorator Class‚Äã","type":1,"pageTitle":"Loading Prevention in Extra Lazy Collections","url":"/doctrine-collections-decorator/cookbook/extra-lazy-load-prevention#the-decorator-class","content":" This package already comes with ExtraLazyCollection for this purpose.  info While ExtraLazyCollection only allows the safe methods, they still implement the Collection interface so that the object can still be used in places where a Collection is expected.  ","version":"Next","tagName":"h2"},{"title":"Usage Example in Entities‚Äã","type":1,"pageTitle":"Loading Prevention in Extra Lazy Collections","url":"/doctrine-collections-decorator/cookbook/extra-lazy-load-prevention#usage-example-in-entities","content":" use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Collections\\Decorator\\ExtraLazy\\ExtraLazyCollection; #[ORM\\Entity()] class BookShelf { // our bookshelf has a million of books... #[ORM\\OneToMany( targetEntity: Book::class, fetch: 'EXTRA_LAZY', // needs this, or the safe methods become unsafe indexBy: 'id', // needs this, or containsKey() &amp; get() become unsafe )] private Collection $books; public function getBooks(): Collection { return new ExtraLazyCollection($this-&gt;books); } }  ","version":"Next","tagName":"h2"},{"title":"Decorating Member Objects","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook/decorating-members","content":"","keywords":"","version":"Next"},{"title":"BusinessContract Entity & Superclass‚Äã","type":1,"pageTitle":"Decorating Member Objects","url":"/doctrine-collections-decorator/cookbook/decorating-members#businesscontract-entity--superclass","content":" use Doctrine\\ORM\\Mapping as ORM; interface BusinessContractInterface { // ... } #[ORM\\Entity()] class BusinessContract implements BusinessContractInterface { // ... }   ","version":"Next","tagName":"h2"},{"title":"Decorator for BusinessContract‚Äã","type":1,"pageTitle":"Decorating Member Objects","url":"/doctrine-collections-decorator/cookbook/decorating-members#decorator-for-businesscontract","content":" class BusinessContractDecorator implements BusinessContractInterface { public function __construct(private BusinessContractInterface $wrapped) { } // ... }   ","version":"Next","tagName":"h2"},{"title":"Decorator for the BusinessContract Collection‚Äã","type":1,"pageTitle":"Decorating Member Objects","url":"/doctrine-collections-decorator/cookbook/decorating-members#decorator-for-the-businesscontract-collection","content":" use Doctrine\\Common\\Collections\\Collection; use Doctrine\\Common\\Collections\\Criteria; use Doctrine\\Common\\Collections\\Selectable; use Rekalogika\\Collections\\Decorator\\Decorator\\CollectionDecorator; /** * @extends CollectionDecorator&lt;array-key,BusinessContractInterface&gt; */ class BusinessContractCollectionDecorator extends CollectionDecorator { #[\\Override] public function get(string|int $key): BusinessContractInterface { return new BusinessContractDecorator( $this-&gt;getWrapped()-&gt;get($key) ); } #[\\Override] public function getIterator(): \\Traversable { foreach ($this-&gt;getWrapped() as $key =&gt; $value) { yield $key =&gt; new BusinessContractDecorator($value); } } // We should override all the other methods that returns // BusinessContractInterface, but for conciseness, we skip them here. }   ","version":"Next","tagName":"h2"},{"title":"Usage in the PartnerCompany Object‚Äã","type":1,"pageTitle":"Decorating Member Objects","url":"/doctrine-collections-decorator/cookbook/decorating-members#usage-in-the-partnercompany-object","content":" use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity()] class PartnerCompany { /** * @var Collection&lt;array-key,BusinessContractInterface&gt; */ #[ORM\\OneToMany(targetEntity: BusinessContract::class)] private Collection $businessContracts; public function __construct() { $this-&gt;businessContracts = new ArrayCollection(); } public function getBusinessContracts(): BusinessContractCollectionDecorator { return new BusinessContractCollectionDecorator($this-&gt;businessContracts); } }   ","version":"Next","tagName":"h2"},{"title":"Class Diagram‚Äã","type":1,"pageTitle":"Decorating Member Objects","url":"/doctrine-collections-decorator/cookbook/decorating-members#class-diagram","content":" Now for a bird's-eye view of our classes.   ","version":"Next","tagName":"h2"},{"title":"Record Precounting","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook/record-precounting","content":"","keywords":"","version":"Next"},{"title":"The Decorator Class‚Äã","type":1,"pageTitle":"Record Precounting","url":"/doctrine-collections-decorator/cookbook/record-precounting#the-decorator-class","content":" use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\Collections\\Decorator\\Decorator\\CollectionDecorator; /** * @extends CollectionDecorator&lt;array-key,Book&gt; */ class BookCollection extends CollectionDecorator { /** * @param Collection&lt;array-key,Book&gt; $collection */ public function __construct( Collection $collection, private int &amp;$count // pass by reference ) { parent::__construct($collection); } #[\\Override] public function count(): int { return $this-&gt;count(); } /** * Calculates the count and stores it in the `$count` property. */ public function preCount(): void { $this-&gt;count = $this-&gt;getWrapped()-&gt;count(); } }   ","version":"Next","tagName":"h2"},{"title":"Usage in the one-to-many Side‚Äã","type":1,"pageTitle":"Record Precounting","url":"/doctrine-collections-decorator/cookbook/record-precounting#usage-in-the-one-to-many-side","content":" use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity()] class BookShelf { /** * @var Collection&lt;array-key,Book&gt; */ #[ORM\\OneToMany(targetEntity: Book::class)] private Collection $books; #[ORM\\Column()] private int $booksCount = 0; public function __construct() { $this-&gt;books = new ArrayCollection(); } public function getBooks(): BookCollection { return new BookCollection($this-&gt;books, $this-&gt;booksCount); } }   ","version":"Next","tagName":"h2"},{"title":"The Caller Side‚Äã","type":1,"pageTitle":"Record Precounting","url":"/doctrine-collections-decorator/cookbook/record-precounting#the-caller-side","content":" To get the count, you can do it the same way as before. But instead of asking the database to do that, this time it will give you the value from the pre-counted result instantly:  $count = $bookShelf-&gt;getBooks()-&gt;count(); // or: $count = count($bookShelf-&gt;getBooks());   When it is time to refresh the pre-counted value, you can do this:  /** @var EntityManagerInterface $entityManager */ $bookShelf-&gt;getBooks()-&gt;preCount(); $entityManager-&gt;flush();  ","version":"Next","tagName":"h2"},{"title":"Lazy Chained Matching","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook/lazy-chained-matching","content":"","keywords":"","version":"Next"},{"title":"The Decorator Class‚Äã","type":1,"pageTitle":"Lazy Chained Matching","url":"/doctrine-collections-decorator/cookbook/lazy-chained-matching#the-decorator-class","content":" This package already comes with LazyMatchingCollection that you can use for this purpose.  ","version":"Next","tagName":"h2"},{"title":"Usage Example in Entities‚Äã","type":1,"pageTitle":"Lazy Chained Matching","url":"/doctrine-collections-decorator/cookbook/lazy-chained-matching#usage-example-in-entities","content":" use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Collections\\Decorator\\LazyMatching\\LazyMatchingCollection; #[ORM\\Entity()] class BookShelf { #[ORM\\OneToMany(targetEntity: Book::class, fetch: 'EXTRA_LAZY', indexBy: 'id')] private Collection $books; public function __construct() { $this-&gt;books = new ArrayCollection(); } /** * @return Collection&lt;array-key,Book&gt;&amp;Selectable&lt;array-key,Book&gt; */ public function getBooks(): Collection&amp;Selectable { return new LazyMatchingCollection($this-&gt;books); } public function getScienceBooks(): Collection { return $this-&gt;getBooks()-&gt;matching( Criteria::create() -&gt;where(Criteria::expr()-&gt;eq('genre', 'science')) ); } public function getOldScienceBooks(): Collection { return $this-&gt;getScienceBook()-&gt;matching( Criteria::create() -&gt;where(Criteria::expr()-&gt;lt('publishedAt', new \\DateTime('-10 years'))) ); } }   ","version":"Next","tagName":"h2"},{"title":"The Caller Side‚Äã","type":1,"pageTitle":"Lazy Chained Matching","url":"/doctrine-collections-decorator/cookbook/lazy-chained-matching#the-caller-side","content":" Then the caller will be able to do something like this:  $bookShelf = $entityManager-&gt;find(BookShelf::class, 1); $oldScienceBook = $bookShelf-&gt;getOldScienceBook(); foreach ($oldScienceBook as $book) { echo $book-&gt;getTitle(); }   With this example, there will be only two database queries, one due to$entityManager-&gt;find(), and one due to the foreach call. ","version":"Next","tagName":"h2"},{"title":"Introduction & Installation","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/intro","content":"","keywords":"","version":"Next"},{"title":"Motivation‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/doctrine-collections-decorator/intro#motivation","content":" Custom collection classes won't come to Doctrine ORM anytime soon. Therefore, the only way to modify the behavior of a Doctrine collection is to use decorators. However, creating a Collection decorator by hand is a tedious process.  ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/doctrine-collections-decorator/intro#features","content":" Easily create your decorator classes by extending one of the abstract classes.Several ready-made decorators for common use cases.  ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/doctrine-collections-decorator/intro#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  Open a command console, enter your project directory and execute:  composer require rekalogika/doctrine-collections-decorator   ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/doctrine-collections-decorator/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/doctrine-collections-decorator/intro#contributing","content":" This framework consists of multiple repositories split from a monorepo. Be sure to submit issues and pull requests to therekalogika/doctrine-collections-decorator monorepo. ","version":"Next","tagName":"h2"},{"title":"Selectable Abstraction","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook/selectable-abstraction","content":"","keywords":"","version":"Next"},{"title":"The Decorator Class‚Äã","type":1,"pageTitle":"Selectable Abstraction","url":"/doctrine-collections-decorator/cookbook/selectable-abstraction#the-decorator-class","content":" use Doctrine\\Common\\Collections\\Collection; use Doctrine\\Common\\Collections\\Criteria; use Doctrine\\Common\\Collections\\Selectable; use Rekalogika\\Collections\\Decorator\\AbstractDecorator\\AbstractCollectionDecorator; /** * @extends AbstractCollectionDecorator&lt;array-key,Book&gt; */ class BookCollection extends AbstractCollectionDecorator { /** * @param Collection&lt;array-key,Book&gt;&amp;Selectable&lt;array-key,Book&gt; $collection */ public function __construct(private Collection $collection) { if (!$collection instanceof Selectable) { throw new \\RuntimeException('The wrapped collection must implement the Selectable interface.'); } } /** * @return Collection&lt;array-key,Book&gt;&amp;Selectable&lt;array-key,Book&gt; */ #[\\Override] protected function getWrapped(): Collection&amp;Selectable { return $this-&gt;collection; } public function findByAuthor(string $author): self { $criteria = Criteria::create() -&gt;where(Criteria::expr()-&gt;eq('author', $author)); $result = $this-&gt;getWrapped()-&gt;matching($criteria); return new self($result); } }   ","version":"Next","tagName":"h2"},{"title":"Usage in the one-to-many Side‚Äã","type":1,"pageTitle":"Selectable Abstraction","url":"/doctrine-collections-decorator/cookbook/selectable-abstraction#usage-in-the-one-to-many-side","content":" use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity()] class BookShelf { /** * @var Collection&lt;array-key,Book&gt; */ #[ORM\\OneToMany(targetEntity: Book::class)] private Collection $books; public function __construct() { $this-&gt;books = new ArrayCollection(); } public function getBooks(): BookCollection { return new BookCollection($this-&gt;books); } }   ","version":"Next","tagName":"h2"},{"title":"The Caller Side‚Äã","type":1,"pageTitle":"Selectable Abstraction","url":"/doctrine-collections-decorator/cookbook/selectable-abstraction#the-caller-side","content":" Then the caller will be able to do something like this:  /** @var BookShelf $bookShelf */ $booksByJohnDoe = $bookShelf-&gt;getBooks()-&gt;findByAuthor('John Doe');  ","version":"Next","tagName":"h2"},{"title":"Type Safety","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/cookbook/type-safety","content":"","keywords":"","version":"Next"},{"title":"The Decorator Class‚Äã","type":1,"pageTitle":"Type Safety","url":"/doctrine-collections-decorator/cookbook/type-safety#the-decorator-class","content":" use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\Collections\\Decorator\\Decorator\\CollectionDecorator; /** * @extends CollectionDecorator&lt;array-key,Book&gt; */ class Books extends CollectionDecorator { private static function assert(mixed $book): Book { if (!$book instanceof Book) { throw new \\InvalidArgumentException('Invalid input'); } return $book; } #[\\Override] public function add(mixed $element): void { $this-&gt;getWrapped()-&gt;add(self::assert($element)); } #[\\Override] public function set(string|int $key, mixed $value): void { $this-&gt;getWrapped()-&gt;set($key, self::assert($value)); } }   ","version":"Next","tagName":"h2"},{"title":"Usage in the one-to-many Side‚Äã","type":1,"pageTitle":"Type Safety","url":"/doctrine-collections-decorator/cookbook/type-safety#usage-in-the-one-to-many-side","content":" use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity()] class BookShelf { /** * @var Collection&lt;array-key,Book&gt; */ #[ORM\\OneToMany(targetEntity: Book::class)] private Collection $books; public function __construct() { $this-&gt;books = new ArrayCollection(); } public function getBooks(): Books { return new Books($this-&gt;books); } }  ","version":"Next","tagName":"h2"},{"title":"Creating a Decorator Class","type":0,"sectionRef":"#","url":"/doctrine-collections-decorator/creating","content":"","keywords":"","version":"Next"},{"title":"Creating a Decorator Class‚Äã","type":1,"pageTitle":"Creating a Decorator Class","url":"/doctrine-collections-decorator/creating#creating-a-decorator-class","content":" The simplest way to create a decorator class is to extend CollectionDecorator.  use Rekalogika\\Collections\\Decorator\\Decorator\\CollectionDecorator; /** * @extends CollectionDecorator&lt;array-key,Book&gt; */ class BookCollection extends CollectionDecorator { // ... }   Then add your methods to override the existing one. In your methods, you can access the wrapped collection object by calling $this-&gt;getWrapped().  Protip If you want the caller to use the matching() method of the wrapped collection, you can use the SelectableCollectionDecorator class instead.  ","version":"Next","tagName":"h2"},{"title":"Using it in an Entity‚Äã","type":1,"pageTitle":"Creating a Decorator Class","url":"/doctrine-collections-decorator/creating#using-it-in-an-entity","content":" To use it, simply wrap the collection in the constructor.  use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; class BookShelf { /** * @var Collection&lt;array-key,Book&gt; */ private Collection $books; public function __construct() { $this-&gt;books = new ArrayCollection(); } public function getBooks(): BookCollection { return new BookCollection($this-&gt;books); } }  ","version":"Next","tagName":"h2"},{"title":"rekalogika/domain-event","type":0,"sectionRef":"#","url":"/domain-event","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/domain-event","url":"/domain-event#sections","content":" üìÑÔ∏è Introduction &amp; Installation An implementation of domain event pattern for Symfony &amp; Doctrine. üìÑÔ∏è Outbox Installation &amp; Configuration To use the transactional outbox pattern to publish your events on the event bus, üìÑÔ∏è Basic Usage You make your entities record events happening in your domain. This library üìÑÔ∏è Pseudo Magic Method The interface DomainEventEmitterInterface implemented by your entities and the üìÑÔ∏è Equatable Domain Events A domain event can optionally implement EquatableDomainEventInterface which üìÑÔ∏è Transactions The framework fully supports transaction, as long as the caller uses the üìÑÔ∏è Manual Control To manually manage domain events, you can use üìÑÔ∏è Dispatch Events When a domain event is dispatched, another event is dispatched. The event wraps üìÑÔ∏è Testing Undispatched Event Problem üìÑÔ∏è Transactional Outbox Pattern The package rekalogika/domain-event-outbox implements the transactional outbox üìÑÔ∏è Batch Processing How to handle domain events in batch processing. üìÑÔ∏è Tips This chapter explains the tips and our best practices that others might find ","version":"Next","tagName":"h2"},{"title":"Batch Processing","type":0,"sectionRef":"#","url":"/domain-event/batch-processing","content":"","keywords":"","version":"Next"},{"title":"Common Patterns‚Äã","type":1,"pageTitle":"Batch Processing","url":"/domain-event/batch-processing#common-patterns","content":" To handle domain events in batch processing, you probably want to disable auto-dispatch. This way, your equatable events will only be dispatched once at the end of the batch processing, and you can avoid expensive event listeners from affecting the performance of your batch processing.  use Rekalogika\\DomainEvent\\DomainEventAwareEntityManagerInterface; /** @var DomainEventEntityManagerInterface $entityManager */ // disable autodispatching of domain events $entityManager-&gt;setAutoDispatchDomainEvents(false); // Do some batch processing $batchSize = 20; $i = 1; foreach (...) { // example loop, can also be a while, for, etc loop too. // Do some processing here. You can persist, update, or remove entities, // operations that might emit domain events. if ($i % $batchSize === 0) { // dispatches domain events in the pre-flush phase $entityManager-&gt;dispatchPreFlushDomainEvents(); // flushes the changes to the database $entityManager-&gt;flush(); // detaches all objects from Doctrine $entityManager-&gt;clear(); } $i++; } // do not forget to handle the remaining items $entityManager-&gt;dispatchPreFlushDomainEvents(); $entityManager-&gt;flush(); $entityManager-&gt;clear(); // dispatches domain events in the post-flush phase $entityManager-&gt;dispatchPostFlushDomainEvents(); // reenable autodispatching of domain events $entityManager-&gt;setAutoDispatchDomainEvents(true);  ","version":"Next","tagName":"h2"},{"title":"Equatable Domain Events","type":0,"sectionRef":"#","url":"/domain-event/equatable","content":"Equatable Domain Events A domain event can optionally implement EquatableDomainEventInterface which requires the method getSignature(). Two objects with the same signature will be considered identical and won't be dispatched twice. This is useful if your entity is working with a million of related objects. By implementing EquatableDomainEventInterface, you can have your ObjectChangedevent dispatched only once and occupy only a single spot in the memory, instead of a million times. use Rekalogika\\Contracts\\DomainEvent\\EquatableDomainEventInterface; class PostCommentAdded implements EquatableDomainEventInterface { public function __construct(private string $postId) { } public function getSignature(): string { return sha1(serialize($this)); } } use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface; use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait; class Post implements DomainEventEmitterInterface { use DomainEventEmitterTrait; // ... public function addComment(string $comment): Comment { // ... // the PostCommentAdded event will only get dispatched once despite of // addComment being called multiple times. $this-&gt;recordEvent(new PostCommentAdded($this-&gt;id)); } } note Equatable domain events only apply to where the events are spooled before they are processed. Immediate domain events are dispatched immediately, and there is no chance for the equatable check to take place. warning There is no guarantee that the event will be dispatched only once. Two events considered identical may have been recorded in two different phases, and never get grouped together.","keywords":"","version":"Next"},{"title":"Dispatch Events","type":0,"sectionRef":"#","url":"/domain-event/dispatch-events","content":"","keywords":"","version":"Next"},{"title":"List of the Dispatch Events‚Äã","type":1,"pageTitle":"Dispatch Events","url":"/domain-event/dispatch-events#list-of-the-dispatch-events","content":" DomainEventImmediateDispatchEvent: dispatched immediately after the domain event is recorded.DomainEventPreFlushDispatchEvent: dispatched before the flush() is called.DomainEventPostFlushDispatchEvent: dispatched after the flush() is called.  note DomainEventPreFlushDispatchEvent and DomainEventPostFlushDispatchEvent also includes the ObjectManager (EntityManager) instance that manages the object that emitted the domain event.  ","version":"Next","tagName":"h2"},{"title":"Listening to the Dispatch Events‚Äã","type":1,"pageTitle":"Dispatch Events","url":"/domain-event/dispatch-events#listening-to-the-dispatch-events","content":" use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener; #[AsEventListener] class PreFlushDispatchEventListener { public function __invoke(DomainEventPreFlushDispatchEvent $event) { // log the $event, publish the $event on an event bus, etc } }   ","version":"Next","tagName":"h2"},{"title":"Purpose‚Äã","type":1,"pageTitle":"Dispatch Events","url":"/domain-event/dispatch-events#purpose","content":" This mechanism is created to allow you to build on top of the domain events. For example, you can record the events for audit trails, or publish the events on an event bus.  info The package rekalogika/domain-event-outbox is completely decoupled fromrekalogika/domain-event. The only thing that connects them is the event DomainEventPreFlushDispatchEvent. ","version":"Next","tagName":"h2"},{"title":"Basic Usage","type":0,"sectionRef":"#","url":"/domain-event/basic-usage","content":"","keywords":"","version":"Next"},{"title":"Creating Domain Events‚Äã","type":1,"pageTitle":"Basic Usage","url":"/domain-event/basic-usage#creating-domain-events","content":" Domain events are plain old PHP objects that you create to represent a specific event happening in your domain. There is no particular requirement for these classes, except they should be serializable. For event bus dispatching, they must be serializable.  // our event superclass for the Post object abstract class AbstractPostEvent { public function __construct(private string $id) { } public function getId(): string { return $this-&gt;id; } } // our concrete events final class PostCreated extends AbstractPostEvent { } final class PostChanged extends AbstractPostEvent { } final class PostRemoved extends AbstractPostEvent { }   ","version":"Next","tagName":"h2"},{"title":"Recording Events‚Äã","type":1,"pageTitle":"Basic Usage","url":"/domain-event/basic-usage#recording-events","content":" Your emitters (entities) must implement DomainEventEmitterInterface. There is a DomainEventEmitterTrait to help you with that. To record events, you can use the method recordEvents() defined in the trait.  use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface; use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait; use Symfony\\Component\\Uid\\UuidV7; class Post implements DomainEventEmitterInterface { use DomainEventEmitterTrait; private string $id; private string $title; /** @var Collection&lt;int,Comment&gt; */ private Collection $comments; public function __construct(string $title) { $this-&gt;id = new UuidV7(); $this-&gt;title = $title; $this-&gt;comments = new ArrayCollection(); $this-&gt;recordEvent(new PostCreated($this-&gt;id)); } // __remove() is our pseudo magic method that gets triggered when the entity // is about to be removed from the persistence layer public function __remove() { $this-&gt;recordEvent(new PostRemoved($this-&gt;id)); } public function setTitle(string $title): void { $this-&gt;title = $title; $this-&gt;recordEvent(new PostChanged($this-&gt;id)); } }   ","version":"Next","tagName":"h2"},{"title":"Listening to Events‚Äã","type":1,"pageTitle":"Basic Usage","url":"/domain-event/basic-usage#listening-to-events","content":" When an entity records the event, the event will be dispatched up to four times: immediately when it is recorded (immediate strategy), before the flush() is called (pre-flush strategy), and after the flush() is called (post-flush strategy). Additionally, with the optional rekalogika/domain-event-outboxpackage, the event will be published on an event bus.  To listen to the events, you can use the usual Symfony way of listening to events, where the event listener will be invoked after you call flush():  use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener; #[AsEventListener] class PostEventListener { // this method will be invoked after a new Post is persist()-ed &amp; flush()-ed public function __invoke(PostCreated $event) { $postId = $event-&gt;getId(); // ... } }   To choose different dispatching strategy, you can use different attributes:  use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsImmediateDomainEventListener; use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPostFlushDomainEventListener; use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPreFlushDomainEventListener; use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPublishedDomainEventListener; class PostEventListener { #[AsImmediateDomainEventListener] public function immediate(PostCreated $event) { // this will be executed immediately after the entity records the event } #[AsPreFlushDomainEventListener] public function preFlush(PostCreated $event) { // this will be executed when you flush() the new post. before the actual // flush() } #[AsPostFlushDomainEventListener] public function postFlush(PostCreated $event) { // this will be executed when you flush() the new post. after the actual // flush() } #[AsPublishedDomainEventListener] public function eventBus(PostCreated $event) { // the event will be published on the event bus, and this method will // be executed when the event is consumed from the bus } }   note AsEventListener and AsPostFlushDomainEventListener currently have identical behavior, but they utilize different event dispatchers. We plan to have a different event dispatcher behavior withAsPostFlushDomainEventListener while keeping AsEventListener standard.Doing a flush() inside a pre-flush listener is not allowed and will result in a FlushNotAllowedException.AsPublishedDomainEventListener requires the optionalrekalogika/domain-event-outbox package.  ","version":"Next","tagName":"h2"},{"title":"Dispatching the Events‚Äã","type":1,"pageTitle":"Basic Usage","url":"/domain-event/basic-usage#dispatching-the-events","content":" With pre and post-flush strategy, the actual dispatching of the events is done when you call flush() on the entity manager. It will do the following in order:  Collects the events from the entities, and adds them to the pre-flush and post-flush queue. Then it dispatches the events in the pre-flush queue.Calls the actual flush().Dispatches post-flush events in the queue.  The pre-flush events might generate additional events, in which case they will also be dispatched in the pre-flush phase. It does that until there are no more events to dispatch.  note There is a safeguard in place to prevent infinite loops. If the pre-flush events keep generating more pre-flush events, it will throw aSafeguardTriggeredException after 100 iterations.  The AsPublishedDomainEventListener strategy works by adding the events to the outbox table in the same phase as the pre-flush strategy. Then the message relay reads the table, and publishes the events to the event bus. ","version":"Next","tagName":"h2"},{"title":"Pseudo Magic Method","type":0,"sectionRef":"#","url":"/domain-event/pseudo-magic-method","content":"Pseudo Magic Method The interface DomainEventEmitterInterface implemented by your entities and the corresponding DomainEventEmitterTrait add a pseudo magic method __remove(). The __remove() method is called when the entity is about to be removed from the database. You can use this method to record a 'removed' event. use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface; use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait; class Post implements DomainEventEmitterInterface { use DomainEventEmitterTrait; // ... public function __remove() { $this-&gt;recordEvent(new PostRemoved($this-&gt;id)); } } This mechanism is devised because otherwise the entity cannot possibly know if it is being removed from the persistence layer.","keywords":"","version":"Next"},{"title":"Manual Control","type":0,"sectionRef":"#","url":"/domain-event/manual-control","content":"","keywords":"","version":"Next"},{"title":"Manual Dispatching‚Äã","type":1,"pageTitle":"Manual Control","url":"/domain-event/manual-control#manual-dispatching","content":" You can disable automatic dispatching on flush() by callingsetAutoDispatchDomainEvents(false).  use Rekalogika\\DomainEvent\\DomainEventAwareEntityManagerInterface; /** @var DomainEventAwareEntityManagerInterface $entityManager */ $entityManager-&gt;setAutoDispatchDomainEvents(false); // ... $entityManager-&gt;dispatchPreFlushDomainEvents(); $entityManager-&gt;flush(); $entityManager-&gt;dispatchPostFlushDomainEvents();   note Immediate dispatching is dispatched outside DomainEventAwareEntityManager, and therefore unaffected by setAutoDispatchDomainEvents().  ","version":"Next","tagName":"h2"},{"title":"Clearing the Events‚Äã","type":1,"pageTitle":"Manual Control","url":"/domain-event/manual-control#clearing-the-events","content":" If the domain event queues are not empty at the end of the request,DomainEventEntityManager will throw UndispatchedEventsException. To prevent that from happening, if you disable auto-dispatch, you need to make sure that you dispatch both pre-flush and post-flush events as above. Alternatively, you can clear the events if you don't want them dispatched:  use Rekalogika\\DomainEvent\\DomainEventAwareEntityManagerInterface; /** @var DomainEventAwareEntityManagerInterface $entityManager */ $entityManager-&gt;setAutoDispatchDomainEvents(false); // ... $entityManager-&gt;flush(); $entityManager-&gt;clearDomainEvents();   note In the event of an uncaught error, the framework will automatically clear undispatched events using the kernel.exception and console.errorevents, so in such cases, you don't have to handle that manually. But if you catch an exception that previously caused pending events not to be dispatched, you need to manually clear the events.  ","version":"Next","tagName":"h2"},{"title":"Getting the Events From the Queue and Dispatching Them Elsewhere‚Äã","type":1,"pageTitle":"Manual Control","url":"/domain-event/manual-control#getting-the-events-from-the-queue-and-dispatching-them-elsewhere","content":" You can get the undispatched events in the queue by calling popDomainEvents().  use Rekalogika\\DomainEvent\\DomainEventAwareEntityManagerInterface; /** @var DomainEventAwareEntityManagerInterface $entityManager */ $events = $entityManager-&gt;popDomainEvents();   note As it suggests, popDomainEvents() also removes the events from the queue.  Then, you can dispatch them in another place, for example, in another process, or at the end of a batch process.  use Rekalogika\\DomainEvent\\DomainEventAwareEntityManagerInterface; /** @var DomainEventAwareEntityManagerInterface $entityManager */ $entityManager-&gt;recordDomainEvent($events); $entityManager-&gt;dispatchPreFlushDomainEvents(); $entityManager-&gt;flush(); $entityManager-&gt;dispatchPostFlushDomainEvents();   You might find the DomainEventStore object useful. You can use it to store the events in transit. It handles EquatableDomainEventInterface and will automatically discard duplicate events.  use Rekalogika\\DomainEvent\\DomainEventAwareEntityManagerInterface; use Rekalogika\\DomainEvent\\Model\\DomainEventStore; /** @var DomainEventAwareEntityManagerInterface $entityManager */ $domainEventStore = new DomainEventStore(); // a batch process foreach (...) { // ... $domainEventStore-&gt;add($entityManager-&gt;popDomainEvents()); } // ... // now at the end of the batch process $entityManager-&gt;recordDomainEvent($domainEventStore); $entityManager-&gt;dispatchPreFlushDomainEvents(); $entityManager-&gt;flush(); $entityManager-&gt;dispatchPostFlushDomainEvents();   ","version":"Next","tagName":"h2"},{"title":"Multiple Entity Managers‚Äã","type":1,"pageTitle":"Manual Control","url":"/domain-event/manual-control#multiple-entity-managers","content":" When working with multiple entity managers, usually the ManagerRegistry is used to get the correct entity manager. This method still works with domain events without any change.  However, if you need the domain-event-specific methods, you can useDomainEventAwareManagerRegistry in place of ManagerRegistry. It adds several methods to the registry that you can use to manage domain event dispatching:  getDomainEventAwareManager()getDomainEventAwareManagers()getDomainEventAwareManagerForClass()  These are basically the same as their counterparts in ManagerRegistry, only return DomainEventAwareObjectManager instead of ObjectManager. ","version":"Next","tagName":"h2"},{"title":"Outbox Installation & Configuration","type":0,"sectionRef":"#","url":"/domain-event/outbox-setup","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Outbox Installation & Configuration","url":"/domain-event/outbox-setup#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony Flex Open a command console, enter your project directory and execute: composer require rekalogika/domain-event-outbox   ","version":"Next","tagName":"h2"},{"title":"Symfony Messenger Configuration‚Äã","type":1,"pageTitle":"Outbox Installation & Configuration","url":"/domain-event/outbox-setup#symfony-messenger-configuration","content":" The package requires a Symfony Messenger bus namedrekalogika.domain_event.bus. You can accomplish that by creating the configuration file:  config/packages/rekalogika_domain_event_outbox.yaml framework: messenger: buses: rekalogika.domain_event.bus: default_middleware: allow_no_handlers: true   ","version":"Next","tagName":"h2"},{"title":"Make Sure the Default messenger.yaml Has an Explicit Bus Configuration‚Äã","type":1,"pageTitle":"Outbox Installation & Configuration","url":"/domain-event/outbox-setup#make-sure-the-default-messengeryaml-has-an-explicit-bus-configuration","content":" danger The default Symfony Messenger configuration does not define buses anddefault_bus. You need to make sure they are present in your configuration file. Otherwise, our bus configuration above will silently become the default bus.  config/packages/messenger.yaml # default messenger.yaml with explicit default bus framework: messenger: failure_transport: failed transports: # https://symfony.com/doc/current/messenger.html#transport-configuration async: dsn: '%env(MESSENGER_TRANSPORT_DSN)%' options: use_notify: true check_delayed_interval: 60000 retry_strategy: max_retries: 3 multiplier: 2 failed: 'doctrine://default?queue_name=failed' # sync: 'sync://' ### You need to add this ### START default_bus: messenger.bus.default buses: messenger.bus.default: null ### END routing: Symfony\\Component\\Mailer\\Messenger\\SendEmailMessage: async Symfony\\Component\\Notifier\\Message\\ChatMessage: async Symfony\\Component\\Notifier\\Message\\SmsMessage: async # Route your messages to the transports # 'App\\Message\\YourMessage': async   ","version":"Next","tagName":"h2"},{"title":"Configure Your Domain Events Routing‚Äã","type":1,"pageTitle":"Outbox Installation & Configuration","url":"/domain-event/outbox-setup#configure-your-domain-events-routing","content":" With this package, your domain events become the message classes of the Symfony Messenger. And like other Symfony Messenger messages, you may need to configure the routing for your domain events. You can do that like the following.  config/packages/messenger.yaml framework: messenger: # ... routing: # ... 'Rekalogika\\DomainEvent\\Outbox\\Message\\MessageRelayStartMessage': async 'App\\DomainEvent\\*': async   ","version":"Next","tagName":"h2"},{"title":"Bundle Configuration‚Äã","type":1,"pageTitle":"Outbox Installation & Configuration","url":"/domain-event/outbox-setup#bundle-configuration","content":" The bundle defines the following configuration option:  config/packages/rekalogika_domain_event_outbox.yaml rekalogika_domain_event_outbox: # The name of database table used to store the outgoing messages outbox_table: rekalogika_event_outbox  ","version":"Next","tagName":"h2"},{"title":"Introduction & Installation","type":0,"sectionRef":"#","url":"/domain-event/intro","content":"","keywords":"","version":"Next"},{"title":"What is a Domain Event?‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#what-is-a-domain-event","content":" A domain event is simply a regular event like you would normally use with Symfony's EventDispatcher. The difference is that a domain event represents something that has happened in your domain. It has a name that is meaningful to the underlying business that the domain represents. A domain event is usually dispatched by your entities, as opposed to being dispatched from your controllers or other services.  ","version":"Next","tagName":"h2"},{"title":"Why Use Domain Events?‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#why-use-domain-events","content":" A domain event represents a business event that has happened. It is a good way to model the business requirements that say &quot;when something happens, do this&quot;.  A domain event is raised by the part of your code where the event is actually happening. Different part of your application might call the same method on an entity. In some cases, the method is called indirectly, and the caller has no idea that it is being called. By using domain events, the event will be dispatched in all the cases. No need to make sure to dispatch the event from all the different places where the method is called.  The application layer (controllers, services) can tell an entity to do something, but it cannot reliably know if the action is actually performed, or if an additional action is performed. A controller or a service can ask$bookshelf-&gt;removeBook($book), but only the $bookshelf knows if the book was actually removed. And if the event actually happened, the entity can tell the world about it by recording a BookRemoved event.  Some problems might tempt you to inject a service into your entity. With domain events, you can avoid that. Your entity can dispatch an event, and you can set up a listener to react to that event. The relevant services can then correctly act on your entity, instead of the other way around.  ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#features","content":" Works out of the box. No configuration is required for basic features.Simple, unopinionated architecture. Uses plain event objects, and doesn't require much from your domain entities.Uses standard Symfony's EventDispatcher, with the same dispatching semantics &amp; listener registrations.Transaction support.Works with multiple entity managers.Multiple events considered identical are dispatched only once.Four listening strategies: immediate, pre-flush, post-flush, and event bus.Uses Symfony Messenger as the event bus implementation.Utilizes the transactional outbox pattern when publishing events to the event bus to guarantee consistency and delivery.Utilizes Symfony Scheduler to relay undelivered events to the event bus.Does not require you to change how you work with entities.Should work everywhere without any change: in controllers, message handlers, command line, etc.Separated contracts &amp; framework. Useful for enforcing architectural boundaries. Your domain doesn't have to depend on the framework.Symfony Profiler integration. Debug your events in the profiler's events panel.  ","version":"Next","tagName":"h2"},{"title":"To Do‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#to-do","content":" Support for Doctrine MongoDB ODM.Support event inheritance.  ","version":"Next","tagName":"h2"},{"title":"Synopsis‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#synopsis","content":" // // The event // final readonly class PostPublished { public function __construct(public string $postId) {} } // // The entity // use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface; use Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait; class Post implements DomainEventEmitterInterface { use DomainEventEmitterTrait; // ... public function setStatus(string $status): void { $originalStatus = $this-&gt;status; $this-&gt;status = $status; // records the published event if the new status is published and it // is different from the original status if ($status === 'published' &amp;&amp; $originalStatus !== $status) { $this-&gt;recordEvent(new PostPublished($this-&gt;id)); } } // ... } // // The listener // use Psr\\Log\\LoggerInterface; use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPostFlushDomainEventListener; class PostEventListener { public function __construct(private LoggerInterface $logger) {} // will be called after the post is published and the entity manager is // flushed #[AsPostFlushDomainEventListener] public function onPostPublished(PostPublished $event) { $postId = $event-&gt;postId; $this-&gt;logger-&gt;info(&quot;Post $postId has been published.&quot;); } } // // The caller // use Doctrine\\ORM\\EntityManagerInterface; /** @var Post $post */ /** @var EntityManagerInterface $entityManager */ $post-&gt;setStatus('published'); $entityManager-&gt;flush(); // the event will be dispatched after the flush above, afterwards the listener // above will be called, sending a message to the logger   ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony Flex Open a command console, enter your project directory and execute: composer require rekalogika/domain-event   ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/domain-event/intro#contributing","content":" This framework consists of multiple repositories split from a monorepo. Be sure to submit issues and pull requests to therekalogika/domain-event-src monorepo. ","version":"Next","tagName":"h2"},{"title":"Testing","type":0,"sectionRef":"#","url":"/domain-event/testing","content":"","keywords":"","version":"Next"},{"title":"Undispatched Event Problem‚Äã","type":1,"pageTitle":"Testing","url":"/domain-event/testing#undispatched-event-problem","content":" Rekalogika\\DomainEvent\\Exception\\UndispatchedEventsException: There are still 1 undispatched domain events. If you disable autodispatch, you have to dispatch them manually or clear them.  Our entity manager checks if there are any undispatched domain events in__destroy(). If there are, it throws an exception. This poses a problem in unit tests, especially with negative tests.  To prevent the problem, you need to prevent entity manager from going out of scope. In setUp(), save the entity manager to a property, then intearDown(), call clearUndispatchedEvents() on the entity manager.  use Symfony\\Bundle\\FrameworkBundle\\Test\\KernelTestCase; use Rekalogika\\DomainEvent\\DomainEventAwareEntityManagerInterface; class SomeTest extends KernelTestCase { protected DomainEventAwareEntityManagerInterface $entityManager; public function setUp(): void { parent::setUp(); $this-&gt;entityManager = self::getContainer()-&gt;get(DomainEventAwareEntityManagerInterface::class); } public function tearDown(): void { $this-&gt;entityManager-&gt;clearUndispatchedEvents(); parent::tearDown(); } // ... }   ","version":"Next","tagName":"h2"},{"title":"Immediate Dispatcher in Unit Tests‚Äã","type":1,"pageTitle":"Testing","url":"/domain-event/testing#immediate-dispatcher-in-unit-tests","content":" RuntimeException: ImmediateDomainEventDispatcher has not been initialized.  Immediate event dispatcher works by installing the event dispatcher to a static variable. This installation happens during the kernel boot.  If the kernel is not booted, there is no opportunity to install the event dispatcher. This usually happens only in isolated unit tests. To address the problem, you can install a stub event dispatcher manually like this.  use PHPUnit\\Framework\\TestCase; use Rekalogika\\DomainEvent\\ImmediateDomainEventDispatcherInstaller; use Symfony\\Component\\EventDispatcher\\EventDispatcher; class SomeTest extends TestCase { public function setUp(): void { $installer = new ImmediateDomainEventDispatcherInstaller(new EventDispatcher); $installer-&gt;install(); } // ... }   note The stub dispatcher doesn't do anything. If you want to test the dispatching, you need to get the real dispatcher from the container.  tip This is not necessary if your test extends KernelTestCase because it will boot the kernel for you automatically. ","version":"Next","tagName":"h2"},{"title":"Tips","type":0,"sectionRef":"#","url":"/domain-event/tips","content":"","keywords":"","version":"Next"},{"title":"Use UUIDs as Identifiers‚Äã","type":1,"pageTitle":"Tips","url":"/domain-event/tips#use-uuids-as-identifiers","content":" Use UUIDs as entity identifiers &amp; have the entities generate one for themselves on instantiation. That means new entities already have an ID before flush().  use Symfony\\Component\\Uid\\UuidV7; class Post { private string $id; public function __construct(string $title) { $this-&gt;id = new UuidV7(); } // ... }   This way, you can reliably store the ID in your event objects, instead of the object itself. Using the ID in the events means your events can be reliably serialized. It improves logistics because you can pass them anywhere without modification, and without creating additional event objects.  ","version":"Next","tagName":"h2"},{"title":"Persist Early after Entity Creation‚Äã","type":1,"pageTitle":"Tips","url":"/domain-event/tips#persist-early-after-entity-creation","content":" On entity creation, persist() your entities early, and flush() late. This is especially important if you are using the immediate listening strategy. It will let your listener obtain the entity instance by calling find() on the repository using the entity's identifier.  $post = new Post(); $entityManager-&gt;persist($post); $post-&gt;setContent('Hello, World!'); $entityManager-&gt;flush();   ","version":"Next","tagName":"h2"},{"title":"Choosing Dispatching Strategy‚Äã","type":1,"pageTitle":"Tips","url":"/domain-event/tips#choosing-dispatching-strategy","content":" If you want to do something similar to what you are used to doing with application events, you probably want the post-flush strategy. If you are already using Symfony Messenger, consider using the event bus strategy instead for more reliability.  Use pre-flush events to make alterations to your domain that will beflush()-ed together along with the other changes.  ","version":"Next","tagName":"h2"},{"title":"No Event Inheritance, Yet‚Äã","type":1,"pageTitle":"Tips","url":"/domain-event/tips#no-event-inheritance-yet","content":" Symfony Event Dispatcher does not currently support event inheritance. This needs to be mentioned because many programmers expect an event dispatcher to support event inheritance, especially when working with a large amount of event objects.  This is not ideal, and we want this feature in the future. But for now, this is a limitation that you need to be aware of.  ","version":"Next","tagName":"h2"},{"title":"Idempotent Event Bus Listeners‚Äã","type":1,"pageTitle":"Tips","url":"/domain-event/tips#idempotent-event-bus-listeners","content":" Idempotence is a desirable trait in event bus messaging. This means if a listener receives the same event multiple times, it should have the same effect as if it received the event only once.  With an event bus, a system failure might cause the same event to be dispatched more than once. An idempotent listener won't cause any harm when that happens.  In simpler cases, you can leverage EquatableDomainEventInterface. If your event implements EquatableDomainEventInterface, your listener can get the event's signature and store it somewhere. If the event is dispatched again, the listener can check if it has already processed the event. ","version":"Next","tagName":"h2"},{"title":"Transactions","type":0,"sectionRef":"#","url":"/domain-event/transaction","content":"","keywords":"","version":"Next"},{"title":"Semantics‚Äã","type":1,"pageTitle":"Transactions","url":"/domain-event/transaction#semantics","content":" Immediate events are dispatched immediately as usual.Pre-flush events will be dispatched before every flush() regardless of the transaction status.Post-flush events will be dispatched after the outermost commit().rollback() clears the pending post-flush events collected during the transaction, but retains the events collected before the transaction.The events are collected only on flush().  ","version":"Next","tagName":"h2"},{"title":"Managing Transaction Using DBAL is not Supported‚Äã","type":1,"pageTitle":"Transactions","url":"/domain-event/transaction#managing-transaction-using-dbal-is-not-supported","content":" warning Doing the transaction by hand using DBAL's Connection is not supported. Always do the transaction using entity manager's methods of beginTransaction(),commit(), rollback(), transactional() and wrapInTransaction().  Don't do like this snippet taken from Doctrine's documentation:  // warning: don't do this $em-&gt;getConnection()-&gt;beginTransaction(); // üëé try { // ... do some work $user = new User; $user-&gt;setName('George'); $em-&gt;persist($user); $em-&gt;flush(); $em-&gt;getConnection()-&gt;commit(); // üëé } catch (Exception $e) { $em-&gt;getConnection()-&gt;rollBack(); // üëé throw $e; }   Instead, do this:  $em-&gt;beginTransaction(); // üëç try { // ... do some work $user = new User; $user-&gt;setName('George'); $em-&gt;persist($user); $em-&gt;flush(); $em-&gt;commit(); // üëç } catch (Exception $e) { $em-&gt;rollback(); // üëç throw $e; }  ","version":"Next","tagName":"h2"},{"title":"Transactional Outbox Pattern","type":0,"sectionRef":"#","url":"/domain-event/transactional-outbox-pattern","content":"","keywords":"","version":"Next"},{"title":"How It Works‚Äã","type":1,"pageTitle":"Transactional Outbox Pattern","url":"/domain-event/transactional-outbox-pattern#how-it-works","content":" During the same time as the pre-flush phase, for each of the domain events, the framework wraps the event in a Symfony Messenger Envelope, and then in anOutboxMessage object. Then, it calls the entity manager to persist theOutboxMessage object.  When flush() or commit() is finally called, Doctrine will save theOutboxMessage objects in the same transaction as the rest of the changes to the domain entities. This guarantees that the events are published only if the transaction is successful.  When the message relay is executed. It reads the outbox table, publishes the events to the event bus, and removes the events from the outbox table.  ","version":"Next","tagName":"h2"},{"title":"Comparison with the Post-Flush Strategy‚Äã","type":1,"pageTitle":"Transactional Outbox Pattern","url":"/domain-event/transactional-outbox-pattern#comparison-with-the-post-flush-strategy","content":" With the post-flush strategy, if an error happens during the dispatching, then the event will be lost.  In contrast, the transactional outbox pattern guarantees that the event will be delivered. If an error happens, both the events and the entire changes to the domain model will not be committed to the database. Because all the other changes are rolled back, the discarded events would have been invalid anyway, and should not be delivered.  ","version":"Next","tagName":"h2"},{"title":"Message Relay‚Äã","type":1,"pageTitle":"Transactional Outbox Pattern","url":"/domain-event/transactional-outbox-pattern#message-relay","content":" Message relay's job is to read the outbox table, publish the events to the event bus, and remove the events from the outbox table. The message relay is executed using the following mechanisms:  Using the kernel.terminate and console.terminate events, a listener checks if there are new messages sent to the outbox in the current session. If there are, it tells the message relay to run using Symfony Messenger bus.Using Symfony Scheduler, the message relay is executed every hour. This is mainly used for safety, in case the above mechanism failed to execute for whatever reason.Manually, using the console command bin/console rekalogika:domain-event:relay.  ","version":"Next","tagName":"h2"},{"title":"Message Preparer‚Äã","type":1,"pageTitle":"Transactional Outbox Pattern","url":"/domain-event/transactional-outbox-pattern#message-preparer","content":" When the domain events are being saved to the outbox table, the message preparer services are executed to prepare the events. By default, it adds theUserIdentifierStamp to the envelope. You can add your own message preparer by implementing the MessagePreparerInterface (tag name:rekalogika.domain_event.outbox.message_preparer) ","version":"Next","tagName":"h2"},{"title":"rekalogika/file","type":0,"sectionRef":"#","url":"/file","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/file","url":"/file#sections","content":" üìÑÔ∏è Introduction High-level file abstraction library built on top of Flysystem. It lets you work üìÑÔ∏è Installation &amp; Configuration This section explains how to install and configure the rekalogika/file üìÑÔ∏è Concepts &amp; Terms Terms üìÑÔ∏è Using File &amp; FileRepository When using this framework, the user will primarily work with the üìÑÔ∏è Adapters The library provides a FileAdapter class that can be used to adapt or convert üìÑÔ∏è Metadata This chapter describes how file metadata is handled by this library. üìÑÔ∏è Derivation This chapter describes the concept of file derivation and the pipe &amp; filter üìÑÔ∏è Lazy-Loading Proxy This chapter describes how to lazy-load a file. üìÑÔ∏è Null File This chapter describes the null object pattern applied to files. ","version":"Next","tagName":"h2"},{"title":"rekalogika/file-bundle","type":0,"sectionRef":"#","url":"/file-bundle","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/file-bundle","url":"/file-bundle#sections","content":" üìÑÔ∏è Introduction Symfony bundle to easily integrate the rekalogika/file framework and related üìÑÔ∏è Installation &amp; Configuration This chapter describes how to install and configure the bundle. üìÑÔ∏è Associating Files to Doctrine Entities This chapter describes how to create a file property in a Doctrine entity that üìÑÔ∏è Working With Entities &amp; Files You can work with the entities and associated files as usual, and they will work üìÑÔ∏è File Uploads Using FilePond This chapter describes how to easily create a form for uploading files. üìÑÔ∏è Integration With Symfony Components This chapter describes how to integrate this framework with the typical Symfony üìÑÔ∏è Serving Files This chapter describes how to serve files to the client web browser. üìÑÔ∏è Filtering In this framework, 'filtering' is the opportunistic creation &amp; caching of üìÑÔ∏è Translation This chapter explains localization support in the framework. üìÑÔ∏è Mandatory File This chapter explains the situation where a file is mandatory to the entity. üìÑÔ∏è Lazy-Loading Files This chapter describes how to implement the lazy-loading of files in your üìÑÔ∏è Replicating Metadata in Entities This chapter describes how to replicate file metadata in your entities. üìÑÔ∏è Implementing a Collection of Files This chapter describes how to implement a collection of files, or one-to-many üìÑÔ∏è Streaming a ZIP File of Files This chapter explains how to stream-download a ZIP file containing several üìÑÔ∏è Command Line Utilities Currently there is one command line utility available in the bundle. üóÉÔ∏è File Location 3 items üóÉÔ∏è Advanced 3 items ","version":"Next","tagName":"h2"},{"title":"Creating Filters","type":0,"sectionRef":"#","url":"/file-bundle/advanced/creating-filters","content":"Creating Filters This chapter explains how to create your own file filters usingAbstractFileFilter. Preparation You need to install the package rekalogika/file-derivation to use this feature: composer require rekalogika/file-derivation To create a filter class, you can extend AbstractFileFilter, create a method (or more) for the callers to specify the filtering parameters, and implement all the abstract methods. The following is an example filter class that creates a derived file by (rather uselessly) appending a text to the original content: use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Derivation\\Filter\\AbstractFileFilter; use Rekalogika\\File\\TemporaryFile; class TextAppender extends AbstractFileFilter { private string $text; /** * Your custom method that lets the caller specify the filtering parameters. */ public function appendText(string $text): self { assert(ctype_alpha($text)); // ensure alpha characters only $this-&gt;text = $text; return $this; } /** * This method return the derivation ID from the filtering parameters the * caller provided. */ #[\\Override] protected function getDerivationId(): string { return 'append_' . $this-&gt;text; } #[\\Override] protected function process(): FileInterface { $originalContent = $this-&gt;getSourceFile()-&gt;getContent(); return new TemporaryFile::createFromString($originalContent . $this-&gt;text); } } If you are using autoconfiguration, then you are all set. Otherwise, you need to tag your class with rekalogika.file.derivation.filter: config/services.yaml services: App\\TextAppender: tags: - { name: 'rekalogika.file.derivation.filter' } A caller will be able to use the above filter like the following: use Rekalogika\\Contracts\\File\\FileInterface; /** @var TextAppender $textAppender */ /** @var FileInterface $file */ $derivedFile = $textAppender -&gt;take($file) -&gt;appendText('foo') -&gt;getResult(); ","keywords":"","version":"Next"},{"title":"Object ID Resolver","type":0,"sectionRef":"#","url":"/file-bundle/advanced/object-id-resolver","content":"","keywords":"","version":"Next"},{"title":"Creating An Object ID Resolver‚Äã","type":1,"pageTitle":"Object ID Resolver","url":"/file-bundle/advanced/object-id-resolver#creating-an-object-id-resolver","content":" use Rekalogika\\Contracts\\File\\Association\\ObjectIdResolverInterface; class MyObjectIdResolver implements ObjectIdResolverInterface { public function getObjectId(object $object): string { // your implementation here } }   If you are using autoconfiguration, then it is all set. If not, you need to register your class in the service container:  config/services.yaml services: App\\MyObjectIdResolver: tags: - { name: 'rekalogika.file.association.object_id_resolver' }  ","version":"Next","tagName":"h2"},{"title":"Marking Entities using Interface","type":0,"sectionRef":"#","url":"/file-bundle/advanced/file-association-interface","content":"Marking Entities using Interface As an alternative to using attributes to mark your entities, you can also have your entities implement FileAssociationInterface. note We recommend using attributes instead of implementing the interface as described in Associating Files with Doctrine Entities. use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\Association\\FileAssociationInterface; class Product implements FileAssociationInterface { /** * The file properties must accept FileInterface */ private ?FileInterface $image = null; /** * This method gives the list of properties of this class that will * be managed by this framework. In this case it tells us that the * property 'image' is a file property we need to manage. */ public static function getFileAssociationPropertyList(): array { return ['image']; } /** * The framework needs the ID of the entity. By default, it will call getId() * of the object to get the ID. */ public function getId(): string { return $this-&gt;id; } // // The rest of this class is inconsequential to the framework // /** * This framework reads and writes directly to the properties, even if * private. Therefore, you are free to have your own business logic in the * getters and setters. */ public function getImage(): FileInterface { if (date('m-d') == '04-01') { // if today is april 1st return new File('shock-image.jpg'); // april fools! } return $this-&gt;image; } public function setImage(?FileInterface $image): self { if ($this-&gt;status == 'published') { throw new \\Exception(&quot;Cannot change a published product's image&quot;); } $this-&gt;image = $image; return $this; } } ","keywords":"","version":"Next"},{"title":"Command Line Utilities","type":0,"sectionRef":"#","url":"/file-bundle/cli","content":"","keywords":"","version":"Next"},{"title":"rekalogika:file:resolve‚Äã","type":1,"pageTitle":"Command Line Utilities","url":"/file-bundle/cli#rekalogikafileresolve","content":" This command is used to resolve the file path for a given property of an object managed by Doctrine.  $ php bin/console rekalogika:file:resolve &lt;entity&gt; &lt;id&gt; &lt;property&gt; # Example: $ php bin/console rekalogika:file:resolve 'App\\Entity\\Article' 01955f6c-f3ff-7830-b78b-1b06603c1c98 image  ","version":"Next","tagName":"h2"},{"title":"Where The Files Are Stored","type":0,"sectionRef":"#","url":"/file-bundle/file-location/file-location","content":"","keywords":"","version":"Next"},{"title":"Default Algorithm‚Äã","type":1,"pageTitle":"Where The Files Are Stored","url":"/file-bundle/file-location/file-location#default-algorithm","content":" The default implementation DefaultClassBasedFileLocationResolverstores files into the filesystem with the identifier 'default' and the key similar to the following:  entity/ffa87ef3fc5388bc8b666e2cec17d27cc493d0c1/image/e5/80/72/6d/31337 ‚ï∞----‚ïØ ‚ï∞--------------------------------------‚ïØ ‚ï∞---‚ïØ ‚ï∞---------‚ïØ ‚ï∞---‚ïØ A B C D E   A: Prefix, defaults to 'entity'.B: The class signature, by default it is the SHA-1 hash of the entity's fully-qualified class name.C: Property name.D: Hashed directories of the entity's ID. The ID is hashed using SHA-1, then split by 2 characters each. Then, the first four of them are taken to form the directory structure.E: The entity ID.  This default should be sufficient in most cases, for all entities, and all types of file system. It is chosen with the following objectives in mind:  It masks internal details (entity class names) because we may need to expose the name to the Internet.It does not store too many files in a single directory because some file system types struggle with a huge number of files in a directory.The ordering is chosen to make it easier for manual administration tasks.  To obtain the entity's ID, DefaultFileLocationResolver callsObjectIdResolverInterface. By default, it is DoctrineObjectIdResolver which obtains the ID from Doctrine Entity Manager.  DefaultFileLocationResolver then usesClassBasedFileLocationResolverInterface to determine the location of the file which ultimately provides the above logic.  ","version":"Next","tagName":"h2"},{"title":"Determining the File Location‚Äã","type":1,"pageTitle":"Where The Files Are Stored","url":"/file-bundle/file-location/file-location#determining-the-file-location","content":" To determine the location of a file, you can use the rekalogika:file:resolvecommand. The command takes the entity class, the identifier, and the property name of the file in the class, in that order:  $ php bin/console rekalogika:file:resolve \\ 'App\\Entity\\Article' \\ 01955f6c-f3ff-7830-b78b-1b06603c1c98 \\ image   The information will also appear in Symfony's profiler panel.  ","version":"Next","tagName":"h2"},{"title":"About File Names‚Äã","type":1,"pageTitle":"Where The Files Are Stored","url":"/file-bundle/file-location/file-location#about-file-names","content":" Like modern key-value cloud storage services, this framework uses the concept of 'keys', not 'paths'. The file name is not used as the name of the key but is stored in the metadata, along with other properties of the file (file size, type, etc.). The original file name is never considered when determining where to store the file.  The metadata itself is stored in a sidecar file. Using the example above, the metadata will be stored in this location:  entity/ffa87ef3fc5388bc8b666e2cec17d27cc493d0c1/image/e5/80/72/6d/31337.metadata   The caller can obtain the file name using the appropriate methods:  $imageFilename = $entity-&gt;getImage()?-&gt;getName();   When possible, the framework should copy the file name of the original file to the destination metadata when the file was first associated with the entity.  ","version":"Next","tagName":"h2"},{"title":"How It Works‚Äã","type":1,"pageTitle":"Where The Files Are Stored","url":"/file-bundle/file-location/file-location#how-it-works","content":" The storage key of the file is deterministic. It is determined only by the object's class name, the object's ID, and the name of the property containing the file. As long as those don't change, the key will remain the same.  When persisting an entity, the framework will calculate the destination storage key of every applicable property of the entity, and compare it to the current file residing on each property:  If both are the same, the framework leaves it alone.If they are different, the framework will copy the file from the entity to the storage destination.If null, the framework will attempt to remove the file from the storage, irrespective of whether the file exists or not.  ","version":"Next","tagName":"h2"},{"title":"Architecture‚Äã","type":1,"pageTitle":"Where The Files Are Stored","url":"/file-bundle/file-location/file-location#architecture","content":" In a nutshell: Doctrine Unit Of Work ‚û°Ô∏è Doctrine Events ‚û°Ô∏èrekalogika/reconstitutor ‚û°Ô∏è InterfaceReconstitutor &amp;AttributeReconstitutor ‚û°Ô∏è ObjectManagerInterface ‚û°Ô∏èPropertyManagerInterface ‚û°Ô∏è FileRepository (from rekalogika/file).  InterfaceReconstitutor &amp; AttributeReconstitutor are the entry points of this package. They execute methods of ObjectManagerInterface which callsPropertyManagerInterface, which in turn works with the entities andFileRepository to manage the association between the entities and files.  InterfaceReconstitutor &amp; AttributeReconstitutor are registered to the service container so that they are called by our rekalogika/reconstitutor when the relevant events are being emitted by Doctrine. The service configuration is done by the package rekalogika/file-bundle. ","version":"Next","tagName":"h2"},{"title":"Overriding the Algorithm","type":0,"sectionRef":"#","url":"/file-bundle/file-location/overriding","content":"","keywords":"","version":"Next"},{"title":"File Location Resolver‚Äã","type":1,"pageTitle":"Overriding the Algorithm","url":"/file-bundle/file-location/overriding#file-location-resolver","content":" To override the general algorithm that determines where to store the files, you can create your own implementation of ClassBasedFileLocationResolverInterface. It takes the class name of the object, the ID, and the property name; then returns a FilePointerInterface.  For an example, see the class DefaultClassBasedFileLocationResolver.  ","version":"Next","tagName":"h2"},{"title":"Object ID Resolver‚Äã","type":1,"pageTitle":"Overriding the Algorithm","url":"/file-bundle/file-location/overriding#object-id-resolver","content":" ClassBasedFileLocationResolverInterface takes the object's ID as a string. To determine the ID, the framework uses ObjectIdResolverInterface.  You can create an ObjectIdResolverInterface if you need to override how the framework obtains an object's identifier. This is usually only necessary if your object's ID cannot be serialized to string, which should never happen in practice.  ","version":"Next","tagName":"h2"},{"title":"Class Signature Resolver‚Äã","type":1,"pageTitle":"Overriding the Algorithm","url":"/file-bundle/file-location/overriding#class-signature-resolver","content":" The framework calls ClassSignatureResolverInterface to convert the class name into its signature. This is done so that the class name does not appear in the file path. The default implementation is DefaultClassSignatureResolver which converts the class name into its SHA-1 hash.  Also available is AttributeClassSignatureResolver, it looks for theWithFileAssociation attribute on the class and uses the value of its argument as the class signature. This is useful if you are renaming a class as it would result in a different SHA-1 hash, and the framework would not be able to find previously stored files.  ","version":"Next","tagName":"h2"},{"title":"Manual Service Configuration‚Äã","type":1,"pageTitle":"Overriding the Algorithm","url":"/file-bundle/file-location/overriding#manual-service-configuration","content":" If you are not using autoconfiguration, you have to tag the services you created in the service container. Example:  services: App\\MyClassBasedFileLocationResolver: tags: - { name: 'rekalogika.file.association.class_based_file_location_resolver' } App\\MyObjectIdResolver: tags: - { name: 'rekalogika.file.association.object_id_resolver' } App\\MyClassSignatureResolver: tags: - { name: 'rekalogika.file.association.class_signature_resolver' }  ","version":"Next","tagName":"h2"},{"title":"Associating Files to Doctrine Entities","type":0,"sectionRef":"#","url":"/file-bundle/doctrine-entity","content":"","keywords":"","version":"Next"},{"title":"Creating a File Property in an Entity‚Äã","type":1,"pageTitle":"Associating Files to Doctrine Entities","url":"/file-bundle/doctrine-entity#creating-a-file-property-in-an-entity","content":" To create a file property in an entity that will be managed by this framework, you need to:  Create a property that accepts a FileInterface.Add the attribute #[WithFileAssociation] to the class.Add the attribute #[AsFileAssociation] to the property.  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Association\\Attribute\\WithFileAssociation; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; use Rekalogika\\File\\File; #[WithFileAssociation] class Product { /** * The file property must accept a FileInterface */ #[AsFileAssociation] private ?FileInterface $image = null; // // The rest of this class is inconsequential to the framework // /** * This framework reads and writes directly to the properties, even if * private. Therefore, you are free to have your own business logic in the * getters and setters. */ public function getImage(): FileInterface { if (date('m-d') == '04-01') { // if today is april 1st return new File('shock-image.jpg'); // april fools! } return $this-&gt;image; } public function setImage(?FileInterface $image): self { if ($this-&gt;status == 'published') { throw new \\Exception(&quot;Cannot change a published product's image&quot;); } $this-&gt;image = $image; return $this; } }   ","version":"Next","tagName":"h2"},{"title":"Mandatory File‚Äã","type":1,"pageTitle":"Associating Files to Doctrine Entities","url":"/file-bundle/doctrine-entity#mandatory-file","content":" If your business logic necessitates that the file is mandatory to an entity, you can omit the ? in the property type hint:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Association\\Attribute\\WithFileAssociation; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; #[WithFileAssociation] class Product { #[AsFileAssociation] private FileInterface $image; }   Read more about mandatory files in the chapter Mandatory File. ","version":"Next","tagName":"h2"},{"title":"Renaming Class","type":0,"sectionRef":"#","url":"/file-bundle/file-location/renaming-class","content":"Renaming Class If you rename a class, the framework will not be able to find the existing files associated with the class. This is because the framework uses the class name to determine where to store the files. By default, the framework uses the SHA-1 hash of the class name to determine the file location. If you rename the class, the SHA-1 hash will change, and the location of the files will change as well. To avoid this, you can use the WithFileAssociation attribute on the class to specify a custom class signature. This will allow you to rename the class without changing the file location. use Rekalogika\\File\\Attribute\\WithFileAssociation; #[WithFileAssociation('ffa87ef3fc5388bc8b666e2cec17d27cc493d0c1')] class Product { // ... } To obtain the class signature of the old class, you can apply SHA-1 to the old class name. For example, you can use a command line like this: $ echo -n 'App\\Entity\\Product' | sha1sum de668c84f52045975aafef2fc0cd7913dee79056 ","keywords":"","version":"Next"},{"title":"Installation & Configuration","type":0,"sectionRef":"#","url":"/file-bundle/installation","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Installation & Configuration","url":"/file-bundle/installation#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony Flex Open a command console, enter your project directory, and execute: composer require rekalogika/file-bundle   ","version":"Next","tagName":"h2"},{"title":"Configuration‚Äã","type":1,"pageTitle":"Installation & Configuration","url":"/file-bundle/installation#configuration","content":" The bundle should work out of the box without configuration. By default, it will create a filesystem identified by 'default' that stores files in the directory%kernel.project_dir%/var/storage/default.  The following is the default configuration:  config/packages/rekalogika_file.yaml rekalogika_file: filesystems: # our default filesystem service default: rekalogika.file.default_filesystem default_filesystem_directory: '%kernel.project_dir%/var/storage/default'   ","version":"Next","tagName":"h2"},{"title":"Integration With Flysystem Bundle‚Äã","type":1,"pageTitle":"Installation & Configuration","url":"/file-bundle/installation#integration-with-flysystem-bundle","content":" If you are using the Flysystem bundle, you can use the filesystems defined in the Flysystem bundle:  config/packages/rekalogika_file.yaml rekalogika_file: filesystems: # 'default.storage' is the filesystem key under 'flysystem.storages' # in config/packages/flysystem.yaml default: 'default.storage'  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/file-bundle/intro","content":"","keywords":"","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction","url":"/file-bundle/intro#features","content":" Works out of the box without configuration.DX improvement, less micro-management of entity-file relations.Requires only a single property in the entity for each associated file.Having said that, there is an option to replicate the file metadata in the entity, and it does so without changing how you work with the files.Trait and abstract class to ease implementing a one-to-many relation between an entity and multiple files.Reads and writes directly into the file properties, even if private. You are free to have business logic in the getters and setters.Doesn't require you to update another property of the entity (lastUpdated?) just to make sure the correct Doctrine events will be fired.Localization. Show strings in the user's language.Adapters for various Symfony components, including HttpFoundation, Form, and Validator.Image resizing filter.Temporary URL generation to files.Mandatory files (not null for file properties). Substitute the file with a null object if it is not found in the storage backend.Lazy loading for files.ZIP download of multiple files.Full-featured FilePond-based file upload form.Symfony data collector and profiler integration.  ","version":"Next","tagName":"h2"},{"title":"Demo‚Äã","type":1,"pageTitle":"Introduction","url":"/file-bundle/intro#demo","content":" This is the same demo as the official Symfony demo, but adds an image property to the posts using rekalogika/file-bundle:  https://github.com/rekalogika/file-demo  See the last few commits to see how it is done.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction","url":"/file-bundle/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/file-bundle/intro#contributing","content":" This framework consists of multiple repositories split from a monorepo. Be sure to submit issues and pull requests to therekalogika/file-src monorepo. ","version":"Next","tagName":"h2"},{"title":"Filtering","type":0,"sectionRef":"#","url":"/file-bundle/filtering","content":"","keywords":"","version":"Next"},{"title":"ImageResizer‚Äã","type":1,"pageTitle":"Filtering","url":"/file-bundle/filtering#imageresizer","content":" Preparation You need to install the package rekalogika/file-image to use this feature: composer require rekalogika/file-image   ","version":"Next","tagName":"h2"},{"title":"PHP Usage‚Äã","type":1,"pageTitle":"Filtering","url":"/file-bundle/filtering#php-usage","content":" In PHP files, you need to inject the ImageResizer class to your service or controller:  use Rekalogika\\File\\Image\\ImageResizer; use Rekalogika\\Contracts\\File\\FileInterface; /** @var ImageResizer $imageResizer */ /** @var FileInterface $image */ $resizedImage = $imageResizer -&gt;take($image) -&gt;resize(100, ImageResizer::ASPECRATIO_SQUARE) -&gt;getResult();   The first time it is called, the filter will create a 100-pixel-square-cropped image from the original image. The second time it is called, the filter will return the already created derived image.  If the original image is updated, the filter will create a new derived image and overwrite the old one.  ","version":"Next","tagName":"h3"},{"title":"Twig Usage‚Äã","type":1,"pageTitle":"Filtering","url":"/file-bundle/filtering#twig-usage","content":" In Twig templates, you can use the image_resize filter. For example:  &lt;img src=&quot;{{ image_file|image_resize(100, 'square')|temporary_url }}&quot; /&gt;   The example above will give us a temporary URL to a square-cropped image with a maximum width or height of 100 pixels from the original imageimage_file. ","version":"Next","tagName":"h3"},{"title":"Implementing a Collection of Files","type":0,"sectionRef":"#","url":"/file-bundle/collection","content":"","keywords":"","version":"Next"},{"title":"Summary‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#summary","content":" This is what we do to implement a one-to-many relation between an entity and several files:  Create a new entity that will represent a file. For convenience, we provideAbstractFile or FileTrait that your entity can extend or use. Create a one-to-many relation from an entity to the entity in #1.  Preparation You need to install the package rekalogika/file-association-entity to use this feature: composer require rekalogika/file-association-entity   ","version":"Next","tagName":"h2"},{"title":"The many-to-one Side‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#the-many-to-one-side","content":" In the following example, we will be creating an entity Product that will have multiple Images.  You will need your Product entity to extend AbstractFile. Alternatively, if your entity needs to extend another entity, you can use the trait FileTraitinstead.  By Extending AbstractFileBy Using FileTrait Create the Image entity by extending AbstractFile. The following are the relevant parts. use Doctrine\\ORM\\Mapping as ORM; use Rekalogika\\Domain\\File\\Association\\Entity\\AbstractFile; #[ORM\\Entity] class Image extends AbstractFile { // ... #[ORM\\ManyToOne(inversedBy: 'images')] #[ORM\\JoinColumn(nullable: false)] private ?Product $product = null; public function getProduct(): ?Product { return $this-&gt;product; } public function setProduct(?Product $product): static { $this-&gt;product = $product; return $this; } // ... }   ","version":"Next","tagName":"h2"},{"title":"The one-to-many Side‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#the-one-to-many-side","content":" The relevant parts:  use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; use Doctrine\\ORM\\Mapping as ORM; #[ORM\\Entity] class Product { // ... #[ORM\\OneToMany(mappedBy: 'product', targetEntity: Image::class, orphanRemoval: true)] private Collection $images; public function __construct() { $this-&gt;images = new ArrayCollection(); } /** * @return Collection&lt;int, Image&gt; */ public function getImages(): Collection { return $this-&gt;images; } public function addImage(Image $image): static { if (!$this-&gt;images-&gt;contains($image)) { $this-&gt;images-&gt;add($image); $image-&gt;setProduct($this); } return $this; } public function removeImage(Image $image): static { if ($this-&gt;images-&gt;removeElement($image)) { // set the owning side to null (unless already changed) if ($image-&gt;getProduct() === $this) { $image-&gt;setProduct(null); } } return $this; } // ... }   ","version":"Next","tagName":"h2"},{"title":"(Optional) Accepting FileInterface in the Adder‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#optional-accepting-fileinterface-in-the-adder","content":" For convenience, you might also want to modify the adder addImage above so that it also accepts an instance of FileInterface:  use Rekalogika\\Contracts\\File\\FileInterface; class Product { // ... public function addImage(Image|FileInterface $image): static { if (!$image instanceof Image) { $image = new Image($image); } if (!$this-&gt;images-&gt;contains($image)) { $this-&gt;images-&gt;add($image); $image-&gt;setProduct($this); } return $this; } // ... }   ","version":"Next","tagName":"h2"},{"title":"(Optional) Decorate the Collection Using FileCollection‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#optional-decorate-the-collection-using-filecollection","content":" In the getter, you can also return a FileCollection wrapping the original collection, and change the type hint. Then, the caller will be able to know that the Collection contains files and also an instance of DirectoryInterface.  use Rekalogika\\Domain\\File\\Association\\Entity\\FileCollection; class Product { // ... /** * @return FileCollection&lt;int,Image&gt; */ public function getImages(): FileCollection { return new FileCollection( $this-&gt;images, sprintf('product %s images', $this-&gt;getName()) ); } // ... }   info The second argument of FileCollection is the name of the file collection, and will be used for the directory name, ZIP file name, etc. Read the chapter Stream a ZIP File if you need to download an entire collection as a ZIP file.  Protip There is also ReadableFileCollection, which is the read-only flavor ofFileCollection.  ","version":"Next","tagName":"h2"},{"title":"Using The Relation‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#using-the-relation","content":" By following the guide above, your Image entity is a FileInterface. Therefore, with the example above, you can treat the Image entity as a file.  use Rekalogika\\File\\File; $product = new Product(); $image1 = new File('product_image_1.jpg'); $image2 = new File('product_image_2.jpg'); $image3 = new File('product_image_3.jpg'); $product -&gt;addImage($image1) -&gt;addImage($image2) -&gt;addImage($image3); foreach ($product-&gt;getImages() as $image) { $name = $image-&gt;getName(); // product_image_1.jpg, etc. $description = $image-&gt;getType()-&gt;getDescription(); // &quot;JPEG image&quot;, etc. }   ","version":"Next","tagName":"h2"},{"title":"Indexing and Querying by File Properties‚Äã","type":1,"pageTitle":"Implementing a Collection of Files","url":"/file-bundle/collection#indexing-and-querying-by-file-properties","content":" AbstractFile uses EmbeddedMetadata under the hood. Read more about it in theReplicating Metadata in Entities section. ","version":"Next","tagName":"h2"},{"title":"File Uploads Using FilePond","type":0,"sectionRef":"#","url":"/file-bundle/file-upload-filepond","content":"","keywords":"","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"File Uploads Using FilePond","url":"/file-bundle/file-upload-filepond#features","content":" Uses FilePond in the frontend, and Symfony Form in the backend.DX improvement. Simply add a field to your form using FilePondType orFilePondCollectionType and you get file upload, image preview, file removal, and all the other features.To upload, users can browse the files, use drag and drop, or copy &amp; paste them.Looks nice out of the box.No need to write any JavaScript code. Options are supplied using HTML attributes.Upload files along with the other properties of your entity, no need to create a separate form, controller, or logic just for uploading files and removing them.Localization support. Automatically detects the user's locale and displays messages in the correct language.Image preview of uploaded files &amp; images. Also shows the preview for previously uploaded files when editing an entity.To delete the file, users can use the remove button on the preview and submit the form.Ships with the kitchen sink. Includes all the plugins that can be configured without Javascript, and all the available locales.  ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"File Uploads Using FilePond","url":"/file-bundle/file-upload-filepond#installation","content":" Preinstallation checklists:  Make sure Composer is installed globally, as explained in the installation chapter of the Composer documentation.Make sure you haveStimulusBundleconfigured in your app.Make sure your project has Symfony Flex installed and enabled (it is enabled by default).  Open a command console, enter your project directory, and execute:  composer require rekalogika/file-filepond   If you're using WebpackEncore, install your assets and restart Encore (not needed if you're using AssetMapper):  YarnNPM yarn install --force yarn watch   ","version":"Next","tagName":"h2"},{"title":"Usage for a Single File Property‚Äã","type":1,"pageTitle":"File Uploads Using FilePond","url":"/file-bundle/file-upload-filepond#usage-for-a-single-file-property","content":" Simply add your field to your form, using the form type FilePondType. Example:  use Rekalogika\\File\\Bridge\\FilePond\\FilePondType; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\FormBuilderInterface; class MyFormType extends AbstractType { public function buildForm(FormBuilderInterface $builder, array $options): void { $builder // ... -&gt;add('image', FilePondType::class, [ 'label' =&gt; 'Product Image', 'required' =&gt; false, 'attr' =&gt; [ 'accept' =&gt; 'image/png, image/jpeg' ], 'allow_delete' =&gt; true, ]) ; } }   If allow_delete is true, then the file will be removed on form submission if the user removes the file using the remove button on the preview.  ","version":"Next","tagName":"h2"},{"title":"Usage for a Collection of Files‚Äã","type":1,"pageTitle":"File Uploads Using FilePond","url":"/file-bundle/file-upload-filepond#usage-for-a-collection-of-files","content":" First, you need to set up the relation in your entity like what is described inImplementing a Collection of Files. Then you can useFilePondCollectionType. Example:  use Rekalogika\\File\\Bridge\\FilePond\\FilePondCollectionType; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\FormBuilderInterface; class MyFormType extends AbstractType { public function buildForm(FormBuilderInterface $builder, array $options): void { $builder // ... -&gt;add('images', FilePondCollectionType::class, [ 'label' =&gt; 'Product Images', 'required' =&gt; false, 'attr' =&gt; [ 'accept' =&gt; 'image/png, image/jpeg' ], 'allow_delete' =&gt; true, ]); ; } }   If allow_delete is true, then the file will be removed on form submission if the user removes the file using the remove button on the preview.  ","version":"Next","tagName":"h2"},{"title":"Specifying Options‚Äã","type":1,"pageTitle":"File Uploads Using FilePond","url":"/file-bundle/file-upload-filepond#specifying-options","content":" You can specify FilePond options using the attr option of the form field. The example below will disable replacing files.   -&gt;add('image', FilePondType::class, [ 'attr' =&gt; [ 'data-allow-replace' =&gt; 'false' ], ])   The list of available options can be found in the FilePond propertiesdocumentation.  To specify the option, you need to convert from camelCase to kebab-case, and prefix the property name with data-. For example, the property allowReplacebecomes data-allow-replace.  We also use several plugins that add additional options. You can read thedocumentation of each of the plugins to see what options are available.  This is the list of the enabled plugins:  File EncodeFile MetadataFile PosterFile ValidateSizeFile ValidateTypeImage CropImage EditImage ExifOrientationImage PreviewImage ResizeImage TransformImage ValidateSize ","version":"Next","tagName":"h2"},{"title":"Lazy-Loading Files","type":0,"sectionRef":"#","url":"/file-bundle/lazy-loading","content":"","keywords":"","version":"Next"},{"title":"Property Set-Up‚Äã","type":1,"pageTitle":"Lazy-Loading Files","url":"/file-bundle/lazy-loading#property-set-up","content":" To lazy-load files in your entities, simply add the parameter fetch: FetchMode::Lazy to the AsFileAssociation attribute:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; use Rekalogika\\File\\Association\\Model\\FetchMode; class Product { #[AsFileAssociation(fetch: FetchMode::Lazy)] private FileInterface $image; }   ","version":"Next","tagName":"h2"},{"title":"Getter Set-Up‚Äã","type":1,"pageTitle":"Lazy-Loading Files","url":"/file-bundle/lazy-loading#getter-set-up","content":" To preserve the normal behavior of your entity when using a lazy-loading proxy, you should also modify the getter of the property like this:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\FileProxy; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; class Product { #[AsFileAssociation(fetch: FetchMode::Lazy)] private FileInterface $image; public function getImage(): ?FileInterface { return FileProxy::getFile($this-&gt;image); } }   Protip You might want to make sure other methods in the entity don't use the property directly but use the getter instead.  info The class FileDecorator used in metadata replication and file collectionis aware of lazy-loading proxies, so you don't need to modify the getter as explained here if you are using FileDecorator.  ","version":"Next","tagName":"h2"},{"title":"Lazy-Loading Proxy and Mandatory Files‚Äã","type":1,"pageTitle":"Lazy-Loading Files","url":"/file-bundle/lazy-loading#lazy-loading-proxy-and-mandatory-files","content":" If you want both lazy-loading and mandatory files, please read the chapterMandatory File. ","version":"Next","tagName":"h2"},{"title":"Mandatory File","type":0,"sectionRef":"#","url":"/file-bundle/mandatory-file","content":"","keywords":"","version":"Next"},{"title":"Making a File Mandatory in an Entity‚Äã","type":1,"pageTitle":"Mandatory File","url":"/file-bundle/mandatory-file#making-a-file-mandatory-in-an-entity","content":" To make a file mandatory in an entity, you simply need to type-hint the file property with FileInterface instead of ?FileInterface:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Association\\Attribute\\WithFileAssociation; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; #[WithFileAssociation] class Product { #[AsFileAssociation] private FileInterface $image; }   By doing so, the framework will consider that the property has to be filled with a FileInterface object, one way or another.  ","version":"Next","tagName":"h2"},{"title":"If The File That is Supposed to be Present is not Present...‚Äã","type":1,"pageTitle":"Mandatory File","url":"/file-bundle/mandatory-file#if-the-file-that-is-supposed-to-be-present-is-not-present","content":" If the property is mandatory, but the actual file does not exist in the storage backend, the framework will substitute it with a MissingFile object. The situation is considered an error and will be logged as such. The administrator or the developer is expected to fix the problem.  The MissingFile object is an implementation of the null object pattern. It appears to your application like a normal file, and should not cause a fatal error; unless you are trying to operate on it that would cause a permanent effect, like saving it to an entity.  MissingFile is also an Exception, but is not thrown by the framework. You can treat it as a regular exception, including getting the stack trace from it.  For more information about NullFile in the framework, read the chapterNull File.  ","version":"Next","tagName":"h2"},{"title":"Mandatory File and Lazy-Loading Proxy‚Äã","type":1,"pageTitle":"Mandatory File","url":"/file-bundle/mandatory-file#mandatory-file-and-lazy-loading-proxy","content":" If you are using a lazy-loading proxy, the property will always be filled by an instance of FileInterface. However, the framework does not check if the file exists in the storage backend until you first try to access the file. If you want a mandatory file, you have to do it yourself:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\FileProxy; use Rekalogika\\Domain\\File\\Null\\NullFile; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; use Rekalogika\\File\\Association\\Model\\FetchMode; #[WithFileAssociation] class Product { #[AsFileAssociation(fetch: FetchMode::Lazy)] private FileInterface $image; public function getImage(): FileInterface { return FileProxy::getFile($this-&gt;image) ?? new NullFile; } }   Protip You might want to make sure other methods in the entity don't use the property directly but use the getter instead. ","version":"Next","tagName":"h2"},{"title":"Serving Files","type":0,"sectionRef":"#","url":"/file-bundle/serving-files","content":"","keywords":"","version":"Next"},{"title":"Streaming Files in a Symfony Controller‚Äã","type":1,"pageTitle":"Serving Files","url":"/file-bundle/serving-files#streaming-files-in-a-symfony-controller","content":" Preparation You need to install the package rekalogika/file-symfony-bridge to use this feature: composer require rekalogika/file-symfony-bridge   To send a file to the web browser, you can use FileResponse:  use Rekalogika\\File\\Bridge\\Symfony\\HttpFoundation\\FileResponse; use Rekalogika\\Contracts\\File\\FileInterface; use Symfony\\Component\\HttpFoundation\\Response; class SomeController { public function download(): Response { /** @var FileInterface $file */ $file = ...; return new FileResponse($file); } }   ","version":"Next","tagName":"h2"},{"title":"Generate a Temporary URL to a File‚Äã","type":1,"pageTitle":"Serving Files","url":"/file-bundle/serving-files#generate-a-temporary-url-to-a-file","content":" Rather than creating a controller action to serve a file for every possible situation, it is more convenient to generate a temporary URL to a file.  Preparation You need to install the package rekalogika/file-server to use this feature: composer require rekalogika/file-server If you are not using Symfony Flex, read the documentation ofrekalogika/file-bundle and rekalogika/temporary-url-bundle to learn how to register the required bundles.  ","version":"Next","tagName":"h2"},{"title":"PHP Usage‚Äã","type":1,"pageTitle":"Serving Files","url":"/file-bundle/serving-files#php-usage","content":" Wire in the TemporaryUrlGeneratorInterface service, and use thegenerateUrl() method to generate a temporary URL to a file. It accepts either a FileInterface or a FilePointerInterface.  use Rekalogika\\TemporaryUrl\\TemporaryUrlGeneratorInterface; use Rekalogika\\File\\FileInterface; use Rekalogika\\File\\FilePointerInterface; /** @var TemporaryUrlGeneratorInterface $temporaryUrlGenerator */ /** @var FileInterface|FilePointerInterface $file */ $url = $temporaryUrlGenerator-&gt;generateUrl($file);   ","version":"Next","tagName":"h3"},{"title":"Twig Usage‚Äã","type":1,"pageTitle":"Serving Files","url":"/file-bundle/serving-files#twig-usage","content":" In Twig templates, you can use the temporary_url filter to generate a temporary URL to a file.  &lt;a href=&quot;{{ file|temporary_url }}&quot; {{ temporary_url_autoexpire() }}&gt; Click here to download &lt;/a&gt;   With images, a convenient pattern is to chain the temporary_url filter with the image_resize filter from the rekalogika/file-image package.  &lt;img src=&quot;{{ my_image|image_resize(200)|temporary_url }}&quot; /&gt;   info The image_resize filter requires the rekalogika/file-image package: composer require rekalogika/file-image Read more in the Filtering section.  ","version":"Next","tagName":"h3"},{"title":"More Information‚Äã","type":1,"pageTitle":"Serving Files","url":"/file-bundle/serving-files#more-information","content":" The generateUrl() method and the temporary_url Twig filter accept several options. Read the documentation of rekalogika/temporary-url-bundle to learn more. ","version":"Next","tagName":"h3"},{"title":"Translation","type":0,"sectionRef":"#","url":"/file-bundle/translation","content":"","keywords":"","version":"Next"},{"title":"Translatable Strings‚Äã","type":1,"pageTitle":"Translation","url":"/file-bundle/translation#translatable-strings","content":" The framework supports localization in several places, including:  File names. For displaying 'Untitled' in the UI if the file name is null.File type description. For displaying 'Unknown file type' if the file type is not recognized.  use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ $name = $file-&gt;getName(); // this is translatable $baseFileName = $file-&gt;getName()-&gt;getBase(); // also translatable $fullFileName = $file-&gt;getName()-&gt;getFull(); // translatable, too $typeDescription = $file-&gt;getType()-&gt;getDescription(); // translatable as well   ","version":"Next","tagName":"h2"},{"title":"Translation‚Äã","type":1,"pageTitle":"Translation","url":"/file-bundle/translation#translation","content":" The framework uses Symfony's translation contracts. To translate strings, you need to use the TranslatorInterface service:  use Rekalogika\\Contracts\\File\\FileInterface; use Symfony\\Contracts\\Translation\\TranslatorInterface; /** @var FileInterface $file */ /** @var TranslatorInterface $translator */ $fileName = $file-&gt;getName(); $translatedFileName = $fileName-&gt;trans($translator);   note File names are not translated. Only 'Untitled' and 'Unknown file type' are translated.  In Twig:  {# 'file' is an instance of FileInterface #} The file name is {{ file.name|trans }}   ","version":"Next","tagName":"h2"},{"title":"Using the Framework Without Translation‚Äã","type":1,"pageTitle":"Translation","url":"/file-bundle/translation#using-the-framework-without-translation","content":" All the translatable strings also implement Stringable. Therefore, if your application does not use translations, you can simply cast to string.  use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ $fileNameInString = (string) $file-&gt;getName();   ","version":"Next","tagName":"h2"},{"title":"Translating to Your Language‚Äã","type":1,"pageTitle":"Translation","url":"/file-bundle/translation#translating-to-your-language","content":" To add translations to your language, submit a pull request to the repository here:  github.com/rekalogika/file-src/tree/main/packages/file-bundle/translations  Use the English XLIFF as a template. ","version":"Next","tagName":"h2"},{"title":"Replicating Metadata in Entities","type":0,"sectionRef":"#","url":"/file-bundle/replicating-metadata-in-entities","content":"","keywords":"","version":"Next"},{"title":"Objective‚Äã","type":1,"pageTitle":"Replicating Metadata in Entities","url":"/file-bundle/replicating-metadata-in-entities#objective","content":" This framework gives you the convenience of requiring only a single property to associate a file with an entity. However, there are cases where it can be useful to have the file's metadata stored in the entity. For example:  To optimize performance together with our lazy-loading feature, especially when you are dealing with a lot of entities and/or files.You need to use the database to index, search, or sort the files based on their metadata.  Using the method described in this chapter, you will be able to accomplish that by replicating the files' metadata in your entities and it does not require you to change the way you work with files.  ","version":"Next","tagName":"h2"},{"title":"Execution‚Äã","type":1,"pageTitle":"Replicating Metadata in Entities","url":"/file-bundle/replicating-metadata-in-entities#execution","content":" Preparation You need to install the package rekalogika/file-association-entity to use this feature: composer require rekalogika/file-association-entity   In short, you need to:  Add a property with EmbeddedMetadata type. This is a Doctrine embeddablethat implements RawMetadataInterface we will be using to store the file's metadata.Modify the getter of the file property so that it returns a decorated version of the FileInterface that will use our EmbeddedMetadata in #1.Modify the setter of the file property so it will copy the metadata of a new file to our EmbeddedMetadata in #1.  If your original entity looks like this:  use Doctrine\\ORM\\Mapping\\Entity; use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Association\\Attribute\\WithFileAssociation; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; #[Entity] #[WithFileAssociation] class Product { #[AsFileAssociation] private ?FileInterface $image = null; public function getImage(): ?FileInterface { return $this-&gt;image; } public function setImage(?FileInterface $image): self { $this-&gt;image = $image; return $this; } }   You need to modify it to look like this:  use Doctrine\\ORM\\Mapping\\Embedded; use Doctrine\\ORM\\Mapping\\Entity; use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Domain\\File\\Association\\Entity\\EmbeddedMetadata; use Rekalogika\\Domain\\File\\Association\\Entity\\FileDecorator; use Rekalogika\\File\\Association\\Attribute\\WithFileAssociation; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; #[Entity] #[WithFileAssociation] class Product { #[AsFileAssociation] private ?FileInterface $image = null; #[Embedded] private EmbeddedMetadata $imageMetadata; public function __construct() { $this-&gt;imageMetadata = new EmbeddedMetadata(); } public function getImage(): ?FileInterface { return FileDecorator::getFile($this-&gt;image, $this-&gt;imageMetadata); } public function setImage(?FileInterface $image): self { FileDecorator::setFile($image, $this-&gt;image, $this-&gt;imageMetadata); return $this; } }   After the change, calling the setter will still give you a FileInterface that you can use like before. But behind the scenes, any reads to the metadata will be done from the data stored in the entity. And any writes to the metadata are saved to both the file and the entity.  info Because the metadata is now saved in the entity, after any changes to the metadata, you need to call flush() on the entity manager to save the metadata to the database.  ","version":"Next","tagName":"h2"},{"title":"Using The Metadata Fields for Querying and Indexing‚Äã","type":1,"pageTitle":"Replicating Metadata in Entities","url":"/file-bundle/replicating-metadata-in-entities#using-the-metadata-fields-for-querying-and-indexing","content":" EmbeddedMetadata is a Doctrine embeddable that contains the following fields:  name: The file name.size: The file size in bytes.type: The file MIME type.modificationTime: The file modification time.width: The width, if the file is an image.height: The height, if the file is an image.other: Other metadata that is not covered by the above fields.  You can use these fields (other than the other) to query and index the files in your database.  ","version":"Next","tagName":"h2"},{"title":"Mandatory File Properties‚Äã","type":1,"pageTitle":"Replicating Metadata in Entities","url":"/file-bundle/replicating-metadata-in-entities#mandatory-file-properties","content":" If your file property does not accept a null value, you need to modify the setter like the following.  use Doctrine\\ORM\\Mapping\\Entity; use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Domain\\File\\Association\\Entity\\FileDecorator; use Rekalogika\\Domain\\File\\Null\\NullFile; use Rekalogika\\File\\Association\\Attribute\\WithFileAssociation; use Rekalogika\\File\\Association\\Attribute\\AsFileAssociation; #[Entity] #[WithFileAssociation] class Product { // $image is not nullable #[AsFileAssociation] private FileInterface $image; // ... public function setImage(FileInterface $image): self { // make sure the image is not unset, otherwise the next line won't work $this-&gt;image = new NullFile(); // setFileMandatory is identical to setFile, except it does not accept // null value and works with properties that does not accept null FileDecorator::setFileMandatory($file, $this-&gt;file, $this-&gt;fileMetadata); return $this; } }  ","version":"Next","tagName":"h2"},{"title":"Integration With Symfony Components","type":0,"sectionRef":"#","url":"/file-bundle/symfony","content":"","keywords":"","version":"Next"},{"title":"Components Summary‚Äã","type":1,"pageTitle":"Integration With Symfony Components","url":"/file-bundle/symfony#components-summary","content":" Adapters to convert HttpFoundation File objects to a FileInterface and vice versa, with special handling for UploadedFile.FileResponse for streaming a FileInterface to the client web browser.FileType form that works with FileInterface objects.A form transformer FileTransformer that you can add to an existing SymfonyFileType fields so that it gives us a FileInterface instead of aUploadedFile object.A form extension FileTypeExtension that you can optionally register to automatically convert all the existing Symfony FileType so they all give us a FileInterface.Subclassed FileValidator and ImageValidator that works withFileInterface objects.  ","version":"Next","tagName":"h2"},{"title":"Adapters‚Äã","type":1,"pageTitle":"Integration With Symfony Components","url":"/file-bundle/symfony#adapters","content":" Converts a HttpFoundation File (and child classes, including UploadedFile) to a FileInterface:  use Rekalogika\\File\\Bridge\\Symfony\\HttpFoundation\\FromHttpFoundationFileAdapter; use Symfony\\Component\\HttpFoundation\\File\\File; /** @var File $httpFoundationFile */ $file = FromHttpFoundationFileAdapter::adapt($httpFoundationFile);   However, it is more convenient to use the universal adapter instead, although the universal adapter still needs this package to be installed.  use Symfony\\Component\\HttpFoundation\\File\\File; use Rekalogika\\File\\FileAdapter; /** @var File $httpFoundationFile */ $file = FileAdapter::adapt($httpFoundationFile);   Converts a FileInterface to a HttpFoundation File:  use Rekalogika\\File\\Bridge\\Symfony\\HttpFoundation\\ToHttpFoundationFileAdapter; use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ $httpFoundationFile = ToHttpFoundationFileAdapter::adapt($file);   ","version":"Next","tagName":"h2"},{"title":"Streaming a FileInterface‚Äã","type":1,"pageTitle":"Integration With Symfony Components","url":"/file-bundle/symfony#streaming-a-fileinterface","content":" To stream a FileInterface to the client's web browser, you can useFileResponse.  use Rekalogika\\File\\Bridge\\Symfony\\HttpFoundation\\FileResponse; use Rekalogika\\Contracts\\File\\FileInterface; use Symfony\\Component\\HttpFoundation\\Response; class SomeController { public function download(): Response { /** @var FileInterface $file */ $file = ...; return new FileResponse($file); } }   FileResponse accepts additional optional parameters:  $status: HTTP status code. Default: 200.$headers: Array of additional headers. Default: [].$disposition: Force the first parameter of the Content-Disposition header to the specified value. It can be attachment or inline. The filename is automatically taken from the metadata.  ","version":"Next","tagName":"h2"},{"title":"Forms‚Äã","type":1,"pageTitle":"Integration With Symfony Components","url":"/file-bundle/symfony#forms","content":" Protip You might want to use our FilePondType form type instead. See the chapterFile Upload With FilePond for more information.  We provide a FileType that works with FileInterface objects. This is basically the same as Symfony's FileType with a transformer built-in:  use Rekalogika\\File\\Bridge\\Symfony\\Form\\FileType; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\FormBuilderInterface; class SomeFormType extends AbstractType { public function buildForm(FormBuilderInterface $builder, array $options): void { $builder // ... -&gt;add('file', FileType::class, [ // ... ]) ; } }   If for some reason you cannot change the form type, you can useFileTransformer to transform existing fields. It should work with Symfony'sFileType and any third-party form types with a compatible behavior:  use Rekalogika\\File\\Bridge\\Symfony\\Form\\FileTransformer; use Symfony\\Component\\Form\\Extension\\Core\\Type\\FileType; use Symfony\\Component\\Form\\AbstractType; use Symfony\\Component\\Form\\FormBuilderInterface; class SomeFormType extends AbstractType { public function buildForm(FormBuilderInterface $builder, array $options): void { $builder -&gt;add('file', FileType::class, [ // ... ]); $builder-&gt;get('file')-&gt;addModelTransformer(new FileTransformer()); } }   You can also modify all the existing Symfony's FileType fields en masse by registering the FileTypeExtension:  config/services.yaml services: Rekalogika\\File\\Bridge\\Symfony\\Form\\FileTypeExtension: tags: - { name: form.type_extension }   ","version":"Next","tagName":"h2"},{"title":"Validators‚Äã","type":1,"pageTitle":"Integration With Symfony Components","url":"/file-bundle/symfony#validators","content":" We provide File and Image validators. They are the same as Symfony'sFile and Image validators, except that they work with FileInterfaceobjects instead of HttpFoundation File objects:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Bridge\\Symfony\\Constraints\\File as FileConstraint; use Rekalogika\\File\\Bridge\\Symfony\\Constraints\\Image as ImageConstraint; class Product { #[ImageConstraint(minWidth: '1000'] private ?FileInterface $photo = null; #[ImageConstraint(maxSize: '10000k'] private ?FileInterface $manual = null; // ... }   caution Due to how the adapters work, some validator functions might not work correctly, like those that check file names. ","version":"Next","tagName":"h2"},{"title":"Adapters","type":0,"sectionRef":"#","url":"/file/adapters","content":"Adapters The library provides a FileAdapter class that can be used to adapt or convert a file object from another library to our FileInterface. use Rekalogika\\File\\FileAdapter; use Rekalogika\\File\\FileInterface; // $theirFile is any of the supported file object $ourFile = FileAdapter::adapt($theirFile); assert($ourFile instanceof FileInterface); Currently supported objects: string: assumed to be a path to a local filePHP's SplFileInfoSymfony HttpFoundation File (and descendants, including the ubiquitousUploadedFile). Requires the rekalogika/file-symfony-bridge package.FileInterface of OneupUploaderBundle. Requires therekalogika/file-oneup-uploader-bridge package.","keywords":"","version":"Next"},{"title":"Working With Entities & Files","type":0,"sectionRef":"#","url":"/file-bundle/working-with-entities","content":"","keywords":"","version":"Next"},{"title":"Creating an entity, adding it to a file, & persisting it‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#creating-an-entity-adding-it-to-a-file--persisting-it","content":" use Doctrine\\ORM\\EntityManagerInterface; use Rekalogika\\File\\File; /** @var EntityManagerInterface $entityManager */ $product = new Product(); $image = new File('/tmp/image.png'); $product-&gt;setImage($image); $entityManager-&gt;persist($product); $entityManager-&gt;flush();   note The framework will copy the file to the storage location, and leave the original file alone. It is the responsibility of the caller to delete the original if it wishes to do so. If the file arrived from a file upload, PHP will delete the file automatically when the request ends.  ","version":"Next","tagName":"h2"},{"title":"Replacing an associated file‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#replacing-an-associated-file","content":" use Doctrine\\ORM\\EntityManagerInterface; use Rekalogika\\File\\File; /** @var EntityManagerInterface $entityManager */ /** @var Product $product */ $newImage = new File('/tmp/newImage.png') $product-&gt;setImage($newImage); $entityManager-&gt;flush();   ","version":"Next","tagName":"h2"},{"title":"Updating the metadata of an associated file‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#updating-the-metadata-of-an-associated-file","content":" use Doctrine\\ORM\\EntityManagerInterface; /** @var Product $product */ $product-&gt;getImage()?-&gt;setName('newImage.png');   note Files are not Doctrine entities. File modifications are carried out immediately, independent of Doctrine's flush().  ","version":"Next","tagName":"h2"},{"title":"Removing an associated file‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#removing-an-associated-file","content":" use Doctrine\\ORM\\EntityManagerInterface; /** @var EntityManagerInterface $entityManager */ /** @var Product $product */ $product-&gt;setImage(null); $entityManager-&gt;flush();   ","version":"Next","tagName":"h2"},{"title":"Removing the entity will also remove the associated file‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#removing-the-entity-will-also-remove-the-associated-file","content":" use Doctrine\\ORM\\EntityManagerInterface; /** @var EntityManagerInterface $entityManager */ /** @var Product $product */ $entityManager-&gt;remove($product); $entityManager-&gt;flush();   ","version":"Next","tagName":"h2"},{"title":"Copying Files Between Entities‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#copying-files-between-entities","content":" use Doctrine\\ORM\\EntityManagerInterface; /** @var EntityManagerInterface $entityManager */ /** @var Product $product1 */ /** @var Product $product2 */ $product2-&gt;setImage($product1-&gt;getImage()); $entityManager-&gt;flush();   ","version":"Next","tagName":"h2"},{"title":"Moving Files Between Entities‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#moving-files-between-entities","content":" use Doctrine\\ORM\\EntityManagerInterface; /** @var EntityManagerInterface $entityManager */ /** @var Product $product1 */ /** @var Product $product2 */ $product2-&gt;setImage($product1-&gt;getImage()); $product1-&gt;setImage(null); $entityManager-&gt;flush();   ","version":"Next","tagName":"h2"},{"title":"Caveat: Avoid Doctrine's Query::toIterable()‚Äã","type":1,"pageTitle":"Working With Entities & Files","url":"/file-bundle/working-with-entities#caveat-avoid-doctrines-querytoiterable","content":" Doctrine's documentation recommends usingQuery::toIterable()to iterate over large result sets. However, with Query::toIterable(), during the postLoad event, and in turn, when your onSave() method is called, the state of the entity is not guaranteed to be consistentas when loading the entity normally.  We recommend using our rekalogika/rekapager package instead. Read more in ourbatch processing documentation. ","version":"Next","tagName":"h2"},{"title":"Concepts & Terms","type":0,"sectionRef":"#","url":"/file/concepts","content":"","keywords":"","version":"Next"},{"title":"Terms‚Äã","type":1,"pageTitle":"Concepts & Terms","url":"/file/concepts#terms","content":" FileRepository: Manages files in the framework. ImplementsFileRepositoryInterface.File: A file in a Flysystem filesystem. Implements FileInterface. Each file is identified by a filesystem identifier and a key. A null filesystem identifier denotes that the file is in the local filesystem.FilePointer: A pointer to a file. Implements FilePointerInterface. Like a file, a file pointer has a filesystem identifier and a key, but nothing else.Directory: Contains files, file pointers, and other directories.Filesystem: A Flysystem filesystem. Implements Flysystem'sFilesystemOperator. The caller should not use it directly but use theFileRepository instead.Local filesystem: A special Flysystem filesystem initialized by the framework that points to an unscoped local filesystem, using '/' as its root location.  info A Flysystem filesystem using LocalFilesystemAdapter that is set up by the user is not considered a local filesystem in this document.  ","version":"Next","tagName":"h2"},{"title":"Class Diagram‚Äã","type":1,"pageTitle":"Concepts & Terms","url":"/file/concepts#class-diagram","content":" note 'Interface' in the names are stripped for brevity. Simple getters are represented by properties.    ","version":"Next","tagName":"h2"},{"title":"Keys vs Paths‚Äã","type":1,"pageTitle":"Concepts & Terms","url":"/file/concepts#keys-vs-paths","content":" The library encourages using the concept of 'keys', not 'paths'. Although the key can appear similar to a path, the main difference is that the filename is not part of the key, but part of the file's metadata. The key is similar to the primary key of a database table. You can change the 'name' field, but the ID usually stays the same. ","version":"Next","tagName":"h2"},{"title":"Derivation","type":0,"sectionRef":"#","url":"/file/derivation","content":"","keywords":"","version":"Next"},{"title":"Derivation‚Äã","type":1,"pageTitle":"Derivation","url":"/file/derivation#derivation","content":" FileInterface supports what we call 'derivation'. A file can have one or more derivations of itself. For example, an image file can have a thumbnail, medium, and large derivation. A derived file can also be derived further. For example, a thumbnail can be in the original aspect ratio, or square-cropped.  FileInterface provides the method getDerivation() that returns aFilePointer to the derived file. Our File objects ensure that a derivation cannot be made if the file is in the local filesystem, or in an ad-hoc filesystem, to avoid cluttering the local filesystem with unwanted files.  ","version":"Next","tagName":"h2"},{"title":"Low-Level Implementation‚Äã","type":1,"pageTitle":"Derivation","url":"/file/derivation#low-level-implementation","content":" At the low level, a derivation is created simply by appending the derivation ID to the original file's key. For example, if the original file's key is:  entity/ffa87ef3fc5388bc8b666e2cec17d27cc493d0c1/image/e5/80/72/6d/31337   then, with the derivation ID '100px', the derived file's key becomes:  entity/ffa87ef3fc5388bc8b666e2cec17d27cc493d0c1/image/e5/80/72/6d/31337.d/100px   Deleting the original file will also result in the deletion of all of its derivations.  Derivation can be nested. Suppose the derived file above will be derived further with the derivation ID of 'square', then the derived file's key becomes:  entity/ffa87ef3fc5388bc8b666e2cec17d27cc493d0c1/image/e5/80/72/6d/31337.d/100px.d/square   caution Because each derivation step requires a round trip to the storage backend, it is not recommended to nest derivations too deep.  ","version":"Next","tagName":"h2"},{"title":"Pipes & Filters Pattern‚Äã","type":1,"pageTitle":"Derivation","url":"/file/derivation#pipes--filters-pattern","content":" Derivation can be used as the building block of filters. A filter is a service that performs opportunistic creation and caching of a derived file from a source file.  A filter can be applied to a FileInterface and does the following:  Obtain the original file.Determine the derivation ID from the parameters provided by the caller. For example, if the caller wants to get a square thumbnail of an image, the filter can use the derivation ID like 'thumbnail-square'.Call FileInterface::getDerivation() to get a pointer to the derived file.Call FileRepository::get() to get the derived file. If the derived file does not exist, produce the derived file, and write to the pointer.If the derived file exists and is newer than the original file, return it.If the derived file exists and is older than the original file, produce the derived file, then overwrite the old derived file.  The caller can then use the filter to create a modified version of the original file without having to worry about the details.  We provide the packagerekalogika/file-derivation to streamline the creation of filters within the Symfony framework. ","version":"Next","tagName":"h2"},{"title":"Streaming a ZIP File of Files","type":0,"sectionRef":"#","url":"/file-bundle/zip-streaming","content":"","keywords":"","version":"Next"},{"title":"Concepts‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#concepts","content":" A DirectoryInterface represents a tree of files. It contains entries ofFileInterface, FilePointerInterface, or other DirectoryInterface. TheFileZip service turns a DirectoryInterface into a ZIP file.  The ZIP file is created on the fly and streamed to the client's web browser, and does not involve a temporary file. Therefore, the operation is relatively inexpensive.  note We are using the ZipStream-PHPpackage under the hood.  ","version":"Next","tagName":"h2"},{"title":"Basic Usage‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#basic-usage","content":" The FileZip::streamZip() method takes a DirectoryInterface and streams a ZIP file to the client's web browser.  use Rekalogika\\File\\Zip\\FileZip; use Rekalogika\\Contracts\\File\\DirectoryInterface; use Rekalogika\\File\\Directory; use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileZip $fileZip */ /** @var FileInterface $file1 */ /** @var FileInterface $file2 */ /** @var FileInterface $file3 */ $directory = new Directory('my_zip_file', [$file1, $file2, $file3]); $fileZip-&gt;streamZip($directory);   ","version":"Next","tagName":"h2"},{"title":"In Controllers‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#in-controllers","content":" To get an HTTP Foundation Response object, useFileZip::createZipResponse():  use Rekalogika\\File\\Zip\\FileZip; use Rekalogika\\File\\Directory; use Rekalogika\\Contracts\\File\\FileInterface; class SomeController { public function download(FileZip $fileZip): Response { /** @var FileInterface $file1 */ /** @var FileInterface $file2 */ /** @var FileInterface $file3 */ $directory = new Directory('my_zip_file', [$file1, $file2, $file3]); return $fileZip-&gt;createZipResponse($directory); } }   ","version":"Next","tagName":"h2"},{"title":"Dealing With Doctrine Collections Containing Files‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#dealing-with-doctrine-collections-containing-files","content":" To convert a Doctrine collection of files into a DirectoryInterface, you can use FileCollection.  use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\Domain\\File\\Association\\Entity\\FileCollection; use Rekalogika\\Contracts\\File\\DirectoryInterface; use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\File\\Directory; use Rekalogika\\File\\Zip\\FileZip; class SomeController { public function download(Product $product, FileZip $fileZip): Response { /** @var Collection&lt;int,Images&gt; */ $images = $product-&gt;getImages(); /** @var FileCollection */ $directoryOfImages = new FileCollection($images, 'product-image'); return $fileZip-&gt;createZipResponse($directoryOfImages); } }   ","version":"Next","tagName":"h2"},{"title":"Returning a DirectoryInterface in the Getter Itself‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#returning-a-directoryinterface-in-the-getter-itself","content":" FileCollection implements both DirectoryInterface and Collection. So, it is safe to return a FileCollection in the getter because it won't change the existing behavior of your getter.  use Rekalogika\\Domain\\File\\Association\\Entity\\FileCollection; class Product { // ... /** * @return FileCollection&lt;int,Image&gt; */ public function getImages(): FileCollection { return new FileCollection( $this-&gt;images, sprintf('product %s images', $this-&gt;getName()) ); } // ... }   Then, you can do something like this in the controller:  use Rekalogika\\File\\Zip\\FileZip; class SomeController { public function download(Product $product, FileZip $fileZip): Response { return $fileZip-&gt;createZipResponse($product-&gt;getImages()); } }   ","version":"Next","tagName":"h2"},{"title":"Creating a Link to the ZIP File‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#creating-a-link-to-the-zip-file","content":" The framework registers a temporary URL handler. So, you can simply useTemporaryUrlGeneratorInterface::generateUrl() to generate a temporary URL to the ZIP file.  use Rekalogika\\TemporaryUrl\\TemporaryUrlGeneratorInterface; /** @var TemporaryUrlGeneratorInterface $temporaryUrlGenerator */ /** @var FileCollection */ $images = $product-&gt;getImages(); $url = $temporaryUrlGenerator-&gt;generateUrl($images);   ","version":"Next","tagName":"h2"},{"title":"In Twig Templates‚Äã","type":1,"pageTitle":"Streaming a ZIP File of Files","url":"/file-bundle/zip-streaming#in-twig-templates","content":" In Twig templates, you can easily generate URLs to a ZIP file by using thetemporary_url filter with a DirectoryInterface as the input.  &lt;a href=&quot;{{ product.images|temporary_url }}&quot; {{ temporary_url_autoexpire() }}&gt; Download Product Images &lt;/a&gt;  ","version":"Next","tagName":"h2"},{"title":"Installation & Configuration","type":0,"sectionRef":"#","url":"/file/installation","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Installation & Configuration","url":"/file/installation#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  Open a command console, enter your project directory, and execute:  composer require rekalogika/file-bundle   ","version":"Next","tagName":"h2"},{"title":"Initialization‚Äã","type":1,"pageTitle":"Installation & Configuration","url":"/file/installation#initialization","content":" In your application, initialize the file repository like the following example:  use Rekalogika\\File\\FileFactory; use League\\Flysystem\\Filesystem; use League\\Flysystem\\Local\\LocalFilesystemAdapter; $fileFactory = new FileFactory( filesystems: [ 'default' =&gt; new Filesystem(new LocalFilesystemAdapter('/var/storage')), ] ); /** @var FileRepositoryInterface */ $fileRepository = $fileFactory-&gt;getFileRepository();   Read Flysystem documentation on how to initialize the filesystem. Once you have a Flysystem filesystem, you can pass it to our FileFactory. Then, use theFileFactory to create a FileRepositoryInterface instance. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/file/intro","content":"","keywords":"","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction","url":"/file/intro#features","content":" ","version":"Next","tagName":"h2"},{"title":"General Features‚Äã","type":1,"pageTitle":"Introduction","url":"/file/intro#general-features","content":" Rich, high-level abstraction of files built on top of Flysystem.Abstractions for file name and media type (MIME type).Caches and stores metadata in a sidecar file. Uniform metadata support across all filesystems.Uses the repository pattern for files.Remote fa√ßade pattern in accessing metadata. Improves performance with remote filesystems. Two metadata queries require only one round trip.Rich metadata support.Option to use lazy-loading proxy for files.Support for file derivations.Separated contracts and implementation. Useful for enforcing architectural boundaries. Your domain models don't have to depend on the framework.  ","version":"Next","tagName":"h3"},{"title":"Interoperability Features‚Äã","type":1,"pageTitle":"Introduction","url":"/file/intro#interoperability-features","content":" Adapters for Symfony HttpFoundation, Form, and Validator.Adapter for OneupUploaderBundle.  ","version":"Next","tagName":"h3"},{"title":"Components‚Äã","type":1,"pageTitle":"Introduction","url":"/file/intro#components","content":" The File framework consists of several components.    rekalogika/file: The core library. It provides the file abstraction and metadata support.rekalogika/file-bundle: Integrates the library with Symfony.rekalogika/file-association: Provides support for associating files withrekalogika/file-association-entity: Utilities for handling files inside domain entities.rekalogika/file-contracts: Contains the interfaces and contracts used by the library.rekalogika/file-derivation: Library for creating derived files.rekalogika/file-filepond: Form for uploading files utilizing the FilePond Javascript library.rekalogika/file-image: Provides image resizing filter.rekalogika/file-metadata: Classes that represent file metadata.rekalogika/file-metadata-contracts: Contains additional interfacesrekalogika/file-null: Implementation of the null object pattern.rekalogika/file-oneup-uploader-bridge: Adapter for OneupUploaderBundle.rekalogika/file-server: Temporary URL server for files.rekalogika/file-symfony-bridge: Adapter for Symfony HttpFoundation, Form, andrekalogika/file-zip: Streams files as a ZIP file to the client.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction","url":"/file/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/file/intro#contributing","content":" This framework consists of multiple repositories split from a monorepo. Be sure to submit issues and pull requests to therekalogika/file-src monorepo. ","version":"Next","tagName":"h2"},{"title":"Lazy-Loading Proxy","type":0,"sectionRef":"#","url":"/file/proxy","content":"","keywords":"","version":"Next"},{"title":"Getting a Proxy to a File‚Äã","type":1,"pageTitle":"Lazy-Loading Proxy","url":"/file/proxy#getting-a-proxy-to-a-file","content":" To get a lazy-loading proxy to a real file, you can use the method getReference() of FileRepositoryInterface:  use Rekalogika\\Contracts\\File\\FileRepositoryInterface; use Rekalogika\\File\\FilePointer; /** @var FileRepositoryInterface $fileRepository */ $pointer = new FilePointer('default', 'key'); $file = $fileRepository-&gt;getReference($pointer);   The $file variable will contain a FileInterface object that is actually a proxy to the real thing. It behaves the same way as a real FileInterfaceobject, except that it will throw FileNotFoundException if the file is not found when you are trying to use it.  info If the file is already in the cache of the FileRepositoryInterface, then the real file will be returned instead of a proxy.  ","version":"Next","tagName":"h2"},{"title":"Getting The Real File from a Proxy‚Äã","type":1,"pageTitle":"Lazy-Loading Proxy","url":"/file/proxy#getting-the-real-file-from-a-proxy","content":" To get the real file from a proxy, you can call the static methodFileProxy::getFile():  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\FileProxy; /** @var FileInterface $file */ // $realFile will be a FileInterface object or null if it does not exist $realFile = FileProxy::getFile($file);   Protip You can pass any FileInterface to FileProxy::getFile(). If the file is not a proxy, it will be returned as is. ","version":"Next","tagName":"h2"},{"title":"Metadata","type":0,"sectionRef":"#","url":"/file/metadata","content":"","keywords":"","version":"Next"},{"title":"Primary Metadata‚Äã","type":1,"pageTitle":"Metadata","url":"/file/metadata#primary-metadata","content":" Firstly, FileInterface has several methods that return and set what can be considered metadata of the file:  use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // Returns the file's name $name = (string) $file-&gt;getName(); // Returns the file's MIME type $mime = (string) $file-&gt;getType(); // Returns the file's size in bytes $size = $file-&gt;getSize(); // Returns the file's last modified time $lastModified = $file-&gt;getLastModified();   ","version":"Next","tagName":"h2"},{"title":"Metadata Objects‚Äã","type":1,"pageTitle":"Metadata","url":"/file/metadata#metadata-objects","content":" A FileInterface can also have several metadata objects associated with it. A metadata object is an object that represents a specific type of metadata of the file.  These are the metadata objects that are currently implemented:  RawMetadataInterface: Represents the raw metadata object. It is a simple key-value object. The value can be a string, integer, boolean, or null.FileMetadataInterface: Represents the metadata that every file has: name, type, size, and last modified time.HttpMetadataInterface: Represents metadata used in HTTP responses. It is used when streaming the file to the client over HTTP.ImageMetadataInterface: Contains metadata specific to images, including image dimension and orientation.  ","version":"Next","tagName":"h2"},{"title":"Getting Metadata Objects‚Äã","type":1,"pageTitle":"Metadata","url":"/file/metadata#getting-metadata-objects","content":" The FileInterface has a get() method that returns an associated object of the file. The caller can use this method to get a specific metadata object of a file.  use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // Returns the FileMetadataInterface object $fileMetadata = $file-&gt;get(FileMetadataInterface::class); // Returns the ImageMetadataInterface object $imageMetadata = $file-&gt;get(ImageMetadataInterface::class); // Getting image related metadata $width = $file-&gt;get(ImageMetadataInterface::class)-&gt;getWidth(); $height = $file-&gt;get(ImageMetadataInterface::class)-&gt;getHeight();   You can also use string aliases instead of FQCNs. This is useful when specifying FQCNs is inconvenient, like in Twig templates:  &lt;img src=&quot;{{ image_file|temporary_url }}&quot; width=&quot;{{ image_file.get('imageMetadata').width }}&quot; height=&quot;{{ image_file.get('imageMetadata').height }}&quot;&gt;   ","version":"Next","tagName":"h2"},{"title":"Setting Metadata‚Äã","type":1,"pageTitle":"Metadata","url":"/file/metadata#setting-metadata","content":" Metadata objects can provide methods that can be used to set the metadata value. For example, the FileMetadataInterface has setName() and setType(), theHttpMetadataInterface has setDisposition(), etc. After setting the metadata using these methods, the caller must call flush() to persist the changes.  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\Metadata\\HttpMetadataInterface; /** @var FileInterface $file */ // Each of the following will be flush automatically individually, and will // require two roundtrips to the storage backend $file-&gt;setType('image/jpeg'); $file-&gt;setName('foo.jpg'); // The following needs an explicit flush(). It will only require one roundtrip // to the storage backend. $file-&gt;get(FileMetadataInterface::class)?-&gt;setType('image/jpeg'); $file-&gt;get(FileMetadataInterface::class)?-&gt;setName('foo.jpg'); $file-&gt;flush();   note Local files don't persist metadata. Changes in the metadata are only valid for the duration of the request. However, if the file is copied or moved to a non-local filesystem, the metadata will be copied and persisted by the destination file.  ","version":"Next","tagName":"h2"},{"title":"Low-Level Metadata Handling‚Äã","type":1,"pageTitle":"Metadata","url":"/file/metadata#low-level-metadata-handling","content":" In a non-local filesystem, the library stores a file's metadata in a sidecar file in the JSON format. If the file key is foo/bar.txt, the metadata file key will befoo/bar.txt.metadata.  Rationale:  Supports all filesystems.Uniform way of handling metadata with all filesystems.Simpler administration. i.e. when copying between different filesystems.Implements coarse-grained remote fa√ßade pattern to improve performance with remote filesystems.  With the local filesystem, the library provides the same interface as above but does not save the metadata to a sidecar file. Instead, the metadata is determined from the file and stored in an in-memory cache. Any changes to the metadata are not persisted and are only valid in the current request but will be considered if the caller copies or moves the file to a non-local filesystem.  The caller is expected to treat files in the local filesystem as transient objects and expected to copy or move the files to a non-local filesystem if they wish to store the file. ","version":"Next","tagName":"h2"},{"title":"Null File","type":0,"sectionRef":"#","url":"/file/null-file","content":"","keywords":"","version":"Next"},{"title":"The Missing File Problem‚Äã","type":1,"pageTitle":"Null File","url":"/file/null-file#the-missing-file-problem","content":" One of the most common problems when working with files is how to handle the case when the business logic necessitates that a file must be present, but in actuality, it is not. For example, if an image has been assigned to a product in the past, the product has a record of it and knows that it has an image. But in the storage, the image is missing for some reason.  We can use a standard null value, but by doing so, we will have to check for null every time we want to use the file, as well as do the branching logic everywhere. This is tedious and error-prone. Such cases also rarely happen, and therefore the handling logic will also be rarely tested. When it happens, it often results in a fatal error, which is not a good user experience.  ","version":"Next","tagName":"h2"},{"title":"Solution: Use a NullFile Object‚Äã","type":1,"pageTitle":"Null File","url":"/file/null-file#solution-use-a-nullfile-object","content":" NullFile is a null object pattern implementation for files. It is a FileInterface that represents the missing file. It appears like a real file to the caller and can be considered a real file by most parts of the code.  Instead of a fatal error, your user will now be able to see if there is a file, but something is wrong with it, and will be able to tell the admin about it. The admin will be able to act on it, for example, by re-uploading the file or restoring it from backup.  The NullFile does that without much effort from the developer.  A NullFile will only stop acting like a real file if the caller is trying to operate on it that would cause a side effect. For example, you will not be able to copy a NullFile to another location, to change its content, etc. If that happens, NullFile will throw a NullFileOperationException.  ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Null File","url":"/file/null-file#usage","content":" Preparation You need to install the package rekalogika/file-null to use this feature: composer require rekalogika/file-null   An example on how to use NullFile in your entity:  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Domain\\File\\Null\\NullFile; class Product { private ?FileInterface $image = null; public function __construct(FileInterface $image) { $this-&gt;image = $image; } // The image must never be null. So, if the image does not exist, we // substitute it with a NullFile instead. public function getImage(): FileInterface { return $this-&gt;image ?? new NullFile(); } }   ","version":"Next","tagName":"h2"},{"title":"Checking for a Null File‚Äã","type":1,"pageTitle":"Null File","url":"/file/null-file#checking-for-a-null-file","content":" All null files implement the NullFileInterface. You can use this interface to check if a file is null:  use Rekalogika\\Contracts\\File\\NullFileInterface; /** @var FileInterface $file */ if ($file instanceof NullFileInterface) { // The file is null. }   ","version":"Next","tagName":"h2"},{"title":"InvalidFile: a Null File That is Also an Exception‚Äã","type":1,"pageTitle":"Null File","url":"/file/null-file#invalidfile-a-null-file-that-is-also-an-exception","content":" There is also a null file called InvalidFile which is identical to the standard NullFile, but also extends Exception. The idea is that it contains the stack trace where it was instantiated that can help you debug the problem, if you can log it somewhere. You can also throw it somewhere down the line if you need it.  To log an InvalidFile you can do something like the following.  use Rekalogika\\Contracts\\File\\FileInterface; use Psr\\Log\\LoggerInterface; /** @var FileInterface $file */ /** @var LoggerInterface $logger */ if ($file instanceof InvalidFile) { $logger-&gt;error('Invalid file', [ 'exception' =&gt; $file, ]); }  ","version":"Next","tagName":"h2"},{"title":"rekalogika/gotenberg-pdf-bundle","type":0,"sectionRef":"#","url":"/gotenberg-pdf-bundle","content":"","keywords":"","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"rekalogika/gotenberg-pdf-bundle","url":"/gotenberg-pdf-bundle#features","content":" Easy provisioning with Symfony Flex, Symfony CLI, and Docker Compose. Just install the bundle and you're ready to generate your first PDF.Separated high-level interfaces in rekalogika/print-contracts. If Gotenberg gets out of fashion in the future, hopefully we only need to replace this package, and don't need to change our code.Abstractions for paper sizes and page layouts.Leverages Symfony HTTP Client. See the requests and responses in SymfonyWith the heavy lifting already done by Gotenberg, there is no need to deal with Chrome instances, CLI tools, Puppeteer, NodeJS, etc.Scalable architecture. Suitable for low-volume development and high-volume usage alike. No need to reengineer if your usage outgrows your solution. Just add more instances of Gotenberg with Docker Compose or the container orchestration tool you are using.  ","version":"Next","tagName":"h2"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/gotenberg-pdf-bundle","url":"/gotenberg-pdf-bundle#sections","content":" üìÑÔ∏è Installation &amp; Quick Start This chapter describes how to install and use the bundle. üìÑÔ∏è Usage This chapter describes how to use the bundle.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"rekalogika/gotenberg-pdf-bundle","url":"/gotenberg-pdf-bundle#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"rekalogika/gotenberg-pdf-bundle","url":"/gotenberg-pdf-bundle#contributing","content":" The rekalogika/gotenberg-pdf-bundle repository is a read-only repo split from the main repo. Issues and pull requests should be submitted to therekalogika/print-src monorepo. ","version":"Next","tagName":"h2"},{"title":"rekalogika/mapper","type":0,"sectionRef":"#","url":"/mapper","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/mapper","url":"/mapper#sections","content":" üìÑÔ∏è Introduction rekalogika/mapper is an object mapper for PHP and Symfony, also commonly known üìÑÔ∏è Installation &amp; Basic Usage Install and use the mapper. üóÉÔ∏è Mapping Object to Object 8 items üìÑÔ∏è Mapping Arrays &amp; Array-Like Objects This chapter describes how to map arrays and array-like objects. üìÑÔ∏è Mapping DateTime This chapter describes how to do a mapping involving DateTime objects. üìÑÔ∏è Context and Mapping Options Provide context variables to the mapper to control the mapping process. Or get üìÑÔ∏è Manual Mapping using an Object Mapper If you need a custom logic in an object to another object mapping, one way to do üìÑÔ∏è Manual Mapping using a Class Factory Method This mapping method is deprecated. üìÑÔ∏è Predetermined Mapping Preset The user can provide a list of predetermined mapping between objects to Mapper. üìÑÔ∏è Mapping Table When we tell the mapper to map a source to a target, it will look up the mapping üìÑÔ∏è Creating a Custom Transformer Extend the mapper by creating your own transformer. üìÑÔ∏è SubMapper SubMapper is a highly simplified mapper used in places where you might need to üìÑÔ∏è Debugging the Mapper Command Line üìÑÔ∏è Cache Pre-warming Mapper caches the results of expensive processing, so when it does the same üóÉÔ∏è Cookbook 2 items ","version":"Next","tagName":"h2"},{"title":"Installation & Quick Start","type":0,"sectionRef":"#","url":"/gotenberg-pdf-bundle/installation","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Installation & Quick Start","url":"/gotenberg-pdf-bundle/installation#installation","content":" Preinstallation checklists:  Make sure Composer is installed globally, as explained in the installation chapter of the Composer documentation. Run composer about to verify.Make sure your project has Symfony Flex installed and enabled (it is enabled by default). Run composer why symfony/flex to verify.  Open a command console, enter your project directory, and execute:  composer config extra.symfony.allow-contrib true composer require rekalogika/gotenberg-pdf-bundle   ","version":"Next","tagName":"h2"},{"title":"Quick Start‚Äã","type":1,"pageTitle":"Installation & Quick Start","url":"/gotenberg-pdf-bundle/installation#quick-start","content":" Checklist:  Make sure you have Docker Compose installed. Run docker compose version to verify.Make sure you have Symfony CLI installed. Run symfony version to verify.  To start the Gotenberg server (and other services registered in the Docker Compose configuration), run:  docker compose up -d   Then start the web server using Symfony CLI:  symfony serve   Create a sample controller for generating a PDF file:  src/Controller/AppController.php namespace App\\Controller; use Rekalogika\\Contracts\\Print\\PageOrientation; use Rekalogika\\Contracts\\Print\\PdfGeneratorInterface; use Rekalogika\\Print\\PageLayout; use Rekalogika\\Print\\Paper; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\HttpFoundation\\StreamedResponse; use Symfony\\Component\\Routing\\Annotation\\Route; class AppController extends AbstractController { #[Route('/pdf')] public function index(PdfGeneratorInterface $pdfGenerator): Response { $pdf = $pdfGenerator-&gt;generatePdfFromHtml( htmlContent: '&lt;h1&gt;Hello World&lt;/h1&gt;', paper: Paper::A4(), pageLayout: PageLayout::inMm(PageOrientation::Portrait, 30) ); return new StreamedResponse( callback: fn () =&gt; fpassthru($pdf-&gt;detach()), status: 200, headers: [ 'Content-Type' =&gt; 'application/pdf', ] ); } }   Then open your browser and go to localhost:8000/pdf. ","version":"Next","tagName":"h2"},{"title":"Using File & FileRepository","type":0,"sectionRef":"#","url":"/file/file","content":"","keywords":"","version":"Next"},{"title":"Working With the File Repository‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#working-with-the-file-repository","content":" ","version":"Next","tagName":"h2"},{"title":"Create a file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#create-a-file","content":" caution These methods overwrite the existing file if it already exists.  use Rekalogika\\Contracts\\File\\FileRepositoryInterface; use Rekalogika\\File\\FilePointer; /** @var FileRepositoryInterface $fileRepository */ // Create a file from a string $file = $fileRepository-&gt;createFromString( new FilePointer('default', 'key'), 'Hello World!' ); // Create a file from a stream (resource or PSR-7 StreamInterface) $file = $fileRepository-&gt;createFromStream( new FilePointer('default', 'key'), $stream ); // Create a file from a local file $file = $fileRepository-&gt;createFromLocalFile( new FilePointer('default', 'key'), '/tmp/foo.txt' );   ","version":"Next","tagName":"h3"},{"title":"Get a file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#get-a-file","content":" use Rekalogika\\Contracts\\File\\FileRepositoryInterface; use Rekalogika\\Contracts\\File\\Exception\\File\\FileNotFoundException; use Rekalogika\\File\\FilePointer; /** @var FileRepositoryInterface $fileRepository */ // get() will throw an exception if the file is not found try { $file = $fileRepository-&gt;get(new FilePointer('default', 'key')); } catch (FileNotFoundException $e) { // File not found } // tryGet() will return null if the file is not found $file = $fileRepository-&gt;tryGet(new FilePointer('default', 'key')); // With a local file, you can also do it without using file repository: try { $file = new File('/path/to/file'); } catch (FileNotFoundException $e) { // File not found }   ","version":"Next","tagName":"h3"},{"title":"Delete a file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#delete-a-file","content":" use Rekalogika\\Contracts\\File\\FileRepositoryInterface; use Rekalogika\\File\\FilePointer; /** @var FileRepositoryInterface $fileRepository */ $fileRepository-&gt;delete(new FilePointer('default', 'key'));   ","version":"Next","tagName":"h3"},{"title":"Copy and move a file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#copy-and-move-a-file","content":" use Rekalogika\\Contracts\\File\\FileRepositoryInterface; use Rekalogika\\File\\FilePointer; /** @var FileRepositoryInterface $fileRepository */ $newFile = $fileRepository-&gt;copy( new FilePointer('default', 'key'), new FilePointer('otherfilesystem', 'destinationkey') ); $newFile = $fileRepository-&gt;move( new FilePointer('default', 'key'), new FilePointer('otherfilesystem', 'destinationkey') );   tip You can also use a FileInterface as the origin or the destination of the move or copy operation.  ","version":"Next","tagName":"h3"},{"title":"Create a temporary file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#create-a-temporary-file","content":" use Rekalogika\\Contracts\\File\\FileRepositoryInterface; /** @var FileRepositoryInterface $fileRepository */ $file = $fileRepository-&gt;createTemporaryFile();   note The temporary file is represented by a special TemporaryFile that will be automatically deleted if it is unset or falls out of scope.  ","version":"Next","tagName":"h3"},{"title":"Working With a File‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#working-with-a-file","content":" ","version":"Next","tagName":"h2"},{"title":"Reading the file's content‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#reading-the-files-content","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // As a string $string = $file-&gt;getContent(); // As a stream $stream = $file-&gt;getContentAsStream(); // getContentAsStream() returns a PSR-7 StreamInterface, to get a plain PHP // resource, call detach() on it $resource = $stream-&gt;detach();   ","version":"Next","tagName":"h3"},{"title":"Writing to the file, replacing its content‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#writing-to-the-file-replacing-its-content","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // From a string $file-&gt;setContent('Hello World!'); // From a stream or resource $file-&gt;setContentFromStream($resource);   ","version":"Next","tagName":"h3"},{"title":"Renaming the file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#renaming-the-file","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ $file-&gt;setName('my-photo.jpg'); // If you omit the extension, the library will automatically choose the correct // extension based on the file's MIME type $file-&gt;setName('my-photo'); $name = (string) $file-&gt;getName(); // my-photo.jpg // If you absolutely don't want an extension, you can set it directly to the // metadata $file-&gt;get(FileMetadataInterface::class)-&gt;setName('my-photo'); $file-&gt;flush(); // getName() returns FileNameInterface that provides several convenient methods // to get information about the filename $file-&gt;setName('foo.png'); $name = (string) $file-&gt;getName(); // foo.png $fullName = $file-&gt;getName()-&gt;getFull(); // foo.png $baseName = $file-&gt;getName()-&gt;getBase(); // foo $extension = $file-&gt;getName()-&gt;getExtension(); // png $hasExtension = $file-&gt;getName()-&gt;hasExtension(); // true   ","version":"Next","tagName":"h3"},{"title":"Saving to a local file‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#saving-to-a-local-file","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // Saves the file to /tmp/foo.txt $localFile = $file-&gt;saveToLocalFile('/tmp/foo.txt'); // Saves the file to a temporary file $temporaryFile = $file-&gt;createLocalTemporaryFile();   ","version":"Next","tagName":"h3"},{"title":"Media type (MIME type) handling‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#media-type-mime-type-handling","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // Setting the MIME type is usally not necessary as the framework will // automatically detect media type $file-&gt;setType('image/jpeg'); // sets the media type to image/jpeg $type = (string) $file-&gt;getType(); // image/jpeg $type = $file-&gt;getType()-&gt;getName(); // image/jpeg $type = $file-&gt;getType()-&gt;getType(); // image $type = $file-&gt;getType()-&gt;getSubType(); // jpeg $type = $file-&gt;getType()-&gt;getCommonExtensions(); // ['jpg', 'jpeg', 'jpe'] $type = $file-&gt;getType()-&gt;getExtension(); // jpg $type = (string) $file-&gt;getType()-&gt;getDescription(); // JPEG image   ","version":"Next","tagName":"h3"},{"title":"File size & last modified time‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#file-size--last-modified-time","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // Main metadata $size = $file-&gt;getSize(); // file size in bytes $lastModified = $file-&gt;getLastModified(); // last modified time   ","version":"Next","tagName":"h3"},{"title":"Image metadata‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#image-metadata","content":" use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\Metadata\\ImageMetadataInterface; /** @var FileInterface $file */ $width = $file-&gt;get(ImageMetadataInterface::class)?-&gt;getWidth(); $height = $file-&gt;get(ImageMetadataInterface::class)?-&gt;getHeight(); // You can also use string identifiers, useful when specifying FQCNs is // unwieldy, like in Twig templates $width = $file-&gt;get('imageMetadata')?-&gt;getWidth(); $height = $file-&gt;get('imageMetadata')?-&gt;getHeight();   ","version":"Next","tagName":"h3"},{"title":"HTTP metadata‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#http-metadata","content":" use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\Metadata\\HttpMetadataInterface; /** @var FileInterface $file */ // Setting the disposition value, will be used in the Content-Disposition header // when the file is downloaded $file-&gt;get(HttpMetadataInterface::class)?-&gt;setDisposition('attachment'); $file-&gt;flush(); // Getting all the HTTP headers that will be used when the file is downloaded $httpHeaders = $file-&gt;get(HttpMetadataInterface::class)?-&gt;getHeaders();   ","version":"Next","tagName":"h3"},{"title":"Flushing metadata‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#flushing-metadata","content":" Updating metadata using a high-level method (those on FileInterface) will be saved automatically. But using a low-level method (underFileInterface::get()), you have to call flush() manually. You can take advantage of this so that multiple metadata updates are saved in a single round trip.  use Rekalogika\\Contracts\\File\\FileInterface; use Rekalogika\\Contracts\\File\\Metadata\\HttpMetadataInterface; /** @var FileInterface $file */ // Each of the following will be flush automatically individually, and will // require two roundtrips to the storage backend $file-&gt;setType('image/jpeg'); $file-&gt;setName('foo.jpg'); // The following needs an explicit flush(). It will only require one roundtrip // to the storage backend. $file-&gt;get(FileMetadataInterface::class)?-&gt;setType('image/jpeg'); $file-&gt;get(FileMetadataInterface::class)?-&gt;setName('foo.jpg'); $file-&gt;flush();   ","version":"Next","tagName":"h3"},{"title":"File Pointer & comparison‚Äã","type":1,"pageTitle":"Using File & FileRepository","url":"/file/file#file-pointer--comparison","content":" use Rekalogika\\Contracts\\File\\FileInterface; /** @var FileInterface $file */ // get pointer from a FileInterface $filePointer = $file-&gt;getPointer(); // determine if two File/FilePointer objects point to the same file $isEqual = $filePointer-&gt;isEqualTo($file); $isEqual = $file-&gt;isEqualTo($filePointer); $isEqual = $file1-&gt;isEqualTo($file2); $isEqual = $filePointer1-&gt;isEqualTo($filePointer2);  ","version":"Next","tagName":"h3"},{"title":"Usage","type":0,"sectionRef":"#","url":"/gotenberg-pdf-bundle/usage","content":"","keywords":"","version":"Next"},{"title":"Specifying the URL to the Gotenberg Server‚Äã","type":1,"pageTitle":"Usage","url":"/gotenberg-pdf-bundle/usage#specifying-the-url-to-the-gotenberg-server","content":" The bundle uses the GOTENBERG_URL environment variable to determine the URL to the Gotenberg server. You can override it using the standard Symfony environment variable mechanism.  ","version":"Next","tagName":"h2"},{"title":"General Usage‚Äã","type":1,"pageTitle":"Usage","url":"/gotenberg-pdf-bundle/usage#general-usage","content":" Callers will interact with the PdfGeneratorInterface to generate PDF files. The PdfGeneratorInterface is a high-level interface that abstracts away the implementation details of the underlying PDF generator.  namespace Rekalogika\\Contracts\\Print; use Psr\\Http\\Message\\StreamInterface; interface PdfGeneratorInterface { public function generatePdfFromHtml( string $htmlContent, PaperInterface $paper, PageLayoutInterface $pageLayout, ?string $header = null, ?string $footer = null, ): StreamInterface; }   To get an instance of PdfGeneratorInterface, you can usually autowire it in your controller or service:  namespace App\\Controller; use Rekalogika\\Contracts\\Print\\PdfGeneratorInterface; class AppController { public function index(PdfGeneratorInterface $pdfGenerator) { // ... } }   generatePdfFromHtml() returns a PSR-7 StreamInterface containing the resulting PDF file. To get the raw PHP resource, call detach() on the result.  ","version":"Next","tagName":"h2"},{"title":"Paper Size‚Äã","type":1,"pageTitle":"Usage","url":"/gotenberg-pdf-bundle/usage#paper-size","content":" The method generatePdfFromHtml requires a $paper parameter containing aPaperInterface instance. It defines the paper size of the PDF output. You can use the Paper class to create a paper size:  use Rekalogika\\Print\\Paper; $a4Paper = Paper::A4(); // A4 $letterPaper = Paper::Letter(); // Letter $customPaper = Paper::inMm(200, 300); // Custom paper size in mm $customPaperInInches = Paper::inInches(7, 10); // Custom paper size in inches   There are many other paper sizes defined in the class.  ","version":"Next","tagName":"h2"},{"title":"Page Layout‚Äã","type":1,"pageTitle":"Usage","url":"/gotenberg-pdf-bundle/usage#page-layout","content":" The method generatePdfFromHtml requires a $pageLayout parameter containing a PageLayoutInterface instance. It defines the orientation of the page and its margins. You can use the PageLayout class to create a page layout:  use Rekalogika\\Print\\PageLayout; use Rekalogika\\Contracts\\Print\\PageOrientation; // Portrait with 30mm margins $layout = PageLayout::inMm(PageOrientation::Portrait, 30); // Landscape with 2 inches of vertical margin and 1 inch of horizontal margin $layout = PageLayout::inInches(PageOrientation::Landscape, 2, 1); // Portrait with 10mm top margin, 20mm right margin, 30mm bottom margin, and // 40mm left margin $layout = PageLayout::inMm(PageOrientation::Portrait, 10, 20, 30, 40);   ","version":"Next","tagName":"h2"},{"title":"Header and Footer‚Äã","type":1,"pageTitle":"Usage","url":"/gotenberg-pdf-bundle/usage#header-and-footer","content":" The $header and $footer parameters of generatePdfFromHtml are optional. You can use them to specify the HTML content of the header and footer of the PDF file. Read the Header and Footer chapter of the Gotenberg documentation to learn more. ","version":"Next","tagName":"h2"},{"title":"Cache Pre-warming","type":0,"sectionRef":"#","url":"/mapper/cache-prewarming","content":"","keywords":"","version":"Next"},{"title":"Pre-warming is Optional‚Äã","type":1,"pageTitle":"Cache Pre-warming","url":"/mapper/cache-prewarming#pre-warming-is-optional","content":" First off, Mapper can work without pre-warming the cache. It will just take a bit longer to process the first mapping. In most deployments, it should not be necessary to pre-warm the cache.  ","version":"Next","tagName":"h2"},{"title":"When Pre-warming is Useful‚Äã","type":1,"pageTitle":"Cache Pre-warming","url":"/mapper/cache-prewarming#when-pre-warming-is-useful","content":" Very busy applications: Without pre-warming, a new deployment starts with an empty cache. With a busy application, it can result in a load spike, where many requests come in at the same time, and each request tries to perform the same expensive operation. By shipping the pre-warmed cache as part of the deployment image, you can avoid this problem.  Strict read-only deployments: Such systems might have no choice but to store the cache over the network, and pre-warming can help to reduce the overhead.  ","version":"Next","tagName":"h2"},{"title":"How to Pre-warm the Cache‚Äã","type":1,"pageTitle":"Cache Pre-warming","url":"/mapper/cache-prewarming#how-to-pre-warm-the-cache","content":" Mapper cannot possibly know beforehand which mapping you are going to do in the application. So, you need to inform Mapper the list of the mappings. To do so, you can create a mapping collection file and store it in theconfig/rekalogika-mapper directory, any filename is fine.  config/rekalogika-mapper/mappings.php &lt;?php use Rekalogika\\Mapper\\CacheWarmer\\MappingCollection; return function (MappingCollection $mappingCollection) : void { $mappingCollection-&gt;addObjectMapping( source: SomeSourceClass::class, target: SomeTargetClass::class ); $mappingCollection-&gt;addObjectMapping( source: OtherSourceClass::class, target: OtherTargetClass::class ); }   Then, the mapping cache will be pre-warmed as part of Symfony's cache pre-warming process:  $ APP_ENV=prod APP_DEBUG=0 php bin/console cache:clear   ","version":"Next","tagName":"h2"},{"title":"Using PHPStan to Automatically Generate the Mapping Collection‚Äã","type":1,"pageTitle":"Cache Pre-warming","url":"/mapper/cache-prewarming#using-phpstan-to-automatically-generate-the-mapping-collection","content":" If you are using PHPStan, you can add the configuration below to your PHPStan configuration file, then PHPStan will automatically generate the mapping collection in the specified file every time you run PHPStan.  phpstan.neon.dist parameters: rekalogika-mapper: mapperDumpFile: config/rekalogika-mapper/generated-mappings.php # only required if you are not using phpstan/extension-installer: includes: - vendor/rekalogika/mapper/phpstan-extension.neon   note The automatic PHPStan mapping generation is not foolproof. It cannot detect every possible use cases. You might still need to add some of the mappings manually. ","version":"Next","tagName":"h2"},{"title":"Cookbook","type":0,"sectionRef":"#","url":"/mapper/cookbook","content":"Cookbook üìÑÔ∏è Mapping a DTO to a Persisted Doctrine Entity This is an example of mapping a DTO to an entity already persisted in the üìÑÔ∏è Overriding a Mapping Table Entry If the mapper chooses the wrong transformer for a specific source and target","keywords":"","version":"Next"},{"title":"Manual Mapping using a Class Factory Method","type":0,"sectionRef":"#","url":"/mapper/class-factory-mapper","content":"","keywords":"","version":"Next"},{"title":"Mapping from another Object‚Äã","type":1,"pageTitle":"Manual Mapping using a Class Factory Method","url":"/mapper/class-factory-mapper#mapping-from-another-object","content":" You can have your DTO implement the MapFromObjectInterface and create themapFromObject() method:  src/Dto/MoneyDto.php namespace App\\Dto; use Brick\\Money\\Money; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MethodMapper\\MapFromObjectInterface; use Rekalogika\\Mapper\\MethodMapper\\SubMapperInterface; final class MoneyDto implements MapFromObjectInterface { // ... public static function mapFromObject( object $source, SubMapperInterface $mapper, Context $context ): static { if (!$source instanceof Money) { throw new \\InvalidArgumentException('Source must be instance of ' . Money::class); } return new static( $source-&gt;getAmount()-&gt;__toString(), $source-&gt;getCurrency()-&gt;getCurrencyCode(), ); } }   Then, the next time you are mapping from the Money object to the MoneyDtoobject, the mapper will call the mapFromObject() method to get the resultingMoneyDto. The mapping will be done even if your Money object is deeply buried within the object you are mapping from.  ","version":"Next","tagName":"h2"},{"title":"Mapping to Another Object‚Äã","type":1,"pageTitle":"Manual Mapping using a Class Factory Method","url":"/mapper/class-factory-mapper#mapping-to-another-object","content":" You can also get the reverse of the above by implement theMapToObjectInterface and create the mapToObject() method.  src/Dto/MoneyDto.php namespace App\\Dto; use Brick\\Money\\Money; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MethodMapper\\MapToObjectInterface; use Rekalogika\\Mapper\\MethodMapper\\SubMapperInterface; final class MoneyDto implements MapToObjectInterface { // ... public function mapToObject( object|string $target, SubMapperInterface $mapper, Context $context ): object { return Money::of($this-&gt;amount, $this-&gt;currency); } }   ","version":"Next","tagName":"h2"},{"title":"SubMapper‚Äã","type":1,"pageTitle":"Manual Mapping using a Class Factory Method","url":"/mapper/class-factory-mapper#submapper","content":" The $mapper parameter in the mapFromObject() and mapToObject() methods provides you with the SubMapper. Read more about the sub mapper in theSubMapper chapter. ","version":"Next","tagName":"h2"},{"title":"Context and Mapping Options","type":0,"sectionRef":"#","url":"/mapper/context","content":"","keywords":"","version":"Next"},{"title":"Context‚Äã","type":1,"pageTitle":"Context and Mapping Options","url":"/mapper/context#context","content":" The Context object stores objects that are used during the mapping process. The caller can provide a Context in the map() method. If not provided, the mapper will create a new Context object internally.  Context stores objects using class names as keys. Therefore, only one object of a given class can be stored in a Context.  use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MapperInterface; // Create a context $context = Context::create(); // Create a context, initialized with mapper options &amp; a custom object $mapperOptions = new MapperOptions(lazyLoading: false); $yourCustomObject = new YourCustomObject(); $context = Context::create($mapperOptions, $yourCustomObject); // Call map() with the context /** @var MapperInterface $mapper */ $target = $mapper-&gt;map($source, TargetObject::class, $context); // Add an object to the context, note that context is immutable $context = $context-&gt;with($someObject); // Remove an object from the context $context = $context-&gt;without(SomeObject::class); // Get an object from the context $mapperOptions = $context-&gt;get(MapperOptions::class); // or $mapperOptions = $context(MapperOptions::class); // Iterates over all objects in the context foreach ($context as $object) { // ... }   The Context is available in most of the places where you write code to customize the mapping process.  ","version":"Next","tagName":"h2"},{"title":"Built-in Context Objects‚Äã","type":1,"pageTitle":"Context and Mapping Options","url":"/mapper/context#built-in-context-objects","content":" The following context objects are provided by Mapper:  MapperOptions: Options for the mapping process.ObjectCache: Used to store objects that have already been mapped. It is used to handle circular references and to prevent infinite loops.Path: Stores the mapping path. Used for tracing and creating meaningful error messages.NormalizerContext and DenormalizerContext: Used to store the context that will be used by Symfony Serializer.SourcePropertyAttributes: The attributes of the source property.TargetPropertyAttributes: The attributes of the target property.SourceClassAttributes: The attributes of the source class.TargetClassAttributes: The attributes of the target class.  ","version":"Next","tagName":"h2"},{"title":"Mapper Options‚Äã","type":1,"pageTitle":"Context and Mapping Options","url":"/mapper/context#mapper-options","content":" The MapperOptions object is passed by the caller to provide options for the mapping process. The following options are available:  lazyLoading: Enable lazy-loading.readTargetValue: If true, the mapper will get the existing value from the target. If exists, it will be used as the target. If false, the mapper will always create a new target object. ","version":"Next","tagName":"h2"},{"title":"Mapping a DTO to a Persisted Doctrine Entity","type":0,"sectionRef":"#","url":"/mapper/cookbook/doctrine-entity","content":"Mapping a DTO to a Persisted Doctrine Entity This is an example of mapping a DTO to an entity already persisted in the database. The DTO and the entity: class BookDto { public function __construct(public int $id) { } } class Book { private int $id; private string $title; public function getId(): int { return $this-&gt;id; } public function getTitle(): string { return $this-&gt;title; } public function setTitle(string $title): void { $this-&gt;title = $title; } } The mapper: use Rekalogika\\Mapper\\Attribute\\AsObjectMapper; class BookDtoToBookMapper { public function __construct( private BookRepository $bookRepository ) { } #[AsObjectMapper] public function map(BookDto $dto): Book { $book = $this-&gt;bookRepository-&gt;find($dto-&gt;id); if ($book === null) { throw new NotFoundException(); } return $book; } } The caller: use Rekalogika\\Mapper\\MapperInterface; /** @var MapperInterface $mapper */ $bookDto = new BookDto(1); $book = $mapper-&gt;map($bookDto, Book::class); ","keywords":"","version":"Next"},{"title":"Mapping Arrays & Array-Like Objects","type":0,"sectionRef":"#","url":"/mapper/collection","content":"","keywords":"","version":"Next"},{"title":"Mapping to an Array‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#mapping-to-an-array","content":" Suppose you have these entities:  use Doctrine\\Common\\Collections\\ArrayCollection; use Doctrine\\Common\\Collections\\Collection; class Post { /** @var Collection&lt;int,Comment&gt; */ private Collection $comments; public function __construct() { $this-&gt;comments = new ArrayCollection(); } /** * @return Collection&lt;int,Comment&gt; */ public function getComments(): Collection { return $this-&gt;comments; } } class Comment { private string $text; public function __construct(string $text) { $this-&gt;text = $text; } public function getText(): string { return $this-&gt;text; } }   To map those entities to the corresponding DTOs, you can simply create the DTOs like the following. Notice the type-hint of the $comments property:  class PostDto { /** @var ?array&lt;int,CommentDto&gt; */ public ?array $comments = null; } class CommentDto { public string $text; }   Then, you can map between the two objects:  /** @var MapperInterface $mapper */ $postDto = $mapper-&gt;map($post, PostDto::class);   info Without the type-hint, the mapper will copy the source objects to the target array as-is.  The source side must be an iterable: an array or a Traversable object, i.e. anything that you can foreach() over.  ","version":"Next","tagName":"h2"},{"title":"Mapping to an Array-Like Object‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#mapping-to-an-array-like-object","content":" You can also map to an array-like object. Example:  class PostDto { /** @var ?\\ArrayObject&lt;int,CommentDto&gt; */ public ?\\ArrayObject $comments = null; }   Supported types of the target side:  ArrayAccessArrayObjectArrayIteratorDoctrine ReadableCollectionDoctrine CollectionDoctrine ArrayCollectionCollectionInterface  ","version":"Next","tagName":"h2"},{"title":"Mapping Using Adder and Remover Methods‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#mapping-using-adder-and-remover-methods","content":" Mapper supports mapping using adder and remover method on the target side. Example:  class PostDto { /** @var array&lt;int,CommentDto&gt; */ private array $comments = []; /** * @return array&lt;int,CommentDto&gt; */ public function getComments(): array { return $this-&gt;comments; } public function addComment(CommentDto $comment): void { $this-&gt;comments[] = $comment; } public function removeComment(CommentDto $comment): void { $key = array_search($comment, $this-&gt;comments, true); if ($key !== false) { unset($this-&gt;comments[$key]); } } }   ","version":"Next","tagName":"h2"},{"title":"Generator-Backed Mapping‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#generator-backed-mapping","content":" If the target is type-hinted with Traversable, the mapper will map to aGenerator object.  class PostDto { /** @var ?\\Traversable&lt;int,CommentDto&gt; */ public ?\\Traversable $comments = null; }   With this approach, no values are stored on the target side. Instead, the target will transform the source values to the desired type on-the-fly as you iterate over it.  If the source is an array or an object that implements Countable, the result will also be a Countable, i.e. that you can count() or -&gt;count(). In addition, if your source is an extra-lazy Doctrine Collection, the consumer will be able to count() the target without causing a full hydration of the source.  note For this to work, the target must be null or unset.  ","version":"Next","tagName":"h2"},{"title":"Non-Integer and Non-String Keys‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#non-integer-and-non-string-keys","content":" The mapper supports non-integer and non-string keys if the underlying objects support it, including SplObjectStorage. The key value will be transformed to the target key type-hint, just like the values. Example:  class RelationshipMap { /** @var \\ArrayAccess&lt;Person,Person&gt; */ public \\ArrayAccess $spouseMap; public function __construct() { $this-&gt;spouseMap = new \\SplObjectStorage(); } } class RelationshipMapDto { /** @var ?\\ArrayAccess&lt;PersonDto,PersonDto&gt; */ public ?\\ArrayAccess $spouseMap = null; } $jack = new Person('Jack'); $jill = new Person('Jill'); $map = new RelationshipMap(); $map-&gt;spouseMap[$jack] = $jill; $map-&gt;spouseMap[$jill] = $jack; $mapDto = $mapper-&gt;map($map, RelationshipMapDto::class);   warning For this to work, the type-hint of the target side cannot be SplObjectStorageor other concrete class. Use ArrayAccess instead. Also it must be initially null, not pre-initialized. The mapper uses a custom HashTable object on the target side to accomplish this. Using Traversable type hint also works.  ","version":"Next","tagName":"h2"},{"title":"Lazy Loading‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#lazy-loading","content":" The mapper supports lazy-loading, and will instantiate a lazy-loading object on the target size if the conditions are met.  The target must be type-hinted using Traversable, ArrayAccess, the specialCollectionInterface, or Doctrine's Collection or ReadableCollection.If the target is ArrayAccess or CollectionInterface, the source must be an array, or an array-like object that implements ArrayAccess, Traversable, and Countable (pretty much all of them do).The target side cannot be a simple array.The target variable must not be pre-initialized. It must be null or uninitialized.The target property must not be using an adder method.Non-integer, non-string keys are not supported.  If lazy loading is active on the target side, and the source supports lazy loading (like Doctrine PersistentCollection), the source will not be hydrated unless the consumer actually uses the mapped property on the target side. This might be useful, like if you are using the DTOs in a view, where you don't always need to use the property.  ","version":"Next","tagName":"h2"},{"title":"Deleting Items on the Target Side Not Present in Source‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#deleting-items-on-the-target-side-not-present-in-source","content":" By default, the mapper will not remove items already existing on the target side.  To change this behavior, you can add the AllowDelete attribute to the target property, or the AllowTargetDelete attribute to the source property. Mapper will remove existing items from the target side that are not present in the source.  The following example maps a Post entity to a PostDto DTO.  use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\Mapper\\MapperInterface; use Rekalogika\\Mapper\\Attributes\\AllowDelete; use Rekalogika\\Mapper\\Attributes\\AllowTargetDelete; class Post { /** @var Collection&lt;int,Comment&gt; */ #[AllowTargetDelete] private Collection $comments; } class PostDto { /** @var ?array&lt;int,CommentDto&gt; */ #[AllowDelete] public ?array $comments = null; } /** @var MapperInterface $mapper */ /** @var Post $post */ $dto = $mapper-&gt;map($post, PostDto::class);   Protip If your property is virtual (i.e. a getter method without an actual property), you may attach the AllowDelete attribute to to the getter or remover method, and the AllowTargetDelete attribute to the getter method.  note The identity check is done on the items, after transformation. If you are mapping a DTO to a persisted Doctrine entity, you need to use an object mapper to map the DTO to the persisted Doctrine entity. For an example on how to accomplish this, see Mapping a DTO to a Persisted Doctrine Entity.  ","version":"Next","tagName":"h2"},{"title":"Mapping Between Object and Array‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#mapping-between-object-and-array","content":" Mapping between an object and an array follows the same semantics as mapping involving an stdClassobject.  Internally, Mapper will convert the array to stdClass, and convert the result back to an array if necessary.  ","version":"Next","tagName":"h2"},{"title":"Attributes Handling‚Äã","type":1,"pageTitle":"Mapping Arrays & Array-Like Objects","url":"/mapper/collection#attributes-handling","content":" Some attributes are used to control the mapping between two objects. These attributes can be attached to array or array-like objects, and will affect the transformation between the members of the array or array-like object.  use Rekalogika\\Mapper\\Attributes\\DateTimeOptions; class SomeObject { /** * Array of dates in DateTimeInterface * * @var array&lt;int,\\DateTimeInterface&gt; */ public array $dates; } class SomeObjectDto { /** * Array of dates in string, in Y-m-d format * * @var array&lt;int,string&gt; */ #[DateTimeOptions(format: 'Y-m-d')] public array $dates = []; }   With the above example, the mapper will transform the array ofDateTimeInterface to an array of string in Y-m-d format. ","version":"Next","tagName":"h2"},{"title":"Overriding a Mapping Table Entry","type":0,"sectionRef":"#","url":"/mapper/cookbook/overriding-transformer","content":"Overriding a Mapping Table Entry If the mapper chooses the wrong transformer for a specific source and target type pair, you can override it by decorating the correct transformer and adding it to the mapping table. note Note that in this case, we don't decorate the transformer to replace the original transformer in the dependency injection container. Instead, we are &quot;duplicating&quot; an existing transformer, override its type mapping information, and putting it earlier in the mapping table. Suppose you have a YourObject class and a YourObjectDto class, but the mapper does not use the desired transformer for the job. You can fix it by decorating the correct transformer like this: use Rekalogika\\Mapper\\Transformer\\AbstractTransformerDecorator; use Rekalogika\\Mapper\\Transformer\\ObjectToObjectTransformer; use Rekalogika\\Mapper\\Transformer\\Contracts\\TypeMapping; use Rekalogika\\Mapper\\Util\\TypeFactory; class OverrideTransformer extends AbstractTransformerDecorator { public function __construct(ObjectToObjectTransformer $transformer) { parent::__construct($transformer); } public function getSupportedTransformation(): iterable { yield new TypeMapping( TypeFactory::objectOfClass(YourObject::class), TypeFactory::objectOfClass(YourObjectDto::class), ); } } With the above example, when the source is YourObject and the target isYourObjectDto, the mapper will now choose ObjectToObjectTransformer instead of choosing from the rest of the mapping table.","keywords":"","version":"Next"},{"title":"Debugging the Mapper","type":0,"sectionRef":"#","url":"/mapper/debugging","content":"","keywords":"","version":"Next"},{"title":"Command Line‚Äã","type":1,"pageTitle":"Debugging the Mapper","url":"/mapper/debugging#command-line","content":" ","version":"Next","tagName":"h2"},{"title":"Get the List of Transformers‚Äã","type":1,"pageTitle":"Debugging the Mapper","url":"/mapper/debugging#get-the-list-of-transformers","content":" php bin/console debug:container --tag=rekalogika.mapper.transformer   ","version":"Next","tagName":"h3"},{"title":"Dump the Mapping Table‚Äã","type":1,"pageTitle":"Debugging the Mapper","url":"/mapper/debugging#dump-the-mapping-table","content":" php bin/console rekalogika:mapper:mapping   ","version":"Next","tagName":"h3"},{"title":"Get the Mapping Result Between a Source and Target Type‚Äã","type":1,"pageTitle":"Debugging the Mapper","url":"/mapper/debugging#get-the-mapping-result-between-a-source-and-target-type","content":" php bin/console rekalogika:mapper:try 'App\\Entity\\Book' 'App\\Entity\\BookDto'   ","version":"Next","tagName":"h3"},{"title":"Symfony Profiler‚Äã","type":1,"pageTitle":"Debugging the Mapper","url":"/mapper/debugging#symfony-profiler","content":" In debug mode, Mapper will collect mapping data and display it in the Symfony Profiler. You can find comprehensive mapping information in the Mapper tab in the Symfony Profiler. ","version":"Next","tagName":"h2"},{"title":"Mapping DateTime","type":0,"sectionRef":"#","url":"/mapper/datetime","content":"","keywords":"","version":"Next"},{"title":"Supported Transformations‚Äã","type":1,"pageTitle":"Mapping DateTime","url":"/mapper/datetime#supported-transformations","content":" Supported target type-hints are DateTimeInterface, DateTimeImmutable,DateTime and Symfony DatePoint. Mapper supports transformation among these objects, and also to &amp; from string, integer, and float.  To perform the transformation, Mapper will convert the source value to an intermediate Symfony DatePoint object. Then it will transform the intermediate object into the target type.  ","version":"Next","tagName":"h2"},{"title":"Changing the Time Zone‚Äã","type":1,"pageTitle":"Mapping DateTime","url":"/mapper/datetime#changing-the-time-zone","content":" By default, Mapper will leave the time zone alone. If the data does not have the time zone (e.g. when the string representation does not have the time zone), it uses the system time zone.  To change the time zone, use the #[DateTimeOptions] attribute on the property:  use Rekalogika\\Mapper\\Attribute\\DateTimeOptions; class SomeObject { #[DateTimeOptions(timeZone: 'Asia/Jakarta')] public \\DateTimeInterface $someDate; }   If it is on the source side, Mapper will convert the source value to the specified time zone. Or, if the source does not have time zone information, Mapper will assume the source is already in the specified time zone.  If it is on the target side, Mapper will convert the incoming date time object to the specified time zone.  ","version":"Next","tagName":"h2"},{"title":"Changing the Format‚Äã","type":1,"pageTitle":"Mapping DateTime","url":"/mapper/datetime#changing-the-format","content":" If the mapping involves string, float, or integer, you can specify the format using the #[DateTimeOptions] attribute:  use Rekalogika\\Mapper\\Attribute\\DateTimeOptions; class SomeObject { #[DateTimeOptions(format: 'Y-m-d H:i:s', timeZone: 'Asia/Pontianak')] public string $someDate; }   It will work as anyone would expect. At the source side, Mapper will assume the string is in the specified format. At the target side, Mapper will transform to the target using the specified format.  note Without DateTimeOptions, a source date time will be passed as is to theDatePoint constructor, and will be automatically detected. At the target side, the string will be formatted as DateTimeInterface::ATOM by default. Date time in integer or float is assumed to be in Unix time.  ","version":"Next","tagName":"h2"},{"title":"Some Examples‚Äã","type":1,"pageTitle":"Mapping DateTime","url":"/mapper/datetime#some-examples","content":" use Rekalogika\\Mapper\\Attribute\\DateTimeOptions; class SomeObject { #[DateTimeOptions(format: 'Ymd', timeZone: 'Asia/Jayapura')] public int $YYYYMMDDinInteger; #[DateTimeOptions(format: 'd-m-y')] public string $DDMMYYinString; }  ","version":"Next","tagName":"h2"},{"title":"Installation & Basic Usage","type":0,"sectionRef":"#","url":"/mapper/installation-usage","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Installation & Basic Usage","url":"/mapper/installation-usage#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony FlexNon-Symfony Projects Open a command console, enter your project directory, and execute: composer require rekalogika/mapper   ","version":"Next","tagName":"h2"},{"title":"Getting the Mapper Service‚Äã","type":1,"pageTitle":"Installation & Basic Usage","url":"/mapper/installation-usage#getting-the-mapper-service","content":" In Symfony projects, you can simply autowire MapperInterface to your services and controllers just as you would do with any other service.  In non-Symfony projects, you can use the MapperFactory to get the mapper service:  use Rekalogika\\Mapper\\MapperFactory; $mapperFactory = new MapperFactory(); $mapper = $mapperFactory-&gt;getMapper();   ","version":"Next","tagName":"h2"},{"title":"Mapping a Single Object‚Äã","type":1,"pageTitle":"Installation & Basic Usage","url":"/mapper/installation-usage#mapping-a-single-object","content":" Suppose you have a Book entity:  src/Entity/Book.php namespace App\\Entity; class Book { public function __construct( private int $id, private string $title, private string $author, ) { } public function getId(): ?int { return $this-&gt;id; } public function getTitle(): ?string { return $this-&gt;title; } public function getAuthor(): ?string { return $this-&gt;author; } }   And need to map it to the BookDto data transfer object:  src/Dto/BookDto.php namespace App\\Dto; class BookDto { public string $id; public string $title; public string $author; }   You can simply do:  use App\\Entity\\Book; use Rekalogika\\Mapper\\MapperInterface; /** @var MapperInterface $mapper */ /** @var Book $book */ $result = $mapper-&gt;map($book, BookDto::class); /** @var BookDto $result */ // or map to an existing object $bookDto = new BookDto(); $mapper-&gt;map($book, $bookDto);   ","version":"Next","tagName":"h2"},{"title":"Mapping Multiple Objects‚Äã","type":1,"pageTitle":"Installation & Basic Usage","url":"/mapper/installation-usage#mapping-multiple-objects","content":" You can also map an iterable of objects of the same type by using IterableMapperInterface.  In Symfony projects, you can simply autowire the service IterableMapperInterface.  In non-Symfony projects, you can use the MapperFactory to get the iterable mapper service:  use Rekalogika\\Mapper\\MapperFactory; $mapperFactory = new MapperFactory(); $iterableMapper = $mapperFactory-&gt;getIterableMapper();   Then, you can use the mapIterable() method to map an iterable of Bookentities to an iterable of BookDto objects:  use App\\Entity\\Book; use Rekalogika\\Mapper\\IterableMapperInterface; /** @var IterableMapperInterface $iterableMapper */ /** @var iterable&lt;Book&gt; $books */ $result = $iterableMapper-&gt;mapIterable($books, BookDto::class); /** @var iterable&lt;BookDto&gt; $result */  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/mapper/intro","content":"","keywords":"","version":"Next"},{"title":"Synopsis‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#synopsis","content":" use App\\Entity\\Book; use Rekalogika\\Mapper\\MapperInterface; /** @var MapperInterface $mapper */ /** @var Book $book */ $result = $mapper-&gt;map($book, BookDto::class); // or map to an existing object $bookDto = new BookDto(); $mapper-&gt;map($book, $bookDto);   ","version":"Next","tagName":"h2"},{"title":"Why Use a Mapper?‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#why-use-a-mapper","content":" Why do we need to use a mapper to save a few keystrokes, and not just use something simple like this?  class BookDto { public static function create(Book $book): self { $dto = new self(); // ... return $dto; } }   Everyone must have that idea at some point. However, as the project grows, the target classes (DTOs) may start to reference each other, and become a rich object graph. Your code will start to have many special cases, and is no longer as simple as you thought it would be. It becomes harder to maintain, and then eventually forces you to sit back and try to resolve the problem. When (if?) you successfully engineer a solution, you will end up with something that resembles a mapping framework anyway.  Mapping can be simple, but can also become a highly complex task. A mapper is created out of necessity to handle the complexity, not just as a means of saving a few keystrokes.  ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#features","content":" ","version":"Next","tagName":"h2"},{"title":"General‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#general","content":" Automatically lists the properties of the source and target, detects their types, and maps them accordingly.Reads the type from PHP type declaration and PHPDoc annotations, including the type of the nested objects.Does not attempt to circumvent your class constraints. Reads only from and writes only to public properties, getters, setters. Does not instantiate objects without their constructor.Constructor initialization.Supports immutable setters, also known as wither methods.Handles nested objects.Handles recursion and circular references.Inheritance support. Maps to abstract classes and interfaces using an inheritance map attribute.Maps to and from stdClass, objects extending stdClass, and other objects with dynamic properties (#[AllowDynamicProperties]).Specify the source or target using property path.Maps an object to an array, and vice versa.Support for variadic setters and constructors.Support for third-party objects: Doctrine Collections, Symfony Uid, Ramsey UUID.DateTime timezone and format conversion.Cache pre-warming for busy workloads and read-only deployments.  ","version":"Next","tagName":"h3"},{"title":"Custom Mapping‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#custom-mapping","content":" Override the mapping of a specific property using a custom property mapper.Override the mapping between two specific classes using a custom object mapper.Extend the mapper by creating new transformers, or decorating the existing ones.Match classes using attributes in your transformers, in addition to using class names.Preset mapping. Provide a table of predetermined mappings that the mapper can use.  ","version":"Next","tagName":"h3"},{"title":"Object Lazy-Loading‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#object-lazy-loading","content":" If possible, target objects are lazy-loaded. The mapping does not take place until the target is accessed, and will never take place if it is never accessed.Attempts to detect identifier properties on the source side. Those properties will be mapped eagerly to the target side, as they should not trigger the hydration of the source. As an example, API Platform will be able to generate IRIs without causing Doctrine to hydrate the entire object graph.Uses native PHP &gt; 8.4 lazy objects if available, and falls back tosymfony/var-exporter if not available.  ","version":"Next","tagName":"h3"},{"title":"Arrays and Array-Like Objects‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#arrays-and-array-like-objects","content":" Handles the mapping between array or array-like objects.Handles adder and remover methods on the target side.Supports immutable adders and removers, where the methods return a new instance of the host object.Handles non-string &amp; non-integer keys in array-like objects, includingSplObjectStorage.Option to remove existing items from the target if they are not present in the source.  ","version":"Next","tagName":"h3"},{"title":"Array-Like Lazy-Loading‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#array-like-lazy-loading","content":" Lazy loading if the target is type-hinted with ArrayAccess, Traversable orCollectionInterface. The target will not iterate the source object until it is accessed, or never if it is never accessed.Stream mapping. Maps the source members to the target side as they are being iterated. This may consume less memory.With lazy loading, if the source is a Countable, then the target will also be a Countable. With an extra-lazy Doctrine Collection, the consumer will be able to count the target without causing a full hydration of the source.  ","version":"Next","tagName":"h3"},{"title":"Development Experience (DX)‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#development-experience-dx","content":" Helpful exception messages.Console commands for debugging.Data collector and profiler integration.Coded from the start using PHP 8, strict types, and maxed-out PHPStan and Psalm level.  ","version":"Next","tagName":"h3"},{"title":"To-Do List‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#to-do-list","content":" Option to read &amp; write to private properties.Migrate engine to symfony/type-info.Auto-detect static factory method.Improve non-framework usage.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/mapper/intro#contributing","content":" Issues and pull requests should be filed in the GitHub repositoryrekalogika/mapper. ","version":"Next","tagName":"h2"},{"title":"Mapping Table","type":0,"sectionRef":"#","url":"/mapper/mapping-table","content":"","keywords":"","version":"Next"},{"title":"Mapping Table Properties‚Äã","type":1,"pageTitle":"Mapping Table","url":"/mapper/mapping-table#mapping-table-properties","content":" A row in the mapping table has the following properties:  Ordering number. Transformers have a priority. A mapping entry generated by a transformer with a higher priority will be checked earlier than those generated by one with a lower priority.Source and target type pair.Target variance. Invariant means the target type must be exactly the same as specified in the mapping table. Variant means the target type can also be a subclass of the type specified in the mapping table. Note that the source type is always variant.Transformer service ID.  ","version":"Next","tagName":"h2"},{"title":"Viewing the Mapping Table‚Äã","type":1,"pageTitle":"Mapping Table","url":"/mapper/mapping-table#viewing-the-mapping-table","content":" To inspect the mapping table, you can use the rekalogika:mapper:mappingcommand:  $ php bin/console rekalogika:mapper:mapping   The Mapper panel of the Symfony Profiler also shows the mapping table.  ","version":"Next","tagName":"h2"},{"title":"Default Mapping Table‚Äã","type":1,"pageTitle":"Mapping Table","url":"/mapper/mapping-table#default-mapping-table","content":" Ordering\tSource Type\tTarget Type\tTarget Variance\tClass1\tnull\tnull\tinvariant\tNullToNullTransformer 2\tint\tint\tinvariant\tScalarToScalarTransformer 3\tint\tfloat\tinvariant\tScalarToScalarTransformer 4\tint\tstring\tinvariant\tScalarToScalarTransformer 5\tint\tbool\tinvariant\tScalarToScalarTransformer 6\tfloat\tint\tinvariant\tScalarToScalarTransformer 7\tfloat\tfloat\tinvariant\tScalarToScalarTransformer 8\tfloat\tstring\tinvariant\tScalarToScalarTransformer 9\tfloat\tbool\tinvariant\tScalarToScalarTransformer 10\tstring\tint\tinvariant\tScalarToScalarTransformer 11\tstring\tfloat\tinvariant\tScalarToScalarTransformer 12\tstring\tstring\tinvariant\tScalarToScalarTransformer 13\tstring\tbool\tinvariant\tScalarToScalarTransformer 14\tbool\tint\tinvariant\tScalarToScalarTransformer 15\tbool\tfloat\tinvariant\tScalarToScalarTransformer 16\tbool\tstring\tinvariant\tScalarToScalarTransformer 17\tbool\tbool\tinvariant\tScalarToScalarTransformer 18\tstring\tDateTimeInterface\tinvariant\tDateTimeTransformer 19\tstring\tDateTime\tinvariant\tDateTimeTransformer 20\tstring\tDateTimeImmutable\tinvariant\tDateTimeTransformer 21\tstring\tDatePoint\tinvariant\tDateTimeTransformer 22\tDateTimeInterface\tDateTimeInterface\tinvariant\tDateTimeTransformer 23\tDateTimeInterface\tDateTime\tinvariant\tDateTimeTransformer 24\tDateTimeInterface\tDateTimeImmutable\tinvariant\tDateTimeTransformer 25\tDateTimeInterface\tDatePoint\tinvariant\tDateTimeTransformer 26\tDateTimeInterface\tstring\tinvariant\tDateTimeTransformer 27\tstring\tBackedEnum\tvariant\tStringToBackedEnumTransformer 28\tMapToObjectInterface\tobject\tvariant\tClassMethodTransformer 29\tobject\tMapFromObjectInterface\tvariant\tClassMethodTransformer 30\tStringable\tstring\tinvariant\tObjectToStringTransformer 31\tUnitEnum\tstring\tinvariant\tObjectToStringTransformer 32\tTraversable\tCollection\tinvariant\tTraversableToArrayAccessTransformer 33\tTraversable\tReadableCollection\tinvariant\tTraversableToArrayAccessTransformer 34\tTraversable\tArrayCollection\tinvariant\tTraversableToArrayAccessTransformer 35\tTraversable\tArrayObject\tinvariant\tTraversableToArrayAccessTransformer 36\tTraversable\tArrayIterator\tinvariant\tTraversableToArrayAccessTransformer 37\tTraversable\tArrayAccess\tinvariant\tTraversableToArrayAccessTransformer 38\tTraversable\tCollectionInterface\tinvariant\tTraversableToArrayAccessTransformer 39\tTraversable\tarray\tinvariant\tTraversableToArrayAccessTransformer 40\tarray\tCollection\tinvariant\tTraversableToArrayAccessTransformer 41\tarray\tReadableCollection\tinvariant\tTraversableToArrayAccessTransformer 42\tarray\tArrayCollection\tinvariant\tTraversableToArrayAccessTransformer 43\tarray\tArrayObject\tinvariant\tTraversableToArrayAccessTransformer 44\tarray\tArrayIterator\tinvariant\tTraversableToArrayAccessTransformer 45\tarray\tArrayAccess\tinvariant\tTraversableToArrayAccessTransformer 46\tarray\tCollectionInterface\tinvariant\tTraversableToArrayAccessTransformer 47\tarray\tarray\tinvariant\tTraversableToArrayAccessTransformer 48\tTraversable\tTraversable\tinvariant\tTraversableToTraversableTransformer 49\tarray\tTraversable\tinvariant\tTraversableToTraversableTransformer 50\tobject\tarray\tinvariant\tObjectToArrayTransformer 51\tarray\tobject\tvariant\tArrayToObjectTransformer 52\tobject\tobject\tvariant\tObjectToObjectTransformer 53\tnull\tstring\tinvariant\tNullTransformer 54\tnull\tint\tinvariant\tNullTransformer 55\tnull\tfloat\tinvariant\tNullTransformer 56\tnull\tbool\tinvariant\tNullTransformer 57\tnull\tarray\tinvariant\tNullTransformer 58\tmixed\tnull\tinvariant\tNullTransformer 59\tmixed\tmixed\tvariant\tCopyTransformer ","version":"Next","tagName":"h2"},{"title":"Mapping Object to Object","type":0,"sectionRef":"#","url":"/mapper/object","content":"Mapping Object to Object üìÑÔ∏è General Mapping an object to another object is the most common task done by a mapper. üìÑÔ∏è Changing the Mapping Behavior with the Map Attribute By default, Mapper will map a property on the source side to a property with the üìÑÔ∏è Mapping to Abstract Classes and Interfaces To map to an abstract class or an interface, you can add the attribute üìÑÔ∏è Custom Property Mapper If you need a custom mapping logic for a specific property, you can create a üìÑÔ∏è Lazy Loading If the specified target is a class, not an existing object, Mapper will attempt üìÑÔ∏è Dynamic Properties &amp; Property Overloading Dynamic properties are properties that are not explicitly declared in the class üìÑÔ∏è Immutable Objects Immutable objects are objects whose state cannot be changed after they are üìÑÔ∏è Extra Target Values Mapper will map the properties of the source object to that of the target","keywords":"","version":"Next"},{"title":"Mapping to Abstract Classes and Interfaces","type":0,"sectionRef":"#","url":"/mapper/object/abstract-interface","content":"Mapping to Abstract Classes and Interfaces To map to an abstract class or an interface, you can add the attributeInheritanceMap to specify the concrete class the mapper will map to. For example: use Rekalogika\\Mapper\\Attribute\\InheritanceMap; use Rekalogika\\Mapper\\Tests\\Fixtures\\Inheritance\\ConcreteClassA; use Rekalogika\\Mapper\\Tests\\Fixtures\\Inheritance\\ConcreteClassB; #[InheritanceMap([ ConcreteClassA::class =&gt; ConcreteClassADto::class, ConcreteClassB::class =&gt; ConcreteClassBDto::class, ConcreteClassB::class =&gt; ConcreteClassCDto::class, ])] abstract class AbstractClassDto { } In the above example, the mapper will map the source to ConcreteClassADto if the source is an instance of ConcreteClassA, and so on. info This only applies if there is no a preexisting object on the target side. If there is already an object on the target side, Mapper will map to that object instead. Protip The #[InheritanceMap] is bidirectional. If Mapper encounters the attribute on the source side, it will flip the mapping, so the same attribute above will also work in reverse.","keywords":"","version":"Next"},{"title":"Dynamic Properties & Property Overloading","type":0,"sectionRef":"#","url":"/mapper/object/dynamic-properties","content":"","keywords":"","version":"Next"},{"title":"Mapper Semantic for Dynamic Properties‚Äã","type":1,"pageTitle":"Dynamic Properties & Property Overloading","url":"/mapper/object/dynamic-properties#mapper-semantic-for-dynamic-properties","content":" Mapper supports classes with #[AllowDynamicProperties], including stdClassand all classes that extends stdClass, with the following semantics.  If the target is stdClass (or an object with #[AllowDynamicProperties]), then all properties of the source will be mapped to the target. If the target has explicit properties, then they will be respected as usual.  If the source is a stdClass (or an object with #[AllowDynamicProperties]) and the target is a regular object, then the mapping will take place for each property of the target that has a matching property on the source side.  If the source is a stdClass (or an object with #[AllowDynamicProperties]) and an argument of the target constructor is mandatory, then Mapper will assume the source value is null.  ","version":"Next","tagName":"h2"},{"title":"Classes With Overloading, or __get() and __set() Methods‚Äã","type":1,"pageTitle":"Dynamic Properties & Property Overloading","url":"/mapper/object/dynamic-properties#classes-with-overloading-or-__get-and-__set-methods","content":" Classes that use overloading, or have __get() and __set() methods generally work the same way with Mapper as classes with dynamic properties as above.  You can throw BadMethodCallException in your __get() and __set() methods if you want to indicate that the property being accessed does not exist. ","version":"Next","tagName":"h2"},{"title":"Manual Mapping using an Object Mapper","type":0,"sectionRef":"#","url":"/mapper/object-mapper","content":"","keywords":"","version":"Next"},{"title":"Getting the Existing Target Value‚Äã","type":1,"pageTitle":"Manual Mapping using an Object Mapper","url":"/mapper/object-mapper#getting-the-existing-target-value","content":" If you need to get the existing value of the target property, you can add the optional second argument to the method. The mapper will pass the existing value to the method.  use Brick\\Money\\Money; use Rekalogika\\Mapper\\Attribute\\AsObjectMapper; class MoneyObjectMapper { #[AsObjectMapper] public function mapMoneyDtoToMoney( MoneyDto $moneyDto, Money $existingMoney ): Money { return Money::of($moneyDto-&gt;getAmount(), $moneyDto-&gt;getCurrency()); } }   note You may return the original instance or a new instance. If you return a new instance, Mapper will replace the original instance with the new one.  ","version":"Next","tagName":"h2"},{"title":"Extra Arguments‚Äã","type":1,"pageTitle":"Manual Mapping using an Object Mapper","url":"/mapper/object-mapper#extra-arguments","content":" You also have the option to inject the main transformer, sub-mapper, and the context to the property mapper. This can be in any order, but the first argument must be the source object.  use Brick\\Money\\Money; use Rekalogika\\Mapper\\Attribute\\AsObjectMapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MainTransformerInterface; use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; class MoneyObjectMapper { #[AsObjectMapper] public function mapMoneyToMoneyDto( Money $money, MainTransformerInterface $mainTransformer, SubMapperInterface $subMapper, Context $context ): MoneyDto { return new MoneyDto( $money-&gt;getAmount()-&gt;__toString(), $money-&gt;getCurrency()-&gt;getCurrencyCode(), ); } }   ","version":"Next","tagName":"h2"},{"title":"Source Union Types‚Äã","type":1,"pageTitle":"Manual Mapping using an Object Mapper","url":"/mapper/object-mapper#source-union-types","content":" Union types on the source side are supported.  use Rekalogika\\Mapper\\Attribute\\AsObjectMapper; class AnimalMapper { #[AsObjectMapper()] public function mapCatOrDogToAnimalDto(Cat|Dog $animal): AnimalDto { return new AnimalDto($animal); } }   Read more about the sub mapper in the SubMapper chapter.  ","version":"Next","tagName":"h2"},{"title":"Using a Lazy-Loading Proxy‚Äã","type":1,"pageTitle":"Manual Mapping using an Object Mapper","url":"/mapper/object-mapper#using-a-lazy-loading-proxy","content":" Instead of doing the mapping immediately, you can also use the createProxy()method to create a target proxy object. The mapping will be deferred to the point when you first access the properties of the proxy object.  use Brick\\Money\\Money; use Rekalogika\\Mapper\\Attribute\\AsObjectMapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MainTransformerInterface; use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; class MoneyObjectMapper { #[AsObjectMapper] public function mapMoneyToMoneyDto( Money $source, SubMapperInterface $subMapper, ): MoneyDto { return $subMapper-&gt;createProxy( MoneyDto::class, static function (MoneyDto $target) use ($source) { $target-&gt;__construct( $source-&gt;getAmount()-&gt;__toString(), $source-&gt;getCurrency()-&gt;getCurrencyCode(), ); }, ); } }   Read more about the createProxy() method in the SubMapperchapter. ","version":"Next","tagName":"h2"},{"title":"Creating a Custom Transformer","type":0,"sectionRef":"#","url":"/mapper/creating-transformer","content":"","keywords":"","version":"Next"},{"title":"Creating the Transformer‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#creating-the-transformer","content":" Suppose you are using the brick/money library to represent a monetary value in your application, and you need to map the Money object to the following DTO:  src/Dto/MoneyDto.php namespace App\\Dto; class MoneyDto { public function __construct( private string $amount, private string $currency, ) { } public function getAmount(): string { return $this-&gt;amount; } public function getCurrency(): string { return $this-&gt;currency; } }   You can create the transformer as follows:  src/Mapper/MoneyToMoneyDtoTransformer.php namespace App\\Mapper; use Brick\\Money\\Money; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; use Rekalogika\\Mapper\\Contracts\\TypeMapping; use Rekalogika\\Mapper\\Util\\TypeCheck; use Rekalogika\\Mapper\\Util\\TypeFactory; use Symfony\\Component\\PropertyInfo\\Type; class MoneyToMoneyDtoTransformer implements TransformerInterface { // This tells the library that this transformer supports the transformation // from the Money object to the MoneyDto object, and vice versa. // // The TypeFactory methods are convenience methods for creating the // PropertyInfo Type objects. public function getSupportedTransformation(): iterable { yield new TypeMapping( TypeFactory::objectOfClass(Money::class), TypeFactory::objectOfClass(MoneyDto::class) ); yield new TypeMapping( TypeFactory::objectOfClass(MoneyDto::class), TypeFactory::objectOfClass(Money::class) ); } // This method is called when the mapper is trying to transform Money to // MoneyDto, and vice versa. // // The $source and $target parameters are the source and target objects, // respectively. $target is usually null, unless there is already an // existing value in the target object. // // $sourceType and $targetType are the types of the source and target, in // the form of PropertyInfo Type object. // // The TypeCheck class is a convenience class for verifying the type // specified by a Type object. public function transform( mixed $source, mixed $target, ?Type $sourceType, ?Type $targetType, Context $context ): mixed { if ( $source instanceof Money &amp;&amp; TypeCheck::isObjectOfType($targetType, MoneyDto::class) ) { return new MoneyDto( amount: $source-&gt;getAmount()-&gt;__toString(), currency: $source-&gt;getCurrency()-&gt;getCurrencyCode(), ); } if ( $source instanceof MoneyDto &amp;&amp; TypeCheck::isObjectOfType($targetType, Money::class) ) { return Money::of( $source-&gt;getAmount(), $source-&gt;getCurrency() ); } throw new InvalidArgumentException('Unsupported transformation'); } }   ","version":"Next","tagName":"h2"},{"title":"Registering the Transformer‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#registering-the-transformer","content":" If you are not using autoconfiguration, you need to register the transformer and add the rekalogika.mapper.transformer tag:  config/services.yaml services: App\\Mapper\\MoneyToMoneyDtoTransformer: tags: - { name: rekalogika.mapper.transformer, priority: 0 }   info The default priority is 0. The higher the priority, the mapping supplied by the transformer will be considered earlier.  If you are using autoconfiguration, you can use the #[AsTaggedItem] attribute to set its priority.  ","version":"Next","tagName":"h2"},{"title":"Verifying‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#verifying","content":" To verify that the transformer is registered, you can use the debug:containercommand:  php bin/console debug:container --tag=rekalogika.mapper.transformer   Also, you can verify the existence of the transformer in the mapping table:  php bin/console rekalogika:mapper:mapping   ","version":"Next","tagName":"h2"},{"title":"Delegating Mapping to the Main Transformer‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#delegating-mapping-to-the-main-transformer","content":" Your transformer does not need to do everything. You can delegate the mapping of properties or other objects back to the main transformer. To accomplish this, your transformer needs to implement MainTransformerAwareInterface. We also provide MainTransformerAwareTrait to help you with that:  src/Mapper/MyObjectToMyDtoTransformer.php namespace App\\Mapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\MainTransformerAwareInterface; use Rekalogika\\Mapper\\Contracts\\MainTransformerInterface; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; class MyObjectToMyDtoTransformer implements TransformerInterface, MainTransformerAwareInterface { use MainTransformerAwareTrait; public function transform( mixed $source, mixed $target, ?Type $sourceType, ?Type $targetType, Context $context ): mixed { // ... // delegating the task of transforming 'someProperty' to the main // transformer $target-&gt;someProperty = $this-&gt;getMainTransformer()-&gt;transform( source: $source-&gt;getSomeProperty(), target: $target-&gt;someProperty, // current value of the target targetTypes: [TypeFactory::objectOfClass(SomeDto::class)] context: $context ); // ... return $target; } // ... }   ","version":"Next","tagName":"h2"},{"title":"Variant Target Matching‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#variant-target-matching","content":" By default, the target in the mapping is invariant. This means that the target type must exactly be the same as the target specified in the mapping. For example, the mapping MoneyToMoneyDtoTransformer above is invariant. It will only do the mapping if the target is type-hinted exactly MoneyDto, but not any of its subclasses.  To get a variant matching, set the third parameter of TypeMapping to true.  use Brick\\Money\\Money; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; use Rekalogika\\Mapper\\Contracts\\TypeMapping; use Rekalogika\\Mapper\\Util\\TypeFactory; class MoneyToMoneyDtoTransformer implements TransformerInterface { // ... public function getSupportedTransformation(): iterable { yield new TypeMapping( TypeFactory::objectOfClass(Money::class), TypeFactory::objectOfClass(MoneyDto::class), true ); } // ... }   Suppose you have a UsdMoneyDto object that extends MoneyDto, using the example above, the mapping will apply if the target is type-hinted asMoneyDto or UsdMoneyDto.  info The source is always variant.  ","version":"Next","tagName":"h2"},{"title":"Caching and Circular References Detection‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#caching-and-circular-references-detection","content":" If you delegate the mapping of the property of your object, your transformer should add the resulting object to the cache right after instantiation, but before mapping its properties. This is done to prevent infinite recursion when there is a circular reference in the source object.  src/Mapper/MyObjectToMyDtoTransformer.php namespace App\\Mapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\MainTransformerAwareInterface; use Rekalogika\\Mapper\\Contracts\\MainTransformerInterface; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; use Symfony\\Component\\PropertyInfo\\PropertyTypeExtractorInterface; class MyObjectToMyDtoTransformer implements TransformerInterface, { public function transform( mixed $source, mixed $target, ?Type $sourceType, ?Type $targetType, Context $context ): mixed { // ... // instantiate the target object $target = new MyDto(); // add it to the cache $context(ObjectCache::class) -&gt;saveTarget($source, $targetType, $target); // delegate the work of mapping the property to the main transformer $target-&gt;property = $this-&gt;getMainTransformer()-&gt;transform( source: $source-&gt;getProperty(), target: $target-&gt;property, targetTypes: $this-&gt;propertyTypeExtractor -&gt;getTypes($target, 'property'); context: $context ); return $target; } // ... }   ","version":"Next","tagName":"h2"},{"title":"Attribute Matching‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#attribute-matching","content":" You can also match classes using attributes in your transformers, in addition to using class names. The prerequisite is that your attribute needs to implementMapperAttributeInterface.  src/Attribute/MyAttribute.php use Rekalogika\\Mapper\\Attribute\\MapperAttributeInterface; #[\\Attribute(\\Attribute::TARGET_CLASS)] class SomeAttribute implements MapperAttributeInterface { }   Then you can use it as if it is the object's class name in yourgetSupportedTransformation().  src/Mapper/MyObjectToMyDtoTransformer.php use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; use Rekalogika\\Mapper\\Contracts\\TypeMapping; use Rekalogika\\Mapper\\Util\\TypeCheck; use Rekalogika\\Mapper\\Util\\TypeFactory; use Symfony\\Component\\PropertyInfo\\Type; class MyObjectToMyDtoTransformer implements TransformerInterface { // ... public function getSupportedTransformation(): iterable { yield new TypeMapping( TypeFactory::objectOfClass(SomeAttribute::class), TypeFactory::objectOfClass(SomeDto::class) ); } // ... }   When using attributes, the $sourceType and $targetType parameters in thetransform() method will refer to the type of the attribute, not the object.  ","version":"Next","tagName":"h2"},{"title":"Refusal to Transform‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#refusal-to-transform","content":" If the transformer throws RefuseToHandleException, the MainTransformer will pass the mapping to the next transformer in the priority chain.  src/Mapper/MyObjectToMyDtoTransformer.php namespace App\\Mapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; class MyObjectToMyDtoTransformer implements TransformerInterface, { public function transform( mixed $source, mixed $target, ?Type $sourceType, ?Type $targetType, Context $context ): mixed { if ($source instanceof MyObject) { throw new RefuseToHandleException(); } // ... } // ... }   ","version":"Next","tagName":"h2"},{"title":"Property Path‚Äã","type":1,"pageTitle":"Creating a Custom Transformer","url":"/mapper/creating-transformer#property-path","content":" MainInterface::transform() has an optional $path parameter. If your transformer defers the mapping of a property to the main transformer, you should pass the property name to this parameter. It will be used for tracing and for generating a meaningful exception message if the mapping fails.  src/Mapper/MyObjectToMyDtoTransformer.php namespace App\\Mapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; class MyObjectToMyDtoTransformer implements TransformerInterface, { public function transform( mixed $source, mixed $target, ?Type $sourceType, ?Type $targetType, Context $context ): mixed { // ... // delegate the work of mapping the property to the main transformer $target-&gt;someProperty = $this-&gt;getMainTransformer()-&gt;transform( source: $source-&gt;getProperty(), target: $target-&gt;someProperty, targetTypes: $this-&gt;propertyTypeExtractor -&gt;getTypes($target, 'someProperty'); context: $context, path: 'someProperty' ); return $target; } // ... }   If your target object is an array-like object, you should use the [n]notation:  src/Mapper/MyObjectToMyDtoTransformer.php namespace App\\Mapper; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Contracts\\TransformerInterface; class MyObjectToMyDtoTransformer implements TransformerInterface, { public function transform( mixed $source, mixed $target, ?Type $sourceType, ?Type $targetType, Context $context ): mixed { // ... // delegate the work of mapping the array key to the main transformer $target[$key] = $this-&gt;getMainTransformer()-&gt;transform( source: $source[$key], target: $target[$key], targetTypes: $targetTypes, context: $context, path: sprintf('[%s]', $key) ); return $target; } // ... }  ","version":"Next","tagName":"h2"},{"title":"Extra Target Values","type":0,"sectionRef":"#","url":"/mapper/object/extra-target-values","content":"Extra Target Values Mapper will map the properties of the source object to that of the target object. However, there might be times when you need to set additional values to the target object that are not present in the source object. You can specify these additional values using the ExtraTargetValues context object. use Rekalogika\\Mapper\\Context\\ExtraTargetValues; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MapperInterface; /** @var MapperInterface $mapper */ $target = $mapper-&gt;map( source: new SomeObject(), target: SomeObjectDto::class, context: Context::create( new ExtraTargetValues([ SomeObjectDto::class =&gt; [ 'date' =&gt; new \\DateTimeImmutable('2021-01-01'), ], ]), ), ); In the example above, the date property of the SomeObjectDto class will be set to 2021-01-01. The value will be set on the target object using the same mechanism as the normal mapping process, including on constructor arguments, setters, and public properties.","keywords":"","version":"Next"},{"title":"General","type":0,"sectionRef":"#","url":"/mapper/object/general","content":"","keywords":"","version":"Next"},{"title":"How It Works‚Äã","type":1,"pageTitle":"General","url":"/mapper/object/general#how-it-works","content":" The mapper identifies properties that have the same name on the source and the target side. It looks at public properties, public getters &amp; setters, and constructor arguments.  It gets the existing value on the target side. If it is null, then it instantiates a new target object, populating its constructor arguments by transforming properties of the same name from the source object.  Then, it transforms each source property to the target type, and sets them on the target. ","version":"Next","tagName":"h2"},{"title":"Immutable Objects","type":0,"sectionRef":"#","url":"/mapper/object/immutable-objects","content":"Immutable Objects Immutable objects are objects whose state cannot be changed after they are created. Their state is set during construction and cannot be changed. While the object itself is immutable, it can provide an immutable setter method, also known as a wither method. Rather than returning void or itself, the wither method returns a new instance of the object with the requested change. Mapper supports these immutable setters, as well as immutable adders and removers. The caveat is that the host object that contains the immutable object must have a setter method that accepts the new instance. Otherwise, Mapper will give a warning. note Mapping using property paths does not support immutable setters.","keywords":"","version":"Next"},{"title":"Custom Property Mapper","type":0,"sectionRef":"#","url":"/mapper/object/custom-property-mapper","content":"","keywords":"","version":"Next"},{"title":"Basic Usage‚Äã","type":1,"pageTitle":"Custom Property Mapper","url":"/mapper/object/custom-property-mapper#basic-usage","content":" Example:  use Rekalogika\\Mapper\\Attribute\\AsPropertyMapper; class UserMapper { #[AsPropertyMapper( targetClass: UserDto::class, property: 'name', )] public function mapName(User $user): string { return strtoupper($user-&gt;getFirstName() . ' ' . $user-&gt;getLastName()); } }   The above example concatenates first name and last name from the source Userobject, transforms it to uppercase, and returns the result. Mapper will then assign the result to the name property of the target UserDto object, as specified in the arguments of the AsPropertyMapper attribute.  ","version":"Next","tagName":"h2"},{"title":"Shorthand Using AsPropertyMapper Attached to the Class‚Äã","type":1,"pageTitle":"Custom Property Mapper","url":"/mapper/object/custom-property-mapper#shorthand-using-aspropertymapper-attached-to-the-class","content":" If you have many properties to manually map, you can put the AsPropertyMapperattribute on the class, and it will apply to all methods in the class. Example:  use Rekalogika\\Mapper\\Attribute\\AsPropertyMapper; #[AsPropertyMapper(targetClass: UserDto::class)] class UserMapper { #[AsPropertyMapper('name')] public function mapName(User $user): string { return strtoupper($user-&gt;getFirstName() . ' ' . $user-&gt;getLastName()); } #[AsPropertyMapper('birthDate')] public function mapBirthDate(User $user): string { return $user-&gt;getBirthDate()-&gt;format('Y-m-d'); } #[AsPropertyMapper('email')] public function mapEmail(User $user): string { return $user-&gt;getEmailAddress(); } }   ","version":"Next","tagName":"h2"},{"title":"Property Name Magic‚Äã","type":1,"pageTitle":"Custom Property Mapper","url":"/mapper/object/custom-property-mapper#property-name-magic","content":" For even more shorthand, you can omit the property name altogether, and the mapper will use the method name, stripping the leading 'map' and lowercasing the first letter.  use Rekalogika\\Mapper\\Attribute\\AsPropertyMapper; #[AsPropertyMapper(targetClass: UserDto::class)] class UserMapper { // maps to 'name' #[AsPropertyMapper] public function mapName(User $user): string { return strtoupper($user-&gt;getFirstName() . ' ' . $user-&gt;getLastName()); } // maps to 'birthDate' #[AsPropertyMapper] public function mapBirthDate(User $user): string { return $user-&gt;getBirthDate()-&gt;format('Y-m-d'); } // maps to 'email #[AsPropertyMapper] public function mapEmail(User $user): string { return $user-&gt;getEmailAddress(); } }   ","version":"Next","tagName":"h2"},{"title":"Getting the Existing Target Value‚Äã","type":1,"pageTitle":"Custom Property Mapper","url":"/mapper/object/custom-property-mapper#getting-the-existing-target-value","content":" If you need to get the existing value of the target property, you can add the optional second argument to the method. The mapper will pass the existing value to the method.  use Rekalogika\\Mapper\\Attribute\\AsPropertyMapper; class UserMapper { #[AsPropertyMapper( targetClass: User::class, property: 'birthDate', )] public function mapBirthDate( UserDto $userDto, ?\\DateTimeInterface $birthDate // this will contain the current value ): \\DateTimeInterface { return new \\DateTimeImmutable($userDto-&gt;birthDate); } }   note If the target property contains an object, you may return the original instance or a new instance. If you return a new instance, Mapper will replace the original instance with the new one.  ","version":"Next","tagName":"h2"},{"title":"Extra Arguments‚Äã","type":1,"pageTitle":"Custom Property Mapper","url":"/mapper/object/custom-property-mapper#extra-arguments","content":" You also have the option to inject the main transformer, sub-mapper, and the context to the property mapper. This can be in any order, but the first argument must be the source object, followed by an optional second argument for the existing target value.  use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MainTransformerInterface; use Rekalogika\\Mapper\\Attribute\\AsPropertyMapper; use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; #[AsPropertyMapper(targetClass: UserDto::class)] class UserMapper { #[AsPropertyMapper] public function mapName( User $user, MainTransformerInterface $mainTransformer, SubMapperInterface $subMapper, Context $context ): string { return strtoupper($user-&gt;getFirstName() . ' ' . $user-&gt;getLastName()); } }   ","version":"Next","tagName":"h2"},{"title":"Source Union Types‚Äã","type":1,"pageTitle":"Custom Property Mapper","url":"/mapper/object/custom-property-mapper#source-union-types","content":" Union types on the source side are supported.  use Rekalogika\\Mapper\\Attribute\\AsPropertyMapper; class AnimalMapper { #[AsPropertyMapper( targetClass: AnimalDto::class, property: 'name', )] public function mapName(Cat|Dog $animal): string { return $animal-&gt;getName(); } }   ","version":"Next","tagName":"h2"},{"title":"Refusing To Map‚Äã","type":1,"pageTitle":"Custom Property Mapper","url":"/mapper/object/custom-property-mapper#refusing-to-map","content":" If you throw RefuseToMapException from the property mapper, the mapper will skip mapping the property.  use Rekalogika\\Mapper\\Attribute\\AsPropertyMapper; use Rekalogika\\Mapper\\Exception\\RefuseToMapException; class UserMapper { #[AsPropertyMapper( targetClass: UserDto::class, property: 'name', )] public function mapName(User $user): string { if ($user-&gt;isDeleted()) { throw new RefuseToMapException(); } return strtoupper($user-&gt;getFirstName() . ' ' . $user-&gt;getLastName()); } }   ","version":"Next","tagName":"h2"},{"title":"Handling Uninitialized Properties‚Äã","type":1,"pageTitle":"Custom Property Mapper","url":"/mapper/object/custom-property-mapper#handling-uninitialized-properties","content":" Because Mapper doesn't know the source property your custom property mapper will be reading from, you need to handle the case if the source property might be uninitialized.  Alternatively, you can use the ignoreUninitialized argument of the AsPropertyMapper attribute to make Mapper ignore any uninitialized errors if it occurs inside your custom property mapper.  Both property mappers below will accomplish the same thing.  Manually:  use Rekalogika\\Mapper\\Attribute\\AsPropertyMapper; use Rekalogika\\Mapper\\Exception\\RefuseToMapException; class UserMapper { #[AsPropertyMapper( targetClass: UserDto::class, property: 'name', )] public function mapName(User $user): string { try { return strtoupper($user-&gt;name); } catch (\\Error $e) { if (str_contains($e-&gt;getMessage(), 'must not be accessed before initialization')) { throw new RefuseToMapException(); } throw $e; } } }   With ignoreUninitialized:  use Rekalogika\\Mapper\\Attribute\\AsPropertyMapper; class UserMapper { #[AsPropertyMapper( targetClass: UserDto::class, property: 'name', ignoreUninitialized: true, )] public function mapName(User $user): string { // if $user-&gt;name is uninitialized, Mapper will ignore the mapping. return strtoupper($user-&gt;name); } }   As you can see, using the ignoreUninitialized argument can remove a lot of boilerplate code.  ","version":"Next","tagName":"h2"},{"title":"Manual Wiring‚Äã","type":1,"pageTitle":"Custom Property Mapper","url":"/mapper/object/custom-property-mapper#manual-wiring","content":" If you don't use autowiring, autoconfiguration, or don't want to use attributes, you can add the service manually like this:  config/services.yaml services: App\\Mapper\\UserMapper: tags: - name: 'rekalogika.mapper.property_mapper' method: 'mapName' sourceClass: 'App\\Entity\\User' targetClass: 'App\\Dto\\UserDto' property: 'name' - name: 'rekalogika.mapper.property_mapper' method: 'mapBirthDate' sourceClass: 'App\\Entity\\User' targetClass: 'App\\Dto\\UserDto' property: 'birthDate' - name: 'rekalogika.mapper.property_mapper' method: 'mapEmail' sourceClass: 'App\\Entity\\User' targetClass: 'App\\Dto\\UserDto' property: 'email'   ","version":"Next","tagName":"h2"},{"title":"Dumping Property Mapper Table‚Äã","type":1,"pageTitle":"Custom Property Mapper","url":"/mapper/object/custom-property-mapper#dumping-property-mapper-table","content":" To dump the list of all property mappers, run the following command:  $ bin/console debug:container --tag=rekalogika.mapper.property_mapper  ","version":"Next","tagName":"h2"},{"title":"Lazy Loading","type":0,"sectionRef":"#","url":"/mapper/object/lazy-loading","content":"","keywords":"","version":"Next"},{"title":"Mapping to Doctrine Entities‚Äã","type":1,"pageTitle":"Lazy Loading","url":"/mapper/object/lazy-loading#mapping-to-doctrine-entities","content":" Doctrine reads properties using Reflection directly, and therefore will not trigger the hydration of our proxy objects. To prevent problems while working with Doctrine entities, Mapper will prevent proxy creation if the target is a Doctrine entity.  ","version":"Next","tagName":"h2"},{"title":"API Platform‚Äã","type":1,"pageTitle":"Lazy Loading","url":"/mapper/object/lazy-loading#api-platform","content":" With API Platform, if you are using DTOs as ApiResource, then API Platform should be able to generate IRIs without causing the hydration of the source (if the source is a Doctrine entity). The only thing you need to do is to ensure the source (a Doctrine entity) and the target (an ApiResource DTO) both use the same identifier property name. Or better: just use id as the identifier everywhere, and be done with it.  Without lazy-loading, API Platform will hydrate everything in the object graph, even when it only needs to generate an IRI.  Shameless Plug Read the documentation of api-lite to know more about how we utilize Mapper with API Platform.  ","version":"Next","tagName":"h2"},{"title":"Eager Properties‚Äã","type":1,"pageTitle":"Lazy Loading","url":"/mapper/object/lazy-loading#eager-properties","content":" During the mapping, Mapper will try to identify the identifier properties on the source side. First, it looks for the information in Doctrine's class metadata. If not found, it will use id, uuid, or identifier if any of those exists on the source side.  These identifier properties will not be lazy, and will be mapped immediately after the instantiation of the target proxy object. This should not cause the hydration of the source side because a Doctrine proxy already hold the identifier, even when uninitialized.  If your application needs to have a custom logic for determining the identifier fields, you can create a service implementingEagerPropertiesResolverInterface.  info If an identifier property maps to a constructor argument on the target side, then everything in the constructor will be mapped eagerly.  ","version":"Next","tagName":"h2"},{"title":"PHP 8.4 Lazy Objects‚Äã","type":1,"pageTitle":"Lazy Loading","url":"/mapper/object/lazy-loading#php-84-lazy-objects","content":" Since Mapper 2.0, if you are using PHP 8.4 or later, Mapper will use native PHP lazy objects. There should be no practical difference between the native lazy objects and older symfony/var-exporter lazy objects, except that the new mechanism supports final classes.  Old-style proxy classes will still be generated during warming up. This is done to anticipate the case where the target environment uses different PHP versions.  ","version":"Next","tagName":"h2"},{"title":"Disabling Lazy-Loading‚Äã","type":1,"pageTitle":"Lazy Loading","url":"/mapper/object/lazy-loading#disabling-lazy-loading","content":" There should be no downside to using a lazy-loading proxy in place of the real object. In most cases, they should be interchangeable. However, a proxy incurs a small overhead, and you may wish to disable it in some cases, for example if you are using the Mapper in a batch process.  ","version":"Next","tagName":"h2"},{"title":"Using MapperOptions‚Äã","type":1,"pageTitle":"Lazy Loading","url":"/mapper/object/lazy-loading#using-mapperoptions","content":" If you want to disable lazy-loading for a mapping run, you can set the optionenableLazyLoading to false in the MapperOptions object, and add it to the context:  use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Context\\MapperOptions; $options = new MapperOptions(lazyLoading: false); $context = Context::create($options); $target = $this-&gt;mapper-&gt;map($source, TargetDto::class, $context);   ","version":"Next","tagName":"h3"},{"title":"Using Eager Attribute‚Äã","type":1,"pageTitle":"Lazy Loading","url":"/mapper/object/lazy-loading#using-eager-attribute","content":" To disable proxy creation for a specific class, add the #[Eager] attribute to the target class:  use Rekalogika\\Mapper\\Attribute\\Eager; #[Eager] class TargetDto { // ... }   ","version":"Next","tagName":"h3"},{"title":"Other Ways of Disabling Lazy-Loading‚Äã","type":1,"pageTitle":"Lazy Loading","url":"/mapper/object/lazy-loading#other-ways-of-disabling-lazy-loading","content":" You can instantiate manually, and pass the object as the mapper's target.You can decorate ProxyFactoryInterface, and throwProxyNotSupportedException if it asks for your specific class. ReadDoctrineProxyFactory for an example. ","version":"Next","tagName":"h3"},{"title":"Changing the Mapping Behavior with the Map Attribute","type":0,"sectionRef":"#","url":"/mapper/object/map","content":"","keywords":"","version":"Next"},{"title":"Mapping Properties with Different Source and Target Names‚Äã","type":1,"pageTitle":"Changing the Mapping Behavior with the Map Attribute","url":"/mapper/object/map#mapping-properties-with-different-source-and-target-names","content":" use Rekalogika\\Mapper\\Attribute\\Map; use Rekalogika\\Mapper\\MapperInterface; class SomeObject { public string $sourcePropertyA = 'sourcePropertyA'; } class SomeObjectDto { #[Map(property: 'sourcePropertyA')] public ?string $targetPropertyA = null; } /** @var MapperInterface $mapper */ $source = new SomeObject(); $result = $mapper-&gt;map($source, SomeObjectDto::class);   In the above example, the mapper will map the sourcePropertyA from the source object to the targetPropertyA on the target object.  ","version":"Next","tagName":"h2"},{"title":"Ignoring a Property‚Äã","type":1,"pageTitle":"Changing the Mapping Behavior with the Map Attribute","url":"/mapper/object/map#ignoring-a-property","content":" If you want to ignore a property, you can use the #[Map(false)] attribute:  class SomeObject { #[Map(false)] public string $sourcePropertyA = 'sourcePropertyA'; }   ","version":"Next","tagName":"h2"},{"title":"Bidirectionality‚Äã","type":1,"pageTitle":"Changing the Mapping Behavior with the Map Attribute","url":"/mapper/object/map#bidirectionality","content":" #[Map] is bidirectional, the same attribute above will also work in reverse:  $source = new SomeObjectDto(); $result = $mapper-&gt;map($source, SomeObject::class);   ","version":"Next","tagName":"h2"},{"title":"Virtual Properties‚Äã","type":1,"pageTitle":"Changing the Mapping Behavior with the Map Attribute","url":"/mapper/object/map#virtual-properties","content":" A property may be 'virtual', i.e. it has a getter and setter, but no actual property. In this case, you can place the #[Map] attribute on the getter or setter method:  class Person { #[Map(property: 'alias')] public function getName(): string { return 'John Doe'; } }   Protip It will also work with withers, issers, hassers, canners, adders, and removers.  ","version":"Next","tagName":"h2"},{"title":"Limiting to a Specific Class‚Äã","type":1,"pageTitle":"Changing the Mapping Behavior with the Map Attribute","url":"/mapper/object/map#limiting-to-a-specific-class","content":" The #[Map] attribute has an optional $class argument, which can be used to limit the effect only to a specific paired class. i.e. it will only take effect if the other class is the class specified in the $class argument:  class SomeObjectDto { #[Map(property: 'sourcePropertyA', class: SomeObject::class)] public ?string $targetPropertyA = null; }   Protip You may have multiple #[Map] attributes on the same property, each with a different $class argument.  ","version":"Next","tagName":"h2"},{"title":"Property Path‚Äã","type":1,"pageTitle":"Changing the Mapping Behavior with the Map Attribute","url":"/mapper/object/map#property-path","content":" #[Map] also supports property path using the same syntax provided by Symfony PropertyAccess, i.e. you can map a property to a nested property:  class BookDto { #[Map(property: 'authors[0].name')] public ?string $author = null; }   If the caller tries to map a Book object to a BookDto object above, Mapper will get the name using $book-&gt;getAuthors()[0]-&gt;getName() (or equivalent) and assign it to the author property of the BookDto object.  The reverse will also work. If the caller tries to map a BookDto object to aBook object, Mapper will set the name using$book-&gt;getAuthors()[0]-&gt;setName($bookDto-&gt;author) (or equivalent).  Limitations Property path does not support variadic setter, i.e. things likesetAuthors(Author ...$authors). It also does not support immutable setters, or wither methods. ","version":"Next","tagName":"h2"},{"title":"Predetermined Mapping Preset","type":0,"sectionRef":"#","url":"/mapper/preset","content":"","keywords":"","version":"Next"},{"title":"Usage‚Äã","type":1,"pageTitle":"Predetermined Mapping Preset","url":"/mapper/preset#usage","content":" use Rekalogika\\Mapper\\MapperInterface; use Rekalogika\\Mapper\\Transformer\\Context\\PresetMapping; use Rekalogika\\Mapper\\Context\\Context; /** @var MapperInterface $mapper */ /** @var Book $book */ /** @var BookDto $bookDto */ // this means if a Book is being mapped to a BookDto, use the provided $bookDto // @todo this is wrong $presetMapping = new PresetMapping([ $book =&gt; [ BookDto::class =&gt; $bookDto, ] ]) $context = Context::create($presetMapping); $result = $mapper-&gt;map($book, BookDto::class, $context); assert($bookDto === $result); // true   ","version":"Next","tagName":"h2"},{"title":"Populating PresetMapping from an Existing ObjectCache‚Äã","type":1,"pageTitle":"Predetermined Mapping Preset","url":"/mapper/preset#populating-presetmapping-from-an-existing-objectcache","content":" You can use the ObjectCache from a previous mapping to populate thePresetMapping object.  use Rekalogika\\Mapper\\ObjectCache\\ObjectCacheFactoryInterface; use Rekalogika\\Mapper\\Transformer\\Context\\PresetMapping; use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\MapperInterface; /** @var ObjectCacheFactoryInterface $objectCacheFactory */ /** @var MapperInterface $mapper */ /** @var Book $book */ /** @var BookDto $bookDto */ $objectCache = $objectCacheFactory-&gt;createObjectCache(); $context = Context::create($objectCache); $result = $mapper-&gt;map($book, BookDto::class, $context); $presetMapping = PresetMappingFactory::fromObjectCache($objectCache); // or to get the reversed mapping: $reversedMapping = PresetMappingFactory::fromObjectCacheReversed($objectCache); // ...   You can also generate the reversed mapping from the cache. i.e, a mapping from$book to BookDto::class will generate a PresetMapping containing the mapping from the previous result to Book::class.  use Rekalogika\\Mapper\\Transformer\\Context\\PresetMappingFactory; $reversedPresetMapping = PresetMappingFactory::fromObjectCacheReversed($objectCache);   ","version":"Next","tagName":"h2"},{"title":"Example Use Case: Remembering Mapper‚Äã","type":1,"pageTitle":"Predetermined Mapping Preset","url":"/mapper/preset#example-use-case-remembering-mapper","content":" A mapper that remembers the previous mappings. So you can get the original source object if you have the resulting DTO.  use Rekalogika\\Mapper\\Context\\Context; use Rekalogika\\Mapper\\Exception\\UnexpectedValueException; use Rekalogika\\Mapper\\MapperInterface; use Rekalogika\\Mapper\\ObjectCache\\ObjectCacheFactoryInterface; use Rekalogika\\Mapper\\Transformer\\Context\\PresetMapping; use Rekalogika\\Mapper\\Transformer\\Context\\PresetMappingFactory; use Symfony\\Contracts\\Service\\ResetInterface; class RememberingMapper implements MapperInterface, ResetInterface { private PresetMapping $presetMapping; public function __construct( private MapperInterface $decorated, private ObjectCacheFactoryInterface $objectCacheFactory ) { $this-&gt;presetMapping = new PresetMapping(); } public function reset(): void { $this-&gt;presetMapping = new PresetMapping(); } public function map( object $source, object|string $target, ?Context $context = null ): object { $objectCache = $this-&gt;objectCacheFactory-&gt;createObjectCache(); $context ??= Context::create(); $context = $context-&gt;with($objectCache, $this-&gt;presetMapping); $result = $this-&gt;decorated-&gt;map($source, $target, $context); $newPresetMapping = PresetMappingFactory::fromObjectCacheReversed($objectCache); $this-&gt;presetMapping-&gt;mergeFrom($newPresetMapping); return $result; } }  ","version":"Next","tagName":"h2"},{"title":"rekalogika/pivot-table","type":0,"sectionRef":"#","url":"/pivot-table","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/pivot-table","url":"/pivot-table#sections","content":" üìÑÔ∏è Introduction A PHP library for transforming multidimensional data into a pivot table. üìÑÔ∏è Basic Usage First, we need to procure the data. For maximum functionality, the result should ","version":"Next","tagName":"h2"},{"title":"SubMapper","type":0,"sectionRef":"#","url":"/mapper/submapper","content":"","keywords":"","version":"Next"},{"title":"map() Method‚Äã","type":1,"pageTitle":"SubMapper","url":"/mapper/submapper#map-method","content":" The map() method maps an object to the class or object you specified.  use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; /** @var SubMapperInterface $subMapper */ // using class-string as the target type $postDto = $subMapper-&gt;map($source, PostDto::class); // the target can also be an existing object $postDto = new PostDto(); $subMapper-&gt;map($source, $postDto);   ","version":"Next","tagName":"h2"},{"title":"mapForProperty() Method‚Äã","type":1,"pageTitle":"SubMapper","url":"/mapper/submapper#mapforproperty-method","content":" With the mapForProperty(), you specify the property name of the variable that will contain the result of the mapping. SubMapper will detect the type of the property in $containing::$propertyName and use it as the target type for the mapping.  This is useful if the property is an array or an array-like object, as PHP doesn't have generics and it is not simple to specify the type of the array elements.  use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; class Post { /** @var list&lt;Comment&gt; */ public array $comments; } class Comment {} class PostDto { /** @var list&lt;CommentDto&gt; */ public array $comments; } class CommentDto {} /** @var Post $post */ /** @var SubMapperInterface $subMapper */ $postDto = new PostDto(); $subMapper-&gt;cache($postDto); $commentsDto = $subMapper-&gt;mapForProperty($post-&gt;comments, PostDto::class, 'comments'); $postDto-&gt;comments = $commentsDto;   $containing can be a class string or an existing object. If it is an existing object, SubMapper will attempt to retrieve the current object from the property and map the source to it.  ","version":"Next","tagName":"h2"},{"title":"cache() Method‚Äã","type":1,"pageTitle":"SubMapper","url":"/mapper/submapper#cache-method","content":" To reduce the possibility of infinite recursion due to circular references, you can use the cache() method to store the object that is being mapped. You should call cache() after you instantiate the object and before you delegate the mapping of its properties by calling map() or mapForProperty().  use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; /** @var SubMapperInterface $subMapper */ $postDto = new PostDto(); $subMapper-&gt;cache($postDto); $postDto-&gt;author = $subMapper-&gt;map($source-&gt;author, AuthorDto::class); return $postDto;   ","version":"Next","tagName":"h2"},{"title":"createProxy() Method‚Äã","type":1,"pageTitle":"SubMapper","url":"/mapper/submapper#createproxy-method","content":" You can use the createProxy() method to create a proxy object that will be initialized only after you first access its properties.  use Rekalogika\\Mapper\\SubMapper\\SubMapperInterface; /** @var SubMapperInterface $subMapper */ /** @var Post $source */ // this is the function that will be used to initialize the proxy object $initializer = static function ( PostDto $target ) use ($source): void { $target-&gt;__construct(); $target-&gt;name = $source-&gt;getName(); }; $postDto = $subMapper-&gt;createProxy( PostDto::class, // real target class $initializer, // will be executed when the proxy is first accessed ['id'] // eager properties, accessing these will not trigger the // hydration of the proxy object ); // id is eager, so this will not cause the initializer to be called. $postDto-&gt;id = $post-&gt;getId(); // this will trigger the initializer $name = $postDto-&gt;name;  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/pivot-table/intro","content":"","keywords":"","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction","url":"/pivot-table/intro#features","content":" Handles complex data. Renders complex multi-dimensional data involving multiple dimensions and measures.Flexible pivoting: Configure which dimensions should be pivoted (in columns) vs unpivoted (in rows).Measures are dimension: Measures are regarded as a special dimension@values that can be flexibly positioned in the pivot structure.Subtotals: Renders subtotals if they exist in the source data.Accepts simple array data: Compatible with all result set formats. Does not require specific database and database access libraries.Custom integration options: Options for deeper integration with your application by providing your custom data structure in table-like data, or in data cube if your data is already in that format.Customizable legends: Define custom labels for dimensions, measures, and subtotals.Does not require a specific data type: Your dimension members and measure values can be of any type, including entity objects, money object pattern, etc. You can supply a custom renderer to format the output as required.  ","version":"Next","tagName":"h2"},{"title":"Design Philosophy‚Äã","type":1,"pageTitle":"Introduction","url":"/pivot-table/intro#design-philosophy","content":" The library only transforms the data into a pivot table, but does not perform any calculations like sum, average, etc. This decision is taken because some aggregation functions are only available on the database side and cannot be easily performed using PHP.  If your data needs to be manually aggregated, then a custom aggregation/cubing layer needs to be written.  ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Introduction","url":"/pivot-table/intro#installation","content":" Install via Composer:  composer require rekalogika/pivot-table  ","version":"Next","tagName":"h2"},{"title":"rekalogika/reconstitutor","type":0,"sectionRef":"#","url":"/reconstitutor","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/reconstitutor","url":"/reconstitutor#sections","content":" üìÑÔ∏è Introduction &amp; Installation This library provides a thin layer that sits above Doctrine events to help you üìÑÔ∏è Usage Explains how to use the reconstitutor library. üìÑÔ∏è Methods There are several methods that you can override in your reconstitutor classes. ","version":"Next","tagName":"h2"},{"title":"rekalogika/psr-16-simple-cache-bundle","type":0,"sectionRef":"#","url":"/psr-16-simple-cache-bundle","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"rekalogika/psr-16-simple-cache-bundle","url":"/psr-16-simple-cache-bundle#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony Flex Open a command console, enter your project directory, and execute: composer require rekalogika/psr-16-simple-cache-bundle   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"rekalogika/psr-16-simple-cache-bundle","url":"/psr-16-simple-cache-bundle#usage","content":" Callers can simply wire in Psr\\SimpleCache\\CacheInterface. The service uses the same underlying pool used by Symfony's CacheInterface.  use Psr\\SimpleCache\\CacheInterface; class SomeService { public function __construct(private CacheInterface $cache) { } public function doSomething() { $this-&gt;cache-&gt;set('foo', 'bar'); } }   ","version":"Next","tagName":"h2"},{"title":"Rationale‚Äã","type":1,"pageTitle":"rekalogika/psr-16-simple-cache-bundle","url":"/psr-16-simple-cache-bundle#rationale","content":" We are using PSR-16 mostly as an expiring key-value storage. While PSR-6 and Symfony's CacheInterface are more powerful and easier to use for caching things, we don't feel their interfaces are suitable for key-value storage.  ","version":"Next","tagName":"h2"},{"title":"Credits‚Äã","type":1,"pageTitle":"rekalogika/psr-16-simple-cache-bundle","url":"/psr-16-simple-cache-bundle#credits","content":" This package is just a service definition. The actual implementation is done by the Symfony project; they just don't make the service available by default.  Adapters For Interoperability between PSR-6 and PSR-16 CacheService definition by Tobion  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"rekalogika/psr-16-simple-cache-bundle","url":"/psr-16-simple-cache-bundle#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"rekalogika/psr-16-simple-cache-bundle","url":"/psr-16-simple-cache-bundle#contributing","content":" Issues and pull requests should be filed in the GitHub repositoryrekalogika/psr-16-simple-cache-bundle. ","version":"Next","tagName":"h2"},{"title":"Introduction & Installation","type":0,"sectionRef":"#","url":"/reconstitutor/intro","content":"","keywords":"","version":"Next"},{"title":"Features‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/reconstitutor/intro#features","content":" Streamlines a very specific, yet very common use case of Doctrine events.Simple declaration in a class. You can create a reconstitutor class to handle the reconstitution of a specific entity class, entities that implement a specific interface, entities in a class hierarchy, or those with a specific PHP attribute.Our abstract classes provide get() and set() methods as a convenience. They let you work with the properties directly, bypassing getters and setters. It is the best practice in reconstitutions as it frees you to have business logic in the getters and setters.The get() and set() methods are forwarders to a custom implementation of Symfony's PropertyAccessorInterface. Therefore, you can use the same exceptions defined in PropertyAccessorInterface.Abstracts all the peculiarities of Doctrine events, unit of work, database transactions, and proxy, so you don't have to find out and deal with them yourself.It asks your reconstitutor to save only after Doctrine has successfully saved the object.Does not rely on Doctrine seeing the object being dirty before flush()-ing. i.e. your entities don't have to modify a Doctrine-managed property ‚Äîlike$lastUpdated‚Äî just to make sure the correct Doctrine event will be fired.Handles transactions. In a transaction, it will only ask your reconstitutor to save or remove after the transaction has been successfully committed.  ","version":"Next","tagName":"h2"},{"title":"Installation‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/reconstitutor/intro#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony Flex Open a command console, enter your project directory, and execute: composer require rekalogika/reconstitutor   ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/reconstitutor/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction & Installation","url":"/reconstitutor/intro#contributing","content":" Issues and pull requests should be filed in the GitHub repositoryrekalogika/reconstitutor. ","version":"Next","tagName":"h2"},{"title":"Methods","type":0,"sectionRef":"#","url":"/reconstitutor/methods","content":"","keywords":"","version":"Next"},{"title":"onCreate()‚Äã","type":1,"pageTitle":"Methods","url":"/reconstitutor/methods#oncreate","content":" Executed when the object is added to the persistence layer, e.g. when you first call Doctrine's EntityManager::persist() on the object.  warning Implementors should generally avoid using this method for initializing the object, and instead initialize the object using a factory. Changing the object's behavior in this method can be surprising to the caller and can be considered anti-pattern.  ","version":"Next","tagName":"h2"},{"title":"onLoad()‚Äã","type":1,"pageTitle":"Methods","url":"/reconstitutor/methods#onload","content":" Called when the object is loaded from the database. For example, when you callEntityManager::find() or EntityManager::findAll(), or when you use Queryto load the object.  note If the object is a proxy, onLoad() will be called only after the object is initialized. Calling EntityManager::getReference() by itself does not triggeronLoad().  ","version":"Next","tagName":"h2"},{"title":"onSave()‚Äã","type":1,"pageTitle":"Methods","url":"/reconstitutor/methods#onsave","content":" Called after the object is saved to the database. For example, when you callEntityManager::flush().  note onSave() will be called for all initialized objects in the unit of work, even if the object is not dirty. If the object is an uninitialized proxy, onSave() will not be called on that object.  ","version":"Next","tagName":"h2"},{"title":"onRemove()‚Äã","type":1,"pageTitle":"Methods","url":"/reconstitutor/methods#onremove","content":" Called when the object is removed from the database. For example, when you mark the object to be removed using EntityManager::remove(), then callEntityManager::flush().  note If the object is an uninitialized proxy when you call EntityManager::remove(), the framework will initialize the object before calling onRemove(). SoonRemove() will always get an initialized object, but already removed from database by Doctrine.  ","version":"Next","tagName":"h2"},{"title":"onClear()‚Äã","type":1,"pageTitle":"Methods","url":"/reconstitutor/methods#onclear","content":" Called when the object is cleared from the persistence layer. For example, when you call EntityManager::clear(), and also when you callEntityManager::detach() then EntityManager::flush().  note We cannot call onClear() right on EntityManager::detach(), because Doctrine does not provide the necessary event. We can know they are being detached only after EntityManager::flush() is called because we track the objects as they go through their lifecycle. ","version":"Next","tagName":"h2"},{"title":"Basic Usage","type":0,"sectionRef":"#","url":"/pivot-table/basic-usage","content":"Basic Usage First, we need to procure the data. For maximum functionality, the result should be properly cubed. The following is an example SQL query for PostgreSQL. -- name, country, and month are the dimensions, count and sum are the measures. -- grouping is used to identify if a dimension is subtotaled. SELECT name, country, month, COUNT(*) AS count, SUM(price) AS sum, GROUPING(name, country, month) AS grouping FROM items GROUP BY DISTINCT CUBE(name, country, month) -- ORDER BY clause determines the order of the dimensions in the output ORDER BY name, country, month Then, use whatever means to execute the query and fetch the result as an array of array. We can create a pivot table as follows: use Rekalogika\\PivotTable\\ArrayTable\\ArrayTableFactory; use Rekalogika\\PivotTable\\PivotTableTransformer; use Rekalogika\\PivotTable\\TableRenderer\\BasicTableRenderer; // Create a data cube from the result set $cube = ArrayTableFactory::createCube( input: $data, // must be in the same order as the GROUPING() function in the SQL query: dimensionFields: ['name', 'country', 'month'], measureFields: ['count', 'sum'], groupingField: 'grouping', legends: [ '@values' =&gt; 'Values', 'name' =&gt; 'Item Name', 'country' =&gt; 'Country', 'month' =&gt; 'Month', 'count' =&gt; 'Count', 'sum' =&gt; 'Sum', ], subtotalLabels: [ 'name' =&gt; 'All Names', 'country' =&gt; 'All Countries', 'month' =&gt; 'All Months', ], ); // Transform the cube to HTML table object $htmlTable = PivotTableTransformer::transform( cube: $cube, unpivoted: ['country', 'month'], // Rows pivoted: ['@values', 'name'], // Columns measures: ['count', 'sum'], // Which measures to include withSubtotal: ['name', 'country'], // Add subtotals for these dimensions ); // Render to HTML string $html = BasicTableRenderer::render($htmlTable); echo $html; The resulting HTML table will look like this: Country\tMonth\tCount\tSum Name\tName itemA\titemB\titemC\tAll names\titemA\titemB\titemC\tAll namesCN\t202501\t4\t1\t5\t10\t2586.07\t434.22\t3375.71\t6396 202502\tnull\t5\t1\t6\tnull\t2575.55\t337.29\t2912.84 202503\t4\t5\t3\t12\t2823.54\t2849.01\t1488.2\t7160.75 202504\t3\tnull\tnull\t3\t1301.73\tnull\tnull\t1301.73 202505\tnull\t3\tnull\t3\tnull\t1845.78\tnull\t1845.78 All months\t11\t14\t9\t34\t6711.34\t7704.56\t5201.2\t19617.1 JP\t202501\t1\t3\t4\t8\t107.51\t1410.79\t1765.04\t3283.34 202502\t5\t1\t5\t11\t3119.07\t393.39\t2081.02\t5593.48 202503\tnull\t3\t5\t8\tnull\t1966\t3656.16\t5622.16 202504\t3\t5\t2\t10\t2014.32\t2348.93\t1042.42\t5405.67 202505\tnull\t1\t1\t2\tnull\t973.91\t725.8\t1699.71 All months\t9\t13\t17\t39\t5240.9\t7093.02\t9270.44\t21604.36 KR\t202501\tnull\tnull\t2\t2\tnull\tnull\t1134.36\t1134.36 202502\t5\t3\t1\t9\t1668.59\t2239.52\t240.94\t4149.05 202503\t3\t5\t4\t12\t1891.44\t1781.15\t2191.78\t5864.37 202504\t1\t5\t2\t8\t855.94\t2641.75\t1274.36\t4772.05 202505\t5\t2\tnull\t7\t2231.2\t458.68\tnull\t2689.88 All months\t14\t15\t9\t38\t6647.17\t7121.1\t4841.44\t18609.71 All countries\t202501\t5\t4\t11\t20\t2693.58\t1845.01\t6275.11\t10813.7 202502\t10\t9\t7\t26\t4787.66\t5208.46\t2659.25\t12655.37 202503\t7\t13\t12\t32\t4714.98\t6596.16\t7336.14\t18647.28 202504\t7\t10\t4\t21\t4171.99\t4990.68\t2316.78\t11479.45 202505\t5\t6\t1\t12\t2231.2\t3278.37\t725.8\t6235.37 All months\t34\t42\t35\t111\t18599.41\t21918.68\t19313.08\t59831.17","keywords":"","version":"Next"},{"title":"rekalogika/rekapager","type":0,"sectionRef":"#","url":"/rekapager","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"rekalogika/rekapager","url":"/rekapager#sections","content":" üìÑÔ∏è Introduction Rekapager is a pagination library for PHP, supporting both offset-based and üìÑÔ∏è Installation and Usage Installation checklist: üóÉÔ∏è Adapters 6 items üìÑÔ∏è Pageables and Pages A PageableInterface represents a collection that can be üìÑÔ∏è Pager and PagerItem A PagerInterface represents navigation through a collection of items. A view üóÉÔ∏è Framework Integration 4 items üóÉÔ∏è Batch Processing 2 items üìÑÔ∏è Keyset Seek Method If more than one column is involved in the sorting, there are two ways to üìÑÔ∏è Known Issues and Limitations Selectable Bug in Counting matching() Results üìÑÔ∏è Troubleshooting Common issues and how to solve them. ","version":"Next","tagName":"h2"},{"title":"Adapters","type":0,"sectionRef":"#","url":"/rekapager/adapters","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"Adapters","url":"/rekapager/adapters#sections","content":" üìÑÔ∏è Doctrine ORM QueryBuilder QueryBuilderAdapter takes a Doctrine ORM QueryBuilder instance. It supports üìÑÔ∏è Doctrine ORM NativeQuery NativeQueryAdapter allows you to use Doctrine's native SQL functionality. It üìÑÔ∏è Doctrine Collections Selectable Takes a Doctrine Selectable instance, including Doctrine repository and üìÑÔ∏è Doctrine Collections Collection The CollectionAdapter supports only offset pagination. The class works with a üìÑÔ∏è Doctrine DBAL QueryBuilder QueryBuilderAdapter takes a Doctrine DBAL QueryBuilder instance. It supports üìÑÔ∏è Pagerfanta Adapter Allows leveraging any of the existing Pagerfanta adapters. The ","version":"Next","tagName":"h2"},{"title":"Doctrine Collections Collection","type":0,"sectionRef":"#","url":"/rekapager/adapters/doctrine-collections-collection","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Doctrine Collections Collection","url":"/rekapager/adapters/doctrine-collections-collection#installation","content":" composer require rekalogika/rekapager-doctrine-collections-adapter   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Doctrine Collections Collection","url":"/rekapager/adapters/doctrine-collections-collection#usage","content":" use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\Rekapager\\Doctrine\\Collections\\CollectionAdapter; use Rekalogika\\Rekapager\\Offset\\OffsetPageable; /** @var Collection $collection */ $collection = $user-&gt;getComments(); // a Doctrine Collection in an entity $adapter = new CollectionAdapter($collection); $pageable = new OffsetPageable($adapter);  ","version":"Next","tagName":"h2"},{"title":"Usage","type":0,"sectionRef":"#","url":"/reconstitutor/usage","content":"","keywords":"","version":"Next"},{"title":"Reconstitution of a Class‚Äã","type":1,"pageTitle":"Usage","url":"/reconstitutor/usage#reconstitution-of-a-class","content":" This will apply to objects that are instances of a specific class, subclasses of a specific class, or implement a specific interface.  Suppose you have an Order object that stores a payment receipt in thepaymentReceipt property:  use Symfony\\Component\\HttpFoundation\\File\\File; use Symfony\\Component\\Uid\\UuidV7; class Order { private string $id; private ?File $paymentReceipt = null; public function __construct() { $this-&gt;id = new UuidV7; } public function getId(): string { return $this-&gt;id; } public function getPaymentReceipt(): ?File { return $this-&gt;paymentReceipt; } public function setPaymentReceipt(File $paymentReceipt): void { $this-&gt;paymentReceipt = $paymentReceipt; } }   note In the above class, Doctrine related attributes are omitted for brevity.  During the fetching of the object from the database, Doctrine will instantiate the object and hydrate $id and other properties that it manages. Afterward, it will be our reconstitutor's turn to handle the $paymentReceipt property. Similar things also happen when the object is persisted to the database, or removed.  use Rekalogika\\Reconstitutor\\AbstractClassReconstitutor; use Symfony\\Component\\HttpFoundation\\File\\File; use Symfony\\Component\\HttpFoundation\\File\\UploadedFile; /** * @extends AbstractClassReconstitutor&lt;Order&gt; */ final class OrderReconstitutor extends AbstractClassReconstitutor { /** * The class that this reconstitutor manages. It can also be a super class * or an interface. */ public static function getClass(): string { return Order::class; } /** * When the object is being saved, we check if the paymentReceipt has been * just uploaded. If it is, we save it to a file. * * Note: in Symfony, an uploaded file is represented by an instance of * `UploadedFile`, otherwise it will be a `File` object. */ public function onSave(object $order): void { $path = sprintf('/tmp/payment_receipt/%s', $order-&gt;getId()); $file = $this-&gt;get($order, 'paymentReceipt'); if ($file instanceof UploadedFile) { file_put_contents($path, $file-&gt;getContent()); $this-&gt;set($order, 'paymentReceipt', new File($path)); } } /** * When the object is being loaded from the database, we check if the * supposed payment receipt is already saved. If it is, then we load the * file to the property. */ public function onLoad(object $order): void { $path = sprintf('/tmp/payment_receipt/%s', $order-&gt;getId()); if (file_exists($path)) { $file = new File($path); } else { $file = null; } $this-&gt;set($order, 'paymentReceipt', $file); } /** * If the order is being removed, we remove the associated payment receipt * here. */ public function onRemove(object $order): void { $path = sprintf('/tmp/payment_receipt/%s', $order-&gt;getId()); if (file_exists($path)) { unlink($path); } } }   ","version":"Next","tagName":"h2"},{"title":"Reconstitution of Classes With a Specific PHP Attribute‚Äã","type":1,"pageTitle":"Usage","url":"/reconstitutor/usage#reconstitution-of-classes-with-a-specific-php-attribute","content":" Alternatively, you can also target classes with a specific PHP attribute. The following modifies above example to use an attribute for targeting.  The entity class:  use Symfony\\Component\\HttpFoundation\\File\\File; use Symfony\\Component\\Uid\\UuidV7; #[MyAttribute] class Order { // ... }   And the reconstitutor class:  use Rekalogika\\Reconstitutor\\AbstractAttributeReconstitutor; use Symfony\\Component\\HttpFoundation\\File\\File; final class OrderReconstitutor extends AbstractAttributeReconstitutor { /** * If the object has this attribute, then we are going to handle it. */ public static function getAttributeClass(): string { return MyAttribute::class; } public function onSave(object $order): void { // ... } public function onLoad(object $order): void { // ... } public function onRemove(object $order): void { // ... } }   ","version":"Next","tagName":"h2"},{"title":"get() and set() Helpers‚Äã","type":1,"pageTitle":"Usage","url":"/reconstitutor/usage#get-and-set-helpers","content":" In reconstitution, you should get and set the object's properties directly, bypassing the getters and setters, just like what Doctrine does. To help you with that, the abstract classes provide the get() and set() helpers.  These are just forwarders to our custom implementation of the familiar Symfony PropertyAccess (see rekalogika/direct-property-accessfor more information). Therefore, you can catch the same exceptions as you would when using the original Symfony PropertyAccess.  ","version":"Next","tagName":"h2"},{"title":"Caveat: Avoid Query::toIterable‚Äã","type":1,"pageTitle":"Usage","url":"/reconstitutor/usage#caveat-avoid-querytoiterable","content":" Doctrine's documentation recommends usingQuery::toIterable()to iterate over large result sets. However, with Query::toIterable(), during the postLoad event, and in turn, when your onSave() method is called, the state of the entity is not guaranteed to be consistentas when loading the entity normally.  We recommend using our rekalogika/rekapager package instead. Read more in ourbatch processing documentation. ","version":"Next","tagName":"h2"},{"title":"Doctrine Collections Selectable","type":0,"sectionRef":"#","url":"/rekapager/adapters/doctrine-collection-selectable","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Doctrine Collections Selectable","url":"/rekapager/adapters/doctrine-collection-selectable#installation","content":" composer require rekalogika/rekapager-doctrine-collections-adapter   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Doctrine Collections Selectable","url":"/rekapager/adapters/doctrine-collection-selectable#usage","content":" use Doctrine\\Common\\Collections\\Criteria; use Doctrine\\ORM\\EntityRepository; use Rekalogika\\Rekapager\\Doctrine\\Collections\\SelectableAdapter; use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; use Rekalogika\\Rekapager\\Offset\\OffsetPageable; /** @var EntityRepository $postRepository */ $selectable = $postRepository; // a Doctrine repository is also a Selectable // or $selectable = $user-&gt;getComments(); // a Doctrine Collection in an entity $criteria = Criteria::create() -&gt;where(Criteria::expr()-&gt;eq('group', $group)) -&gt;orderBy([ 'date' =&gt; Order::Descending, 'title' =&gt; Order::Ascending, 'id' =&gt; Order::Ascending ]); $adapter = new SelectableAdapter( collection: $selectable, criteria: $criteria, indexBy: 'id' // optional ); $pageable = new KeysetPageable($adapter); // or $pageable = new OffsetPageable($adapter);   ","version":"Next","tagName":"h2"},{"title":"indexBy Parameter‚Äã","type":1,"pageTitle":"Doctrine Collections Selectable","url":"/rekapager/adapters/doctrine-collection-selectable#indexby-parameter","content":" There is a Doctrine bug that may prevents a matching() call from preserving the keys of the collection. To workaround this issue, add the indexByparameter to the adapter like the example above. ","version":"Next","tagName":"h3"},{"title":"Doctrine DBAL QueryBuilder","type":0,"sectionRef":"#","url":"/rekapager/adapters/doctrine-dbal-querybuilder","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Doctrine DBAL QueryBuilder","url":"/rekapager/adapters/doctrine-dbal-querybuilder#installation","content":" composer require rekalogika/rekapager-doctrine-dbal-adapter   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Doctrine DBAL QueryBuilder","url":"/rekapager/adapters/doctrine-dbal-querybuilder#usage","content":" use Doctrine\\DBAL\\Connection; use Rekalogika\\Rekapager\\Doctrine\\DBAL\\QueryBuilderAdapter; use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; use Rekalogika\\Rekapager\\Offset\\OffsetPageable; /** @var Connection $connection */ $queryBuilder = $connection -&gt;createQueryBuilder() -&gt;select('p.id', 'p.date', 'p.title', 'p.content') -&gt;from('post', 'p') -&gt;where('p.set_name = :setName') -&gt;setParameter('setName', $setName); $adapter = new QueryBuilderAdapter( queryBuilder: $queryBuilder, orderBy: [ 'p.date' =&gt; Order::Descending, 'p.title' =&gt; Order::Ascending, 'p.id' =&gt; Order::Ascending, ], indexBy: 'id' ); $pageable = new KeysetPageable($adapter); // or $pageable = new OffsetPageable($adapter);  ","version":"Next","tagName":"h2"},{"title":"Batch Processing","type":0,"sectionRef":"#","url":"/rekapager/batch-processing","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"Batch Processing","url":"/rekapager/batch-processing#sections","content":" üìÑÔ∏è Using Pageable for Batch Processing Any PageableInterface objects can be used to iterate its underlying data page üìÑÔ∏è Simple Batch Command Create a console command for processing batch jobs. ","version":"Next","tagName":"h2"},{"title":"Doctrine ORM NativeQuery","type":0,"sectionRef":"#","url":"/rekapager/adapters/doctrine-orm-nativequery","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Doctrine ORM NativeQuery","url":"/rekapager/adapters/doctrine-orm-nativequery#installation","content":" composer require rekalogika/rekapager-doctrine-orm-adapter   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Doctrine ORM NativeQuery","url":"/rekapager/adapters/doctrine-orm-nativequery#usage","content":" use Doctrine\\Common\\Collections\\Order; use Doctrine\\ORM\\EntityManagerInterface; use Doctrine\\ORM\\Query\\ResultSetMappingBuilder; use Rekalogika\\Rekapager\\Doctrine\\ORM\\NativeQueryAdapter; use Rekalogika\\Rekapager\\Doctrine\\ORM\\Parameter; use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; /** @var EntityManagerInterface $entityManager */ $resultSetMapping = new ResultSetMappingBuilder($entityManager); $resultSetMapping-&gt;addRootEntityFromClassMetadata(Post::class, 'p'); $sql = &quot; SELECT {$resultSetMapping}, {{SELECT}} FROM post p WHERE p.group = :group {{WHERE}} ORDER BY {{ORDER}} LIMIT {{LIMIT}} OFFSET {{OFFSET}} &quot;; $countSql = &quot; SELECT COUNT(*) AS count FROM ( SELECT * FROM post p WHERE p.group = :group {{WHERE}} ORDER BY {{ORDER}} LIMIT {{LIMIT}} OFFSET {{OFFSET}} ) &quot;; $countAllSql = &quot; SELECT COUNT(*) AS count FROM post p WHERE p.set_name = :setName &quot;; $adapter = new NativeQueryAdapter( entityManager: $this-&gt;entityManager, // The ResultSetMapping or ResultSetMappingBuilder instance resultSetMapping: $resultSetMapping, // The SQL query, must contain placeholders for {{SELECT}}, {{WHERE}}, // {{ORDER}}, {{LIMIT}}, and {{OFFSET}} sql: $sql, // The SQL query for counting records, must contain placeholders for // {{WHERE}}, {{ORDER}}, {{LIMIT}}, and {{OFFSET}}. The count field must // be using the alias 'count'. Optional. If null, the adapter will use $sql // encased in a subquery. countSql: $countSql, // The SQL query for counting all records. Optional. If null, the total will // not be available. countAllSql: $countAllSql, // The ordering must be provided here, not directly in the SQL query. orderBy: [ 'p.date' =&gt; Order::Descending, 'p.title' =&gt; Order::Ascending, 'p.id' =&gt; Order::Ascending, ], // The parameters for the query. parameters: [ new Parameter('group', 'some group'), ], // The property of the result that will be used as the index. Optional. indexBy: 'id', ); $pageable = new KeysetPageable($adapter);  ","version":"Next","tagName":"h2"},{"title":"Pagerfanta Adapter","type":0,"sectionRef":"#","url":"/rekapager/adapters/pagerfanta-adapter","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Pagerfanta Adapter","url":"/rekapager/adapters/pagerfanta-adapter#installation","content":" composer require rekalogika/rekapager-pagerfanta-adapter   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Pagerfanta Adapter","url":"/rekapager/adapters/pagerfanta-adapter#usage","content":" use Pagerfanta\\Doctrine\\Collections\\SelectableAdapter; use Rekalogika\\Rekapager\\Offset\\OffsetPageable; use Rekalogika\\Rekapager\\Pagerfanta\\PagerfantaAdapterAdapter; $criteria = Criteria::create() -&gt;where(Criteria::expr()-&gt;eq('group', $group)); $pagerfantaAdapter = new SelectableAdapter($user-&gt;getPosts(), $criteria); $adapter = new PagerfantaAdapterAdapter($pagerfantaAdapter); $pageable = new OffsetPageable($adapter);   info If you already have a Pagerfanta instance, you can use PagerfantaPageableinstead. ","version":"Next","tagName":"h2"},{"title":"Simple Batch Command","type":0,"sectionRef":"#","url":"/rekapager/batch-processing/batch-command","content":"","keywords":"","version":"Next"},{"title":"Requirements‚Äã","type":1,"pageTitle":"Simple Batch Command","url":"/rekapager/batch-processing/batch-command#requirements","content":" This feature uses Symfony Console. Therefore, you need the Symfony integrationor API Platform integration, or both.  ","version":"Next","tagName":"h2"},{"title":"Features‚Äã","type":1,"pageTitle":"Simple Batch Command","url":"/rekapager/batch-processing/batch-command#features","content":" Easy to create. You provide the PageableInterface object, and the logic to process each item. The framework takes care of the rest.Informative UI. You get time elapsed and memory usage on each page, as well as statistics every 15 seconds.Resumable. The UI provides the information about page identifiers on every opportunity, and you can use the --resume or -r option to resume the process from the specified page identifier.Override the page size (the number of items on each batch) using the--page-size or -p command line option.Progress file. Specify the progress file using the --progress-file or -fcommand line option. The command will store the last page identifier to this file. The next invocation of the command will resume from this page.Time limit. Runs the batch up to the duration specified using the--time-limit or -t command line option.Signal handling. The command listens to the SIGINT signal (Ctrl+C) andSIGTERM. It will finish the current page before exiting, so your job will have a consistent state.  ","version":"Next","tagName":"h2"},{"title":"Quick Start‚Äã","type":1,"pageTitle":"Simple Batch Command","url":"/rekapager/batch-processing/batch-command#quick-start","content":" Creating a console command for processing batch jobs is as easy as:  use Doctrine\\ORM\\EntityManagerInterface; use Doctrine\\Common\\Collections\\Criteria; use Doctrine\\Common\\Collections\\Order; use Rekalogika\\Contracts\\Rekapager\\PageableInterface; use Rekalogika\\Rekapager\\Batch\\Event\\AfterPageEvent; use Rekalogika\\Rekapager\\Batch\\Event\\ItemEvent; use Rekalogika\\Rekapager\\Doctrine\\Collections\\SelectableAdapter; use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; use Rekalogika\\Rekapager\\Symfony\\Batch\\SimpleBatchCommand; use Symfony\\Component\\Console\\Attribute\\AsCommand; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Output\\OutputInterface; /** * @extends SimpleBatchCommand&lt;int,Post&gt; */ #[AsCommand( name: 'app:postbatch', description: 'Simple batch command for processing the Post entities' )] class AppSimpleBatchCommand extends SimpleBatchCommand { public function __construct( private readonly PostRepository $postRepository, private readonly EntityManagerInterface $entityManager, ) { parent::__construct(); } #[\\Override] protected function configure(): void { // set up the command arguments and options here, just like any other // Symfony console command } #[\\Override] protected function getPageable(): PageableInterface { // procure a pageable object here, you can get the input arguments or // options from $this-&gt;getInput() $adapter = new SelectableAdapter( selectable: $this-&gt;postRepository, criteria: Criteria::create()-&gt;orderBy(['id' =&gt; Order::Ascending]) ); return new KeysetPageable($adapter); } #[\\Override] public function processItem(ItemEvent $itemEvent): void { $item = $itemEvent-&gt;getItem(); // do something with $item here } #[\\Override] public function afterPage(AfterPageEvent $event): void { // do something after each page here $this-&gt;entityManager-&gt;flush(); // if required $this-&gt;entityManager-&gt;clear(); } }   The complete list of the hooks you can override:  beforeProcess() - called before processing the first page.beforePage() - called before processing each page.processItem() - called for each item.afterPage() - called after processing each page.afterProcess() - called after processing the last page.onInterrupt() - called when the command is interrupted by the user, like when the user presses Ctrl+C.onTimeLimit() - called when the time limit is reached. ","version":"Next","tagName":"h2"},{"title":"Using Pageable for Batch Processing","type":0,"sectionRef":"#","url":"/rekapager/batch-processing/pageable","content":"","keywords":"","version":"Next"},{"title":"Prerequisites‚Äã","type":1,"pageTitle":"Using Pageable for Batch Processing","url":"/rekapager/batch-processing/pageable#prerequisites","content":" When using the library only for batch processing, you only need to install the adapters you need. Framework integration is not required.  ","version":"Next","tagName":"h2"},{"title":"Batch Processing‚Äã","type":1,"pageTitle":"Using Pageable for Batch Processing","url":"/rekapager/batch-processing/pageable#batch-processing","content":" To iterate over a large amount of data, you can use the following pattern:  use Doctrine\\ORM\\EntityManagerInterface; use Rekalogika\\Rekapager\\PageableInterface; /** @var PageableInterface $pageable */ /** @var EntityManagerInterface $entityManager */ foreach ($pageable-&gt;withItemsPerPage(1000)-&gt;getPages() as $page) { foreach ($page as $item) { // Do something with the item } // Do something after each page here // With Doctrine, you'd usually want to flush() and clear() here $entityManager-&gt;flush(); // if required $entityManager-&gt;clear(); }   ","version":"Next","tagName":"h2"},{"title":"Always Use Keyset Pagination‚Äã","type":1,"pageTitle":"Using Pageable for Batch Processing","url":"/rekapager/batch-processing/pageable#always-use-keyset-pagination","content":" While it is possible to use traditional offset pagination, you should always use keyset pagination for batch processing:  With offset pagination you risk missing items, or processing the same items multiple times, if the underlying data changes while you are processing it. Offset pagination will become slower and slower as you go further away from the first page.  ","version":"Next","tagName":"h2"},{"title":"Comparison to Query::toIterable()‚Äã","type":1,"pageTitle":"Using Pageable for Batch Processing","url":"/rekapager/batch-processing/pageable#comparison-to-querytoiterable","content":" Doctrine's documentation recommends usingQuery::toIterable()to iterate over large result sets. This, however, has several drawbacks:  Contrary to what one might expect, toIterable() actually runs the query only once, then loads the entire result into memory, which can be problematic for large result sets. It only saves us memory and time in the hydration phase, in the sense that it does not hydrate the result into entities all at once. Even when you don't care about memory usage, queries with large results will be much slower to execute. The application must wait for the query to finish, and depending on the application, it may affect interactivity and user experience. With toIterable(), during the postLoad event, the state of the entity isnot guaranteed to be consistentas when loading the entity normally. So, if you have postLoad listener on your entities, your entities might not behave the same way as when you load them normally.  Using PageableInterface for batch processing should solve these issues.  ","version":"Next","tagName":"h2"},{"title":"Running the Batch Process‚Äã","type":1,"pageTitle":"Using Pageable for Batch Processing","url":"/rekapager/batch-processing/pageable#running-the-batch-process","content":" The most common way to run a batch process is to create a console command. Read the Simple Batch Command documentation for more information. ","version":"Next","tagName":"h2"},{"title":"Framework Integration","type":0,"sectionRef":"#","url":"/rekapager/framework-integration","content":"","keywords":"","version":"Next"},{"title":"Sections‚Äã","type":1,"pageTitle":"Framework Integration","url":"/rekapager/framework-integration#sections","content":" üìÑÔ∏è Symfony Integration Symfony integration is provided by the package rekalogika/rekapager-bundle. üìÑÔ∏è API Platform Integration API Platform integration is provided by the package üìÑÔ∏è Doctrine Collections Integration High-level integration with Doctrine Collections is provided by our üìÑÔ∏è Integrating Rekapager into a Framework This document explains what you need to do to integrate Rekapager into a ","version":"Next","tagName":"h2"},{"title":"Doctrine ORM QueryBuilder","type":0,"sectionRef":"#","url":"/rekapager/adapters/doctrine-orm-querybuilder","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Doctrine ORM QueryBuilder","url":"/rekapager/adapters/doctrine-orm-querybuilder#installation","content":" composer require rekalogika/rekapager-doctrine-orm-adapter   If you need SQL row values support, you need to register the necessary DQL function:  SymfonyManual Wiring If you are using Symfony, add the following to your configuration: config/packages/doctrine.yaml doctrine: orm: dql: string_functions: REKAPAGER_ROW_VALUES: Rekalogika\\Rekapager\\Doctrine\\ORM\\RowValuesFunction   ","version":"Next","tagName":"h2"},{"title":"Usage‚Äã","type":1,"pageTitle":"Doctrine ORM QueryBuilder","url":"/rekapager/adapters/doctrine-orm-querybuilder#usage","content":" use Doctrine\\DBAL\\LockMode; use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\EntityRepository; use Rekalogika\\Rekapager\\Doctrine\\ORM\\QueryBuilderAdapter; use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; use Rekalogika\\Rekapager\\Offset\\OffsetPageable; /** @var EntityRepository $postRepository */ $queryBuilder = $postRepository -&gt;createQueryBuilder('p') -&gt;where('p.group = :group') -&gt;setParameter('group', $group) -&gt;addOrderBy('p.date', 'DESC') // a date field that accepts DateTime -&gt;addOrderBy('p.title', 'ASC') -&gt;addOrderBy('p.id', 'ASC'); $adapter = new QueryBuilderAdapter( queryBuilder: $queryBuilder, lockMode: LockMode::PESSIMISTIC_WRITE, // optional typeMapping: [ 'p.date' =&gt; Types::DATE_MUTABLE // the type of the date field ], indexBy: 'id' // optional ); $pageable = new KeysetPageable($adapter); // or $pageable = new OffsetPageable($adapter);   info If you don't provide a type mapping, the adapter will try to look it up from Doctrine's class metadata. If it fails, it will use heuristics to detect the type for some common objects.  caution The QueryBuilderAdapter does not support QueryBuilder's indexBy (the third parameter of from(), or the second parameter of a repository'screateQueryBuilder()). If you need the feature, use the indexBy parameter ofQueryBuilderAdapter as the above example.  ","version":"Next","tagName":"h2"},{"title":"Notes‚Äã","type":1,"pageTitle":"Doctrine ORM QueryBuilder","url":"/rekapager/adapters/doctrine-orm-querybuilder#notes","content":" With keyset pagination, there are additional prerequisites:  The underlying QueryBuilder object must have a sort order. Be sure to callorderBy() or addOrderBy() on the query builder before passing it to the adapter.If a field in a sort order uses a non-scalar type, you should provide atypeMapping option. The adapter will use it in the setParameter() method of the QueryBuilder. The example above shows how to provide a type mapping for a date field.  ","version":"Next","tagName":"h2"},{"title":"Limitations‚Äã","type":1,"pageTitle":"Doctrine ORM QueryBuilder","url":"/rekapager/adapters/doctrine-orm-querybuilder#limitations","content":" One-to-many and many-to-many joins are not supported. Many-to-one joins are OK.  // supported because a post has only one author $queryBuilder -&gt;from(Post::class, 'p') -&gt;leftJoin('p.author', 'a') -&gt;select('p'); // not supported because a post has many comments $queryBuilder -&gt;from(Post::class, 'p') -&gt;leftJoin('p.comments', 'c') -&gt;select('p');   If you have an entity with a one-to-many relationship, you can usually omit the join and Doctrine will fetch the related entities lazily.  ","version":"Next","tagName":"h2"},{"title":"Transactions‚Äã","type":1,"pageTitle":"Doctrine ORM QueryBuilder","url":"/rekapager/adapters/doctrine-orm-querybuilder#transactions","content":" If you use the lockMode option, the adapter will pass the option to the resulting Query object. In a batch processing, this is how to wrap the processing of each page in a transaction:  use Doctrine\\DBAL\\LockMode; use Doctrine\\ORM\\EntityManagerInterface; use Doctrine\\ORM\\QueryBuilder; use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; use Rekalogika\\Rekapager\\Doctrine\\ORM\\QueryBuilderAdapter; /** @var EntityManagerInterface $entityManager */ /** @var QueryBuilder $queryBuilder */ $adapter = new QueryBuilderAdapter( queryBuilder: $queryBuilder, lockMode: LockMode::PESSIMISTIC_WRITE, ); /** @var PageableInterface&lt;int,Post&gt; */ $pageable = new KeysetPageable( adapter: $adapter, itemsPerPage: 10, ); // using explicit begin, commit and rollback foreach ($pageable-&gt;getPages() as $page) { $entityManager-&gt;beginTransaction(); try { foreach ($page as $post) { // do something with the post } } catch (\\Throwable $e) { $entityManager-&gt;rollback(); throw $e; } $entityManager-&gt;flush(); $entityManager-&gt;commit(); } // using wrap foreach ($pageable-&gt;getPages() as $page) { $entityManager-&gt;wrapInTransaction(function () use ($page) { foreach ($page as $post) { // do something with the post } }); }   info The above can work because PageInterface is lazy. The content of the page is fetched when you iterate over it, not when you iterate over getPages().  ","version":"Next","tagName":"h2"},{"title":"Overriding the Boundary Fields‚Äã","type":1,"pageTitle":"Doctrine ORM QueryBuilder","url":"/rekapager/adapters/doctrine-orm-querybuilder#overriding-the-boundary-fields","content":" By default, the adapter uses the fields in the ORDER BY clause as the boundary fields, and it should work in most cases. This is an example scenario that necessitates overriding the boundary fields.  Suppose you have this table:  CREATE TABLE post ( id INT PRIMARY KEY NOT NULL, category VARCHAR(255), title VARCHAR(255) ); CREATE INDEX post_category_id ON post (category, id);   To efficiently paginate over the posts of a specific category, you might want to use QueryBuilderAdapter like this:  use Doctrine\\ORM\\EntityRepository; use Rekalogika\\Rekapager\\Doctrine\\ORM\\QueryBuilderAdapter; use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; /** @var EntityRepository $postRepository */ $queryBuilder = $postRepository-&gt;createQueryBuilder('p'); if ($category === null) { $queryBuilder-&gt;where('p.category IS NULL'); } else { $queryBuilder-&gt;where('p.category = :category') -&gt;setParameter('category', $category); } // forces the database to use the same index for filtering and ordering: $queryBuilder -&gt;orderBy('p.category', 'ASC') -&gt;addOrderBy('p.id', 'ASC'); $adapter = new QueryBuilderAdapter( queryBuilder: $queryBuilder, boundaryFields: ['id'], ); $pageable = new KeysetPageable($adapter);   Without the boundaryFields argument, the adapter would use category and idas the boundary fields. And it would work correctly, unless you have posts with a NULL category, like in the above example. ","version":"Next","tagName":"h2"},{"title":"Integrating Rekapager into a Framework","type":0,"sectionRef":"#","url":"/rekapager/framework-integration/integrating","content":"","keywords":"","version":"Next"},{"title":"Dependencies‚Äã","type":1,"pageTitle":"Integrating Rekapager into a Framework","url":"/rekapager/framework-integration/integrating#dependencies","content":" The integration package should depend on:  rekalogika/rekapager-contractsrekalogika/rekapager-core  ","version":"Next","tagName":"h2"},{"title":"Implement PageIdentifierEncoderLocatorInterface‚Äã","type":1,"pageTitle":"Integrating Rekapager into a Framework","url":"/rekapager/framework-integration/integrating#implement-pageidentifierencoderlocatorinterface","content":" It takes the class name of a page identifier object, and returns an instance ofPageIdentifierEncoderInterface that will be used to encode and decode the page identifier.  Rekapager ships with two pageable types: KeysetPageable and OffsetPageable(PagerfantaPageable is a wrapper around OffsetPageable, so it doesn't apply here). The packages already have the encoders, all you need to do is to wire their dependencies, and implement the locator.  ","version":"Next","tagName":"h2"},{"title":"Wire PageIdentifierEncoderResolver‚Äã","type":1,"pageTitle":"Integrating Rekapager into a Framework","url":"/rekapager/framework-integration/integrating#wire-pageidentifierencoderresolver","content":" The class is ready to use. It takes the PageIdentifierEncoderLocatorInterfaceas its argument.  ","version":"Next","tagName":"h2"},{"title":"Implement PageUrlGeneratorInterface‚Äã","type":1,"pageTitle":"Integrating Rekapager into a Framework","url":"/rekapager/framework-integration/integrating#implement-pageurlgeneratorinterface","content":" It takes a page identifier already converted into a string, and returns a URL containing the string.  ","version":"Next","tagName":"h2"},{"title":"Create a Pager Factory‚Äã","type":1,"pageTitle":"Integrating Rekapager into a Framework","url":"/rekapager/framework-integration/integrating#create-a-pager-factory","content":" This factory should do the following:  Take a PageableInterface object from the caller.Determine the page identifier string from the URL. If not found, use the first page as the current page.Transform the string into a page identifier object usingPageIdentifierEncoderResolver.Call getPageByIdentifier($pageIdentifier) on the pageable object to get the current page.Instantiate Pager, and return it.  ","version":"Next","tagName":"h2"},{"title":"Create a Pager Renderer (optional)‚Äã","type":1,"pageTitle":"Integrating Rekapager into a Framework","url":"/rekapager/framework-integration/integrating#create-a-pager-renderer-optional","content":" This class should take a PagerInterface object, and render the pagination control in the user interface, which is probably the final result that most people are looking for. ","version":"Next","tagName":"h2"},{"title":"API Platform Integration","type":0,"sectionRef":"#","url":"/rekapager/framework-integration/api-platform","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"API Platform Integration","url":"/rekapager/framework-integration/api-platform#installation","content":" Preinstallation checklists:  Make sure Composer is installed globally, as explained in the installation chapter of the Composer documentation. Run composer about to verify.Make sure your project has Symfony Flex installed and enabled (it is enabled by default). Run composer why symfony/flex to verify.  Open a command console, enter your project directory, and execute:  composer require rekalogika/rekapager-api-platform   ","version":"Next","tagName":"h2"},{"title":"API Changes‚Äã","type":1,"pageTitle":"API Platform Integration","url":"/rekapager/framework-integration/api-platform#api-changes","content":" This package aims to implement keyset pagination by changing the type of the existing 'page' query parameter from integer to string.   { &quot;@context&quot;: &quot;/api/contexts/Post&quot;, &quot;@id&quot;: &quot;/api/posts&quot;, &quot;@type&quot;: &quot;hydra:Collection&quot;, &quot;hydra:member&quot;: [ ... ], &quot;hydra:view&quot;: { &quot;@type&quot;: &quot;hydra:PartialCollectionView&quot;, &quot;@id&quot;: &quot;/api/posts&quot;, - &quot;hydra:last&quot;: &quot;/api/posts?page=21&quot;, - &quot;hydra:next&quot;: &quot;/api/posts?page=2&quot; + &quot;hydra:last&quot;: &quot;/api/posts?page=q1YqU7KKjtVRKlCy0jXUUcpRssorzcnRUcpXsjLQUSpRslIqVaoFAA&quot;, + &quot;hydra:next&quot;: &quot;/api/posts?page=q1YqU7KqVsrXy0xRsjI2qNVRKlCyMtJRylGyyivNydFRyleyMtBRKlGyAgrVAgA&quot; } }   The change should be transparent to the consumers of the API, and does not require any changes, as long as they traverse the set by using the URIs as they are returned by the API.  However, if the consumer currently increments the page number manually on their side, they need to change how they go to the next page by using the URI provided by the API (hydra:next) instead. Clients that still use the integer page number (after switching to keyset pagination) will get a 400 Bad Request response.  The change is opt-in and can be enabled per operation or globally. You will be able to keep the standard API Platform pagination system, then make sure all the consumers conform to the required behavior, and enable it only after everyone is ready.  note The parameter page=1 is special and will not cause a 400 error response. It will be treated as a request for the first page.  Not using JSON-LD? If your API does not use JSON-LD, your consumer can get the related URIs using the Link header. Example: Link: &lt;/api/posts?page=q1YqU7KqVsrXy0xRsjI2qNVRKlCyMtJRylGyyivNydFRyleyMtBRKlGyAgrVAgA&gt;; rel=&quot;next&quot;, &lt;/api/posts?page=q1YqU7KKjtVRKlCy0jXUUcpRssorzcnRUcpXsjLQUSpRslIqVaoFAA&gt;; rel=&quot;last&quot;, &lt;http://127.0.0.1:8000/api/docs.jsonld&gt;; rel=&quot;http://www.w3.org/ns/hydra/core#apiDocumentation&quot;   ","version":"Next","tagName":"h2"},{"title":"Provided Components‚Äã","type":1,"pageTitle":"API Platform Integration","url":"/rekapager/framework-integration/api-platform#provided-components","content":" A decorator for OpenApiFactoryInterface that changes the type of every 'page' query parameter from integer to string. It should still be compatible with API Platform's standard pagination system.PagerNormalizer: a normalizer for PagerInterface.RekapagerExtension: an extension for API Platform's Doctrine ORM integration to use Rekapager.PagerFactory: creates a PagerInterface object from a PageableInterface, the current operation, and the context. Useful in a state provider or processor.RekapagerLinkProcessor: add the links to the Link HTTP header.  ","version":"Next","tagName":"h2"},{"title":"Usage in a State Provider or Processor‚Äã","type":1,"pageTitle":"API Platform Integration","url":"/rekapager/framework-integration/api-platform#usage-in-a-state-provider-or-processor","content":" In a state provider, you can use PagerFactoryInterface to transform anyPageableInterface into a PagerInterface. Then, you can simply return the pager instance and our PagerNormalizer will output it correctly.  use ApiPlatform\\Metadata\\Operation; use ApiPlatform\\State\\ProviderInterface; use Rekalogika\\Rekapager\\ApiPlatform\\PagerFactoryInterface; use Rekalogika\\Rekapager\\Doctrine\\Collections\\SelectableAdapter; use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; /** * @implements ProviderInterface&lt;Post&gt; */ class PostProvider implements ProviderInterface { public function __construct( private PagerFactoryInterface $pagerFactory, ) { } public function provide( Operation $operation, array $uriVariables = [], array $context = [] ): object|array|null { $pageable = ...; // Get or create a PageableInterface object here $pager = $this-&gt;pagerFactory-&gt;createPager($pageable, $operation, $context); return $pager; } }   PagerFactory should respect these standard API Platform settings in the operation, as well as their corresponding global settings.  paginationItemsPerPage: the number of items per page.paginationClientEnabled: whether to enable the pagination settings from the client.paginationClientItemsPerPage: the number of items per page that the client requested.paginationMaximumItemsPerPage  ","version":"Next","tagName":"h2"},{"title":"Doctrine ORM Support‚Äã","type":1,"pageTitle":"API Platform Integration","url":"/rekapager/framework-integration/api-platform#doctrine-orm-support","content":" This package supports the pagination for API Platform's Doctrine ORM integration as an alternative to the default pagination. Its usage is opt-in. You can enable it per operation using the rekapager_orm_enabled extra property:  #[ApiResource( extraProperties: [ 'rekapager_orm_enabled' =&gt; true ] )] class Post { // ... }   To enable it globally, you can set it in the configuration:  config/packages/api_platform.yaml api_platform: defaults: extra_properties: rekapager_orm_enabled: true  ","version":"Next","tagName":"h2"},{"title":"Doctrine Collections Integration","type":0,"sectionRef":"#","url":"/rekapager/framework-integration/doctrine","content":"","keywords":"","version":"Next"},{"title":"Transforms a Collection into a Collection + Pageable‚Äã","type":1,"pageTitle":"Doctrine Collections Integration","url":"/rekapager/framework-integration/doctrine#transforms-a-collection-into-a-collection--pageable","content":" Use the RecollectionDecorator class to add PageableInterface functionality to a Doctrine Collection.  use Doctrine\\Common\\Collections\\Collection; use Rekalogika\\Contracts\\Collections\\Recollection; use Rekalogika\\Domain\\Collections\\RecollectionDecorator; /** @var Collection $someCollection */ $improvedCollection = RecollectionDecorator::create($someCollection);   In the example above, $improvedCollection is now a Recollection object which is still a Collection but also a PageableInterface at the same time.  ","version":"Next","tagName":"h2"},{"title":"A Better ->matching()‚Äã","type":1,"pageTitle":"Doctrine Collections Integration","url":"/rekapager/framework-integration/doctrine#a-better--matching","content":" Rather than doing this:  use Doctrine\\Common\\Collections\\Collection; use Doctrine\\Common\\Collections\\Criteria; /** @var Collection $collection */ $criteria = Criteria::create()-&gt;where(...); $filteredCollection = $collection-&gt;matching($criteria);   You can do this:  use Doctrine\\Common\\Collections\\Collection; use Doctrine\\Common\\Collections\\Criteria; use Rekalogika\\Domain\\Collections\\CriteriaRecollection; /** @var Collection $collection */ $criteria = Criteria::create()-&gt;where(...); $filteredCollection = CriteriaRecollection::create($collection, $criteria);   The upside of the latter is that the result is lazy-loaded and implements bothReadableCollection and PageableInterface.  ","version":"Next","tagName":"h2"},{"title":"Transforms a QueryBuilder into a Collection + Pageable‚Äã","type":1,"pageTitle":"Doctrine Collections Integration","url":"/rekapager/framework-integration/doctrine#transforms-a-querybuilder-into-a-collection--pageable","content":" use Rekalogika\\Collections\\ORM\\QueryRecollection; $queryBuilder = ... // create a QueryBuilder instance $collection = new QueryRecollection( queryBuilder: $queryBuilder, indexBy: 'id' );   In the example above, $collection is now a Recollection object which is aCollection and a PageableInterface at the same time.  ","version":"Next","tagName":"h2"},{"title":"There are More‚Äã","type":1,"pageTitle":"Doctrine Collections Integration","url":"/rekapager/framework-integration/doctrine#there-are-more","content":" Our rekalogika/collections-* packages are more than just aboutPageableInterface. Check out the rekalogika/collectionsdocumentation for more information. ","version":"Next","tagName":"h2"},{"title":"Known Issues and Limitations","type":0,"sectionRef":"#","url":"/rekapager/known-issues","content":"","keywords":"","version":"Next"},{"title":"Selectable Bug in Counting matching() Results‚Äã","type":1,"pageTitle":"Known Issues and Limitations","url":"/rekapager/known-issues#selectable-bug-in-counting-matching-results","content":" There is a Doctrine bug involving -&gt;matching($criteria)-&gt;count(). If the Criteria has a maxResults, then it will be disregarded and the count() will return the total number of items as if the maxResults were not set.  issue #9951issue #10766PR #10767  We work around this bug by fetching the items and counting them manually. This is suboptimal, but it works. If performance is critical, use a small proximity and a small page size. Or, use QueryBuilderAdapter instead.  ","version":"Next","tagName":"h2"},{"title":"Underlying QueryBuilder or Criteria With setFirstResult() and setMaxResults()‚Äã","type":1,"pageTitle":"Known Issues and Limitations","url":"/rekapager/known-issues#underlying-querybuilder-or-criteria-with-setfirstresult-and-setmaxresults","content":" QueryBuilderAdapter and SelectableAdapter currently do not support underlying QueryBuilder or Criteria with setFirstResult() andsetMaxResults(). If the underlying object has any these set, then the adapter will throw an exception.  ","version":"Next","tagName":"h2"},{"title":"SelectableAdapter does not Preserve Keys/Indexes‚Äã","type":1,"pageTitle":"Known Issues and Limitations","url":"/rekapager/known-issues#selectableadapter-does-not-preserve-keysindexes","content":" The problem is caused by this Doctrine bug:  issue #4693  Workaround: use indexBy parameter of the adapter. Example:  $adapter = new SelectableAdapter( collection: $collection, criteria: $criteria, indexBy: 'id', );  ","version":"Next","tagName":"h2"},{"title":"Pager and PagerItem","type":0,"sectionRef":"#","url":"/rekapager/pager-pageritem","content":"Pager and PagerItem A PagerInterface represents navigation through a collection of items. A view layer can use it to render a pagination control. A pager works at a higher level than a PageableInterface. It needs to be able to determine the current page from the context of the request, and to be able to generate URLs for each page. A framework integration will give you a way to transform a PageableInterface object into a PagerInterface object. Currently, we provide integration forSymfony and API Platform. Check out these pages to see how to transform a PageableInterface object into a PagerInterface in the framework you are using. A pager has many pager items. A pager item is an extended page object that contains a URL.","keywords":"","version":"Next"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/rekapager/intro","content":"","keywords":"","version":"Next"},{"title":"Demo‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#demo","content":" You can try the demo by running the following command:  docker run --rm -p 8187:80 ghcr.io/rekalogika/rekapager:latest   Then access the demo at http://localhost:8187.  ","version":"Next","tagName":"h2"},{"title":"Keyset Pagination (or Cursor-Based Pagination)‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#keyset-pagination-or-cursor-based-pagination","content":" Keyset pagination is a method of pagination that uses the last row of the current page as an anchor for the next page. This method has these advantages compared to the traditional offset-based pagination:  It is more efficient because it leverages the index. It does not require the database to scan all rows from the beginning to reach the desired page.It is more resilient to data changes, as the data will not drift when rows are inserted or deleted.  ","version":"Next","tagName":"h2"},{"title":"Identifying Pages‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#identifying-pages","content":" Instead of using page numbers, a page identifier object is used to reference a page. This identifier is encoded into a string and passed as a single query parameter.  Because it requires only a single query parameter, it works similarly on the surface with offset pagination. Migrating from offset pagination to keyset pagination will be straightforward. The difference is that instead of having page numbers in the URL, we'll be getting an 'ugly' identifier, which is opaque to the user, but meaningful to the application.  It also easily allows us to keep the pagination job separate from the filtering and sorting logic. The library does not require you to use a specific way to filter or sort your data.  ","version":"Next","tagName":"h3"},{"title":"Queries‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#queries","content":" Multiple sort columns are supported. The library will automatically generate the WHERE query for you, including the complex cases involving more than two sort columns. The only requirement is that the query needs to have a deterministic sort order.  Some backends also have the option to use SQL row values syntax for a slightly better performance.  ","version":"Next","tagName":"h3"},{"title":"Bidirectional Navigation and Page Skipping‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#bidirectional-navigation-and-page-skipping","content":" Bidirectional navigation is supported. The user will be able to navigate forward and backward from the current page. It also supports offset seeking, allowing the user to skip the immediate next or previous page up to the configured proximity setting.  In the user interface, the pager will look like a regular pagination control:    The page number is informational only, and carried over from the start page.  ","version":"Next","tagName":"h3"},{"title":"Jumping to the Last Page‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#jumping-to-the-last-page","content":" Seeking to the last page is possible. And with keyset pagination, it will be as fast as seeking to the first page:    ","version":"Next","tagName":"h3"},{"title":"Page Numbers and Counting‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#page-numbers-and-counting","content":" Negative page numbers shown above indicate the page numbers from the end. The last page is -1, the second to last is -2, and so on. It is done this way because by default the pager does not fetch the total count from the underlying data, which is another common performance issue involving pagination.  The pager can work without knowing the total count, but if the count is available, the pager will use it:    It can query the count from the underlying data, or the caller can supply the count. The count can also be an approximation, and the pager will work without an exact count.  ","version":"Next","tagName":"h3"},{"title":"Offset Pagination‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#offset-pagination","content":" The library also supports the traditional offset pagination method with several important improvements.  ","version":"Next","tagName":"h2"},{"title":"No Counting by Default‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#no-counting-by-default","content":" It can paginate without the total count of the data. If the count is not known, the pager won't allow the user to navigate to the last page:    As with keyset pagination, the count can be supplied by the caller, or the pager can query the count from the underlying data.  ","version":"Next","tagName":"h3"},{"title":"Page Number Limit‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#page-number-limit","content":" It also limits the maximum page number that can be navigated to. By default, the limit is 100. The UI indicates the existence of the disabled page but prevents navigation to it:    This limit can be configured, or disabled entirely. But if you need the function to seek beyond a certain number of pages, you should consider switching to keyset pagination instead.  ","version":"Next","tagName":"h3"},{"title":"Pagerfanta Interoperability‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#pagerfanta-interoperability","content":" For interoperability, the library supports offset pagination using any of the existing Pagerfanta adapters, as well as adapting a Pagerfanta instance into anOffsetPageableInterface instance.  ","version":"Next","tagName":"h3"},{"title":"Same Interface for Both Offset and Keyset Pagination‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#same-interface-for-both-offset-and-keyset-pagination","content":" Both offset pagination and keyset pagination use the same interface. This allows you to keep using offset pagination and later switch to keyset pagination without too much effort.  ","version":"Next","tagName":"h3"},{"title":"Secure by Default (or Prevents AI Crawlers from Wreaking Havoc)‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#secure-by-default-or-prevents-ai-crawlers-from-wreaking-havoc","content":" With keyset pagination, not counting by default, and limiting pages in offset pagination, the library is secure by default. It prevents denials of service, either maliciously or accidentally. In most cases, a real user won't have a good reason for accessing page 56267264, but doing so can cause a denial of service to the web server, application, and the database.  After the AI craze, there is a surge of web crawlers that are looking for contents for AI training. Unlike traditional search engine crawlers, these new crawlers are often less sophisticated and less respectful. Some would foolishly traverse thousands of paginated contents with a sub-second delay, causing a denial of service to the server. If your application is public and uses pagination, this library can help to prevent this problem.  ","version":"Next","tagName":"h2"},{"title":"Supported Data Types‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#supported-data-types","content":" Doctrine Collections Selectable and CollectionDoctrine ORM QueryBuilder and NativeQueryDoctrine DBAL QueryBuilderPagerfanta adapters  ","version":"Next","tagName":"h2"},{"title":"Framework Integrations‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#framework-integrations","content":" SymfonyAPI Platform  ","version":"Next","tagName":"h2"},{"title":"Acknowledgements‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#acknowledgements","content":" Use the Index, LukePagerfantaPagerWavefast-doctrine-paginator  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"Introduction","url":"/rekapager/intro#contributing","content":" This framework consists of multiple repositories split from a monorepo. Be sure to submit issues and pull requests to therekalogika/rekapager monorepo. ","version":"Next","tagName":"h2"},{"title":"Pageables and Pages","type":0,"sectionRef":"#","url":"/rekapager/pageable-page","content":"","keywords":"","version":"Next"},{"title":"Pageable Implementations‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#pageable-implementations","content":" ","version":"Next","tagName":"h2"},{"title":"KeysetPageable‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#keysetpageable","content":" The KeysetPageable is a pageable that supports keyset pagination. It is available with the rekalogika/rekapager-keyset-pagination package.  It takes an implementation of KeysetPaginationAdapterInterface as its argument. The library currently provides two implementations:  SelectableAdapterQueryBuilderAdapter  ","version":"Next","tagName":"h3"},{"title":"OffsetPageable‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#offsetpageable","content":" The OffsetPageable is a pageable that supports offset pagination. It is available with the rekalogika/rekapager-offset-pagination package.  It takes an implementation of OffsetPaginationAdapterInterface as its argument. The library currently provides three implementations:  CollectionAdapterSelectableAdapterPagerfantaAdapterAdapter  PagerfantaAdapterAdapter allows the use of the existing Pagerfanta adapters.  ","version":"Next","tagName":"h3"},{"title":"PagerfantaPageable‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#pagerfantapageable","content":" Takes a Pagerfanta object and turns it into a PageableInterface. It is available with the rekalogika/rekapager-pagerfanta-adapter package.  ","version":"Next","tagName":"h3"},{"title":"Pageable Properties‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#pageable-properties","content":" All PageableInterface implementations should have the following properties.  ","version":"Next","tagName":"h2"},{"title":"Number of items per page‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#number-of-items-per-page","content":" In OffsetPageable &amp; KeysetPageable, the number of items per page is set in the constructor parameter $itemsPerPage, with the default value of 50. InPagerfantaPageable, it is taken from the underlying Pagerfanta object.  The value can be altered post-instantiation using the withItemsPerPage()wither method, or rather you get a new instance with a different number of items per page.  use Rekalogika\\Contracts\\Rekapager\\PageableInterface; /** @var PageableInterface $pageable */ $pageableWith10ItemsPerPage = $pageable-&gt;withItemsPerPage(10);   ","version":"Next","tagName":"h3"},{"title":"The count strategy‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#the-count-strategy","content":" There are three strategies for counting the total number of items: ignore (and assume the count is unknown), fetch the count from the underlying data, or supplied by the caller. By default, all implementations use 'ignore' because it is the safest option.  All pageables accepts the $count parameter in the constructor. The parameter accepts integer or bool. false means the count is unknown, true means the count is fetched from the underlying data, and an integer is the count value supplied by the caller.  ","version":"Next","tagName":"h3"},{"title":"Page limit‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#page-limit","content":" The maximum page number that can be navigated to. Beyond the limit, the page is disabled. By default, the limit is 100.  Only applicable to OffsetPageable and PagerfantaPageable. Does not make sense with KeysetPageable, so the option is not provided there.  ","version":"Next","tagName":"h3"},{"title":"Example Usage‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#example-usage","content":" use Rekalogika\\Contracts\\Rekapager\\PageableInterface; /** @var PageableInterface $pageable */ // Getting the first page $firstPage = $pageable-&gt;getFirstPage(); // Getting the last page. Some pageable does not support seeking to the last // page, and will return null. $lastPage = $pageable-&gt;getLastPage(); // Getting the second page, or the page after the first page $secondPage = $firstPage-&gt;getNextPage(); // Getting three pages after the first page $nextPages = $firstPage-&gt;getNextPages(3); // All pages are instances of PageInterface. // Every page has an identifier object, which we can use to get the page later. $pageIdentifier = $secondPage-&gt;getIdentifier(); // Getting a page by its identifier $alsoSecondPage = $pageable-&gt;getPageByIdentifier($pageIdentifier);   ","version":"Next","tagName":"h2"},{"title":"Page Identifiers‚Äã","type":1,"pageTitle":"Pageables and Pages","url":"/rekapager/pageable-page#page-identifiers","content":" Every page has an identifier object, that can be used to get the page later. The class of this identifier object is determined by the implementation of thePageableInterface. Keyset pagination uses the KeysetPageIdentifier class, while offset pagination uses the PageNumber class.  Each of these page identifier classes is accompanied by aPageIdentifierEncoderInterface which is used to encode and decode the identifier object from and to a string. This string is used as query string parameter in the URL.  The PageNumber object is encoded as a simple integer.  The rekapager/rekapager-keyset-pagination package ships with two encoders:  SerializeSecretKeysetPageIdentifierEncoder which uses PHP's serialize() andunserialize() functions. It is protected by checksums to prevent tampering.SymfonySerializerKeysetPageIdentifierEncoder which uses Symfony'sSerializer component to serialize and unserialize the object.  Our Symfony integration uses the latter encoder. ","version":"Next","tagName":"h2"},{"title":"Symfony Integration","type":0,"sectionRef":"#","url":"/rekapager/framework-integration/symfony","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/framework-integration/symfony#installation","content":" Preinstallation checklists:  Make sure Composer is installed globally, as explained in the installation chapter of the Composer documentation. Run composer about to verify.Make sure your project has Symfony Flex installed and enabled (it is enabled by default). Run composer why symfony/flex to verify.  Open a command console, enter your project directory, and execute:  composer require rekalogika/rekapager-bundle   ","version":"Next","tagName":"h2"},{"title":"Transforming a Pageable into a Pager‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/framework-integration/symfony#transforming-a-pageable-into-a-pager","content":" Before we can render a pagination control in the UI, we need to transform thePageableInterface into a PagerInterface object. To do that, wire thePagerFactoryInterface service, and use the createPager() method.  Example with a Symfony Controller:  use Rekalogika\\Rekapager\\Bundle\\Contracts\\PagerFactoryInterface; use Rekalogika\\Rekapager\\Bundle\\PagerOptions; use Symfony\\Component\\HttpFoundation\\Request; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; class MyController extends AbstractController { public function index( PagerFactoryInterface $pagerFactory, Request $request ): Response { $pageable = ...; // Get or create a PageableInterface object here $pager = $pagerFactory-&gt;createPager( pageable: $pageable, request: $request, options: new PagerOptions( proximity: 3, ) ); return $this-&gt;render('my_template.html.twig', [ 'pager' =&gt; $pager, ]); } }   Available options:  pageParameterName: The query string parameter name for the page number. The default is page.proximity: The number of pages to show before and after the current page. The default is 2.routeName: The route name to generate the URL. The default is the current route.routeParameters: The route parameters. The default is the current route parameters.urlReferenceType: The type of URL reference, seeUrlGeneratorInterface::generate() for more information. The default isUrlGeneratorInterface::ABSOLUTE_PATH.itemsPerPage: The number of items per page. The default is 50.pageLimit: The maximum number of pages to show in the pagination control. The default is the effective value in the pageable object.  ","version":"Next","tagName":"h2"},{"title":"Rendering the Pager‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/framework-integration/symfony#rendering-the-pager","content":" In Twig template, you can use the rekapager() function to render the pager.  {# Outputs the item from the current page #} &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Date&lt;/th&gt; &lt;th&gt;Content&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; {# Optionally enables infinite scrolling #} &lt;tbody {{ rekapager_infinite_scrolling_content() }}&gt; {% for post in pager.currentPage %} &lt;tr&gt; &lt;td&gt;{{ post.id }}&lt;/td&gt; &lt;td&gt;{{ post.title }}&lt;/td&gt; &lt;td&gt;{{ post.date|date('Y-m-d') }}&lt;/td&gt; &lt;td&gt;{{ post.content }}&lt;/td&gt; &lt;/tr&gt; {% endfor %} &lt;/tbody&gt; &lt;/table&gt; {# Render the pager #} {{ rekapager(pager, template=&quot;@RekalogikaRekapager/bootstrap5.html.twig&quot;) }}   Available options:  template: The template to use for rendering the pager. The default is@RekalogikaRekapager/default.html.twig.proximity: Override the number of pages to show before and after the current page.locale: Override the current locale for translations.  All options are optional.  tip Wants to see the pager in your language? Feel free to submit your translation.  List of currently available templates:  @RekalogikaRekapager/default.html.twig@RekalogikaRekapager/bootstrap5.html.twig  ","version":"Next","tagName":"h2"},{"title":"Infinite Scrolling‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/framework-integration/symfony#infinite-scrolling","content":" Because infinite scrolling is such a common feature in modern web applications, we provide a helper function to enable it. To enable infinite scrolling, simply add {{ rekapager_infinite_scrolling_content() }} to the element that contains the items; if you are using a table, it should be the tbody element.  Infinite scrolling will be activated if the width of the page is less than 768px (equivalent to Bootstrap's xs and sm breakpoints) when the page is first loaded. It will find the pagination element (.pagination), take note of the next page URL (from [rel=&quot;next&quot;]), and remove the pagination element.  When the user scrolls to the bottom of the page, it will fetch the next page, parse the document, get the new items, and appends them to the same element in the current page.  ","version":"Next","tagName":"h2"},{"title":"Default Options‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/framework-integration/symfony#default-options","content":" The global defaults can be set in the bundle configuration file.  config/packages/rekapager.yaml rekalogika_rekapager: default_template: '@RekalogikaRekapager/default.html.twig' default_page_parameter_name: page default_proximity: 2   ","version":"Next","tagName":"h2"},{"title":"Customizing Out of Bounds Behavior‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/framework-integration/symfony#customizing-out-of-bounds-behavior","content":" If the user navigates to a page beyond the last page, the pager will throwOutOfBoundsException, and Symfony will show a 404 error page by default.  The OutOfBoundsException class provided by the bundle is an extended class that contains information about the pager and the pager options. You can create a KernelEvents::EXCEPTION event listener to intercept the exception and customize the behavior.  ","version":"Next","tagName":"h2"},{"title":"Redirecting to the First Page‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/framework-integration/symfony#redirecting-to-the-first-page","content":" use Rekalogika\\Rekapager\\Bundle\\Exception\\OutOfBoundsException; use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener; use Symfony\\Component\\HttpFoundation\\RedirectResponse; use Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent; use Symfony\\Component\\HttpKernel\\KernelEvents; final readonly class RekapagerOutOfBoundsListener { #[AsEventListener(KernelEvents::EXCEPTION)] public function onKernelException( ExceptionEvent $event ): void { $exception = $event-&gt;getThrowable(); if (!$exception instanceof OutOfBoundsException) { return; } $url = $exception-&gt;getPager()-&gt;getFirstPage()-&gt;getUrl(); $response = new RedirectResponse($url); $event-&gt;setResponse($response); } }   ","version":"Next","tagName":"h3"},{"title":"Showing a Custom Error Message‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/framework-integration/symfony#showing-a-custom-error-message","content":" use Rekalogika\\Rekapager\\Bundle\\Exception\\OutOfBoundsException; use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\HttpKernel\\Event\\ExceptionEvent; use Symfony\\Component\\HttpKernel\\KernelEvents; use Twig\\Environment; final readonly class RekapagerOutOfBoundsListener { public function __construct( private Environment $twig ) { } #[AsEventListener(KernelEvents::EXCEPTION)] public function onKernelException( ExceptionEvent $event ): void { $exception = $event-&gt;getThrowable(); if (!$exception instanceof OutOfBoundsException) { return; } $html = $this-&gt;twig-&gt;render('out_of_bounds.html.twig', [ 'pager' =&gt; $exception-&gt;getPager(), 'pager_options' =&gt; $exception-&gt;getPagerOptions(), ]); $response = new Response($html, Response::HTTP_NOT_FOUND); $event-&gt;setResponse($response); } }   templates/out_of_bounds.html.twig &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Page Not Found&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Page Not Found&lt;/h1&gt; &lt;p&gt; The page you are looking for does not exist. &lt;/p&gt; &lt;p&gt; &lt;a href=&quot;{{ pager.firstPage.url }}&quot;&gt;Go to the first page&lt;/a&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt;   ","version":"Next","tagName":"h3"},{"title":"Batch Process Console Command‚Äã","type":1,"pageTitle":"Symfony Integration","url":"/rekapager/framework-integration/symfony#batch-process-console-command","content":" The package provides a easy-to-use framework for creating console commands for batch processing. Read the Simple Batch Command documentation for more information. ","version":"Next","tagName":"h2"},{"title":"Keyset Seek Method","type":0,"sectionRef":"#","url":"/rekapager/seek-method","content":"","keywords":"","version":"Next"},{"title":"The Approximated Variant‚Äã","type":1,"pageTitle":"Keyset Seek Method","url":"/rekapager/seek-method#the-approximated-variant","content":" SELECT * FROM post p WHERE p.date &gt;= :date AND NOT (p.date = :date AND p.title &lt;= :title) AND NOT (p.date = :date AND p.title = :title AND p.id &lt;= :id) ORDER BY p.date ASC, p.title ASC, p.id ASC   This method is slightly less efficient than using SQL row values, but it is more portable across different database systems. It just works in all cases. This is the default seek method used by the library.  ","version":"Next","tagName":"h2"},{"title":"SQL Row Values‚Äã","type":1,"pageTitle":"Keyset Seek Method","url":"/rekapager/seek-method#sql-row-values","content":" SELECT * FROM post p WHERE (p.date, p.title, p.id) &gt; (:date, :title, :id) ORDER BY p.date ASC, p.title ASC, p.id ASC   This method might be slightly more efficient than the approximated variant, but the support is not uniform across different database systems.  It also requires that all the columns are ordered in the same direction. For example, if the first column is ordered in ascending order, the rest of the columns must also be ordered in ascending order. If your requirement is to have a different order for each column, you have to use the approximated variant.  ","version":"Next","tagName":"h2"},{"title":"Adapter Support‚Äã","type":1,"pageTitle":"Keyset Seek Method","url":"/rekapager/seek-method#adapter-support","content":" All the adapters that support keyset pagination support the approximated variant. The SQL row values method is supported by these adapters:  Doctrine ORM QueryBuilderAdapterDoctrine ORM NativeQueryAdapterDoctrine DBAL QueryBuilderAdapter adapter  In any case, the approximate variant is used by default for better interoperability and flexibility.  ","version":"Next","tagName":"h2"},{"title":"Changing the Seek Method‚Äã","type":1,"pageTitle":"Keyset Seek Method","url":"/rekapager/seek-method#changing-the-seek-method","content":" To change the seek method, you can use the seekMethod argument. There are three options:  SeekMethod::ApproximatedSeekMethod::RowValuesSeekMethod::Auto  SeekMethod::Auto means the adapter will use the row values method if all the sort columns are ordered in the same direction, otherwise it uses the approximated variant.  Example:  use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; use Rekalogika\\Rekapager\\Adapter\\Common\\SeekMethod; use Rekalogika\\Rekapager\\Doctrine\\ORM\\QueryBuilderAdapter; $adapter = new QueryBuilderAdapter( queryBuilder: $queryBuilder, seekMethod: SeekMethod::RowValues, );   note To use SQL row values, Doctrine ORM QueryBuilderAdapter requires theREKAPAGER_ROW_VALUES DQL function to be registered. Read itsdocumentation for more information. ","version":"Next","tagName":"h2"},{"title":"Troubleshooting","type":0,"sectionRef":"#","url":"/rekapager/troubleshooting","content":"","keywords":"","version":"Next"},{"title":"Wonky Pager‚Äã","type":1,"pageTitle":"Troubleshooting","url":"/rekapager/troubleshooting#wonky-pager","content":" If you are using keyset pagination and the pager is not working as expected, as like going to page 5 lands you on page 3 or 8, or it skips some entries when going to the next page, etc; the most common cause is that the query lacks a deterministic sort order.  For example:  SELECT * FROM posts ORDER BY createdDate DESC   The above query does not have a deterministic sort order. If two posts have the same createdDate, then the sort result is non-deterministic, the database engine is free to return them in any order. Because the pager uses the fields mentioned in the ORDER BY clause to determine the page boundaries, the pager will not work correctly.  To fix this, the easiest way is to ensure the last field in the ORDER BYclause is the primary key. For example, to fix the query above, we can change it to:  SELECT * FROM posts ORDER BY createdDate DESC, id DESC   info There is no way for the pager to ensure your query has a deterministic sort order.  ","version":"Next","tagName":"h2"},{"title":"Slow First (and Last) Page‚Äã","type":1,"pageTitle":"Troubleshooting","url":"/rekapager/troubleshooting#slow-first-and-last-page","content":" If you are using keyset pagination, but the first (and last) page feels slower than the rest, usually it is because the query requires further optimization.  A common example:  SELECT * FROM comments WHERE post_id = 123 ORDER BY id ASC   If the amount of comments for a post is large, the database might prefer to scan the entire index to find the comments for post 123. Other pages are not affected much because the pager adds an anchor that the database uses to start looking for the entries.  To show a non-first page, the pager will modify the query above to something like:  SELECT * FROM comments WHERE post_id = 123 AND id &gt; 1234 ORDER BY id ASC LIMIT 10   Where 1234 is the ID of the last comment on the previous page. This query will be much faster because the database can easily locate the starting point and skip all the comments before the anchor.  ","version":"Next","tagName":"h2"},{"title":"Solution 1: Create an Index‚Äã","type":1,"pageTitle":"Troubleshooting","url":"/rekapager/troubleshooting#solution-1-create-an-index","content":" You can optimize the query by adding a composite index on the post_id and idfield:  CREATE INDEX idx_comments_post_id_id ON comments (post_id, id)   ","version":"Next","tagName":"h3"},{"title":"Solution 2: Add the Boundaries to the Query‚Äã","type":1,"pageTitle":"Troubleshooting","url":"/rekapager/troubleshooting#solution-2-add-the-boundaries-to-the-query","content":" Alternatively, you can also try adding the boundary to the first and last page yourself:  SELECT * FROM comments WHERE post_id = 123 AND id &gt;= 1000 AND id &lt;= 2000 ORDER BY id ASC   Where 1000 is the ID of the first comment of the page, and 2000 is that of the last comment. Obviously, with this solution you need to have the IDs beforehand, maybe by storing the IDs in the posts table.  If your entities are using time-based UUIDs as primary keys, in this case, you can be sure that the comments are created after the post, then you can use the post's UUID as the start boundary.  SELECT * FROM comments WHERE post_id = '0190acd3-e701-7cdf-8be0-52f66b96d731' AND id &gt;= '0190acd3-e701-7cdf-8be0-52f66b96d731' ORDER BY id ASC  ","version":"Next","tagName":"h3"},{"title":"Installation and Usage","type":0,"sectionRef":"#","url":"/rekapager/usage","content":"","keywords":"","version":"Next"},{"title":"Transforming the underlying data into a PageableInterface object‚Äã","type":1,"pageTitle":"Installation and Usage","url":"/rekapager/usage#transforming-the-underlying-data-into-a-pageableinterface-object","content":" This part is framework-independent.  use Doctrine\\DBAL\\Types\\Types; use Doctrine\\ORM\\EntityRepository; use Rekalogika\\Rekapager\\Doctrine\\ORM\\QueryBuilderAdapter; use Rekalogika\\Rekapager\\Keyset\\KeysetPageable; use Rekalogika\\Rekapager\\Offset\\OffsetPageable; // The underlying data in this example is a Doctrine ORM QueryBuilder /** @var EntityRepository $postRepository */ $queryBuilder = $postRepository -&gt;createQueryBuilder('p') -&gt;where('p.group = :group') -&gt;setParameter('group', $group) -&gt;addOrderBy('p.date', 'DESC') -&gt;addOrderBy('p.title', 'ASC') -&gt;addOrderBy('p.id', 'ASC'); // The adapter provides an uniform interface for the different types of // underlying data collection $adapter = new QueryBuilderAdapter( queryBuilder: $queryBuilder, typeMapping: [ 'p.date' =&gt; Types::DATE_MUTABLE ] ), // A pageable represents something that can be partitioned into pages. This // example uses KeysetPageable, which is a pageable that supports keyset // pagination. $pageable = new KeysetPageable( adapter: $adapter, itemsPerPage: $itemsPerPage, count: $count, ); // There is also an OffsetPageable for offset pagination. An adapter can // support either or both types of pagination. $pageable = new OffsetPageable( adapter: $adapter, itemsPerPage: $itemsPerPage, count: $count, );   ","version":"Next","tagName":"h2"},{"title":"Transforming the PageableInterface into a PagerInterface object‚Äã","type":1,"pageTitle":"Installation and Usage","url":"/rekapager/usage#transforming-the-pageableinterface-into-a-pagerinterface-object","content":" In this phase, we start involving the framework used in the application. The example below uses Symfony integration provided byrekalogika/rekapager-bundle.  use Rekalogika\\Rekapager\\Bundle\\Contracts\\PagerFactoryInterface; use Symfony\\Component\\HttpFoundation\\Request; /** @var PagerFactoryInterface $pagerFactory */ /** @var Request $request */ // The pager factory is a service that creates a PagerInterface from a // PageableInterface $pager = $pagerFactory-&gt;createFromPageable( pageable: $pageable, request: $request, options: new PagerOptions( proximity: 3, ) ); $currentPage = $pager-&gt;getCurrentPage(); foreach ($currentPage as $item) { // Do something with the item }   ","version":"Next","tagName":"h2"},{"title":"Rendering the Pager‚Äã","type":1,"pageTitle":"Installation and Usage","url":"/rekapager/usage#rendering-the-pager","content":" The PagerInterface object contains all the necessary information to render the pagination control in the user interface. The example below uses the Twig integration provided by rekalogika/rekapager-bundle.  {# Outputs the item from the current page #} &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Date&lt;/th&gt; &lt;th&gt;Content&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody {{ rekapager_infinite_scrolling_content() }}&gt; {% for post in pager.currentPage %} &lt;tr&gt; &lt;td&gt;{{ post.id }}&lt;/td&gt; &lt;td&gt;{{ post.title }}&lt;/td&gt; &lt;td&gt;{{ post.date|date('Y-m-d') }}&lt;/td&gt; &lt;td&gt;{{ post.content }}&lt;/td&gt; &lt;/tr&gt; {% endfor %} &lt;/tbody&gt; &lt;/table&gt; {# Render the pager #} {{ rekapager(pager) }}   ","version":"Next","tagName":"h2"},{"title":"Batch Processing‚Äã","type":1,"pageTitle":"Installation and Usage","url":"/rekapager/usage#batch-processing","content":" A PageableInterface object can also be used for batch processing a large amount of underlying data. The example below demonstrates how to do batch processing using Doctrine.  use Doctrine\\ORM\\EntityManagerInterface; use Rekalogika\\Rekapager\\PageableInterface; /** @var PageableInterface $pageable */ /** @var EntityManagerInterface $entityManager */ foreach ($pageable-&gt;withItemsPerPage(1000)-&gt;getPages() as $page) { foreach ($page as $item) { // Do something with the item } // Do something after each page here $entityManager-&gt;flush(); // if required $entitymanager-&gt;clear(); }  ","version":"Next","tagName":"h2"},{"title":"rekalogika/temporary-url-bundle","type":0,"sectionRef":"#","url":"/temporary-url-bundle","content":"","keywords":"","version":"Next"},{"title":"Installation‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#installation","content":" Make sure Composer is installed globally, as explained in theinstallation chapterof the Composer documentation.  With Symfony FlexWithout Symfony Flex Open a command console, enter your project directory, and execute: composer config extra.symfony.allow-contrib true composer require rekalogika/temporary-url-bundle   If you're using WebpackEncore, install your assets and restart Encore (not needed if you're using AssetMapper):  YarnNPM yarn install --force yarn watch   ","version":"Next","tagName":"h2"},{"title":"Creating a Resource Class‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#creating-a-resource-class","content":" Create a class that describes your resource. There is no particular requirement for this class, except that it must be serializable.  class MyData { public function __construct(private string $name) { } public function getName(): string { return $this-&gt;name; } }   Protip You can reuse your existing event, message, DTO, value objects, or other similar classes for this purpose.  ","version":"Next","tagName":"h2"},{"title":"Creating a Resource Server‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#creating-a-resource-server","content":" Then create a server class or method that transforms the resource into an HTTP response. Use the AsTemporaryUrlServer attribute to mark the method as a temporary URL server. If the attribute is attached to the class, then the method is assumed to be __invoke(). The method must accept the resource as its first argument, and return a Response object.  use Rekalogika\\TemporaryUrl\\Attribute\\AsTemporaryUrlServer; use Symfony\\Component\\HttpFoundation\\Response; class MyDataServer { #[AsTemporaryUrlServer] public function respond(MyData $data): Response { return new Response('My name is ' . $data-&gt;getName()); } }   ","version":"Next","tagName":"h2"},{"title":"Generating a Temporary URL‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#generating-a-temporary-url","content":" To generate a temporary URL, use the TemporaryUrlGeneratorInterface service.  use Rekalogika\\TemporaryUrl\\TemporaryUrlGeneratorInterface; /** @var TemporaryUrlGeneratorInterface $temporaryUrlGenerator */ $resource = new MyData('123'); $url = $temporaryUrlGenerator-&gt;generateUrl($resource);   The TemporaryUrlGeneratorInterface::generateUrl() offers additional options:  $ttl (int or DateInterval): The time-to-live of the URL. Defaults to 30 minutes.$pinSession (bool): Whether to pin the URL to the session. Pinned URLs can only be accessed by the same user that generated them. Defaults to false.$referenceType (int): The type of reference to be generated (one of theUrlGeneratorInterface::ABSOLUTE_* constants). Defaults toUrlGeneratorInterface::ABSOLUTE_PATH.  ","version":"Next","tagName":"h2"},{"title":"In Twig Templates‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#in-twig-templates","content":" In a Twig template, you can use the filter temporary_url to generate a temporary URL. Use the function temporary_url_autoexpire on links to make them unclickable after the URL expires.  {# my_data here is a resource object #} &lt;a href=&quot;{{ my_data|temporary_url }}&quot; {{ temporary_url_autoexpire() }}&gt; Click here to download my data &lt;/a&gt;   The filter accepts the same options as the generateUrl() method above.  ","version":"Next","tagName":"h2"},{"title":"Dealing With Unserializable Resources‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#dealing-with-unserializable-resources","content":" If your resource is not serializable, you can create a resource transformer method that converts your resource into an intermediate serializable object.  use Rekalogika\\TemporaryUrl\\Attribute\\AsTemporaryUrlResourceTransformer; use Rekalogika\\TemporaryUrl\\Attribute\\AsTemporaryUrlServer; use Symfony\\Component\\HttpFoundation\\Response; class MyDataServer { /** * This method transforms the resource into a serializable object. */ #[AsTemporaryUrlResourceTransformer] public function transform(MyUnserializableData $data): MySerializableData { return new MySerializableData($data); } ./** * This uses the transformed data and send it to the client. */ #[AsTemporaryUrlServer] public function respond(MySerializableData $data): Response { return new Response('My name is ' . $data-&gt;getName()); } }   Using the above example, you will be able to generate a temporary URL toMyUnserializableData. The framework will automatically transformMyUnserializableData to MySerializableData behind the scenes.  ","version":"Next","tagName":"h2"},{"title":"License‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#license","content":" MIT  ","version":"Next","tagName":"h2"},{"title":"Contributing‚Äã","type":1,"pageTitle":"rekalogika/temporary-url-bundle","url":"/temporary-url-bundle#contributing","content":" Issues and pull requests should be filed in the GitHub repositoryrekalogika/temporary-url-bundle. ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}