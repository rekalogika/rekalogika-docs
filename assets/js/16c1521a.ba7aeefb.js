"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[1509],{8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var r=n(6540);const a={},i=r.createContext(a);function s(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:t},e.children)}},8975:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"rekapager/seek-method","title":"Keyset Seek Method","description":"If more than one column is involved in the sorting, there are two ways to","source":"@site/docs/rekapager/10-seek-method.md","sourceDirName":"rekapager","slug":"/rekapager/seek-method","permalink":"/rekapager/seek-method","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/rekapager/10-seek-method.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"title":"Keyset Seek Method"},"sidebar":"docs","previous":{"title":"Simple Batch Command","permalink":"/rekapager/batch-processing/batch-command"},"next":{"title":"Known Issues and Limitations","permalink":"/rekapager/known-issues"}}');var a=n(4848),i=n(8453);const s={title:"Keyset Seek Method"},o=void 0,d={},l=[{value:"The Approximated Variant",id:"the-approximated-variant",level:2},{value:"SQL Row Values",id:"sql-row-values",level:2},{value:"Adapter Support",id:"adapter-support",level:2},{value:"Changing the Seek Method",id:"changing-the-seek-method",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"If more than one column is involved in the sorting, there are two ways to\nconstruct the WHERE clause in keyset pagination: using SQL row values, and using\nan approximated variant."}),"\n",(0,a.jsx)(t.h2,{id:"the-approximated-variant",children:"The Approximated Variant"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"SELECT *\nFROM post p\nWHERE p.date >= :date\n   AND NOT (p.date = :date AND p.title <= :title)\n   AND NOT (p.date = :date AND p.title = :title AND p.id <= :id)\nORDER BY p.date ASC, p.title ASC, p.id ASC\n"})}),"\n",(0,a.jsx)(t.p,{children:"This method is slightly less efficient than using SQL row values, but it is more\nportable across different database systems. It just works in all cases. This is\nthe default seek method used by the library."}),"\n",(0,a.jsx)(t.h2,{id:"sql-row-values",children:"SQL Row Values"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"SELECT *\nFROM post p\nWHERE (p.date, p.title, p.id) > (:date, :title, :id)\nORDER BY p.date ASC, p.title ASC, p.id ASC\n"})}),"\n",(0,a.jsx)(t.p,{children:"This method might be slightly more efficient than the approximated variant, but\nthe support is not uniform across different database systems."}),"\n",(0,a.jsx)(t.p,{children:"It also requires that all the columns are ordered in the same direction. For\nexample, if the first column is ordered in ascending order, the rest of the\ncolumns must also be ordered in ascending order. If your requirement is to have\na different order for each column, you have to use the approximated variant."}),"\n",(0,a.jsx)(t.h2,{id:"adapter-support",children:"Adapter Support"}),"\n",(0,a.jsx)(t.p,{children:"All the adapters that support keyset pagination support the approximated\nvariant. The SQL row values method is supported by these adapters:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Doctrine ORM ",(0,a.jsx)(t.code,{children:"QueryBuilderAdapter"})]}),"\n",(0,a.jsxs)(t.li,{children:["Doctrine ORM ",(0,a.jsx)(t.code,{children:"NativeQueryAdapter"})]}),"\n",(0,a.jsxs)(t.li,{children:["Doctrine DBAL ",(0,a.jsx)(t.code,{children:"QueryBuilderAdapter"})," adapter"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"In any case, the approximate variant is used by default for better\ninteroperability and flexibility."}),"\n",(0,a.jsx)(t.h2,{id:"changing-the-seek-method",children:"Changing the Seek Method"}),"\n",(0,a.jsxs)(t.p,{children:["To change the seek method, you can use the ",(0,a.jsx)(t.code,{children:"seekMethod"})," argument. There are\nthree options:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"SeekMethod::Approximated"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"SeekMethod::RowValues"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"SeekMethod::Auto"})}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"SeekMethod::Auto"})," means the adapter will use the row values method if all the\nsort columns are ordered in the same direction, otherwise it uses the\napproximated variant."]}),"\n",(0,a.jsx)(t.p,{children:"Example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-php",children:"use Rekalogika\\Rekapager\\Keyset\\KeysetPageable;\nuse Rekalogika\\Rekapager\\Adapter\\Common\\SeekMethod;\nuse Rekalogika\\Rekapager\\Doctrine\\ORM\\QueryBuilderAdapter;\n\n$adapter = new QueryBuilderAdapter(\n    queryBuilder: $queryBuilder,\n    // highlight-next-line\n    seekMethod: SeekMethod::RowValues,\n);\n"})}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["To use SQL row values, Doctrine ORM ",(0,a.jsx)(t.code,{children:"QueryBuilderAdapter"})," requires the\n",(0,a.jsx)(t.code,{children:"REKAPAGER_ROW_VALUES"})," DQL function to be registered. Read its\n",(0,a.jsx)(t.a,{href:"/rekapager/adapters/doctrine-orm-querybuilder",children:"documentation"})," for more\ninformation."]})})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}}}]);