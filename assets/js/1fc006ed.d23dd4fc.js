"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[318],{5209:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"api-lite/components","title":"Components Overview","description":"These are the components involved in building an API Platform-based project","source":"@site/docs/api-lite/01-components.md","sourceDirName":"api-lite","slug":"/api-lite/components","permalink":"/api-lite/components","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/api-lite/01-components.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Components Overview"},"sidebar":"docs","previous":{"title":"Introduction","permalink":"/api-lite/intro"},"next":{"title":"Design Considerations & Decisions","permalink":"/api-lite/design"}}');var o=t(4848),a=t(8453);const r={title:"Components Overview"},s=void 0,l={},d=[{value:"Components Defined by Your Application",id:"components-defined-by-your-application",level:2},{value:"Domain Layer",id:"domain-layer",level:3},{value:"API Resource DTOs",id:"api-resource-dtos",level:3},{value:"Input DTOs",id:"input-dtos",level:3},{value:"Components Defined by API Platform",id:"components-defined-by-api-platform",level:2},{value:"State Provider",id:"state-provider",level:3},{value:"State Processor",id:"state-processor",level:3},{value:"Paginator",id:"paginator",level:3},{value:"Components Defined By <code>rekalogika/api-lite</code>",id:"components-defined-by-rekalogikaapi-lite",level:2},{value:"Mapper",id:"mapper",level:3},{value:"Paginator Applier",id:"paginator-applier",level:3}];function p(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"These are the components involved in building an API Platform-based project\nusing the principles described in this documentation."}),"\n",(0,o.jsx)(n.h2,{id:"components-defined-by-your-application",children:"Components Defined by Your Application"}),"\n",(0,o.jsx)(n.h3,{id:"domain-layer",children:"Domain Layer"}),"\n",(0,o.jsx)(n.p,{children:"The heart of your software. The domain layer describes the business logic and\nrules. It consists of entities, value objects, domain services, and other\nsupporting classes."}),"\n",(0,o.jsx)(n.p,{children:"In most Symfony and API Platform projects, Doctrine is used to manage the\npersistence of the domain layer. However, it can be anything & our API layer\ndoes not care about how the domain layer is persisted and managed."}),"\n",(0,o.jsx)(n.h3,{id:"api-resource-dtos",children:"API Resource DTOs"}),"\n",(0,o.jsxs)(n.p,{children:["These are the data transfer objects (DTOs) that are used to represent the\nresources in the API. In our projects, we will be using these DTOs as the\n",(0,o.jsx)(n.code,{children:"ApiResource"})," classes. Unlike most of the API Platform examples and demos you\nwill find on the Internet, we will not be adding the ",(0,o.jsx)(n.code,{children:"ApiResource"})," attribute to\nour entities."]}),"\n",(0,o.jsx)(n.p,{children:"These DTOs will usually mirror the domain entities. They usually contain a\nsubset of the properties, but without the domain logic. And like the entities,\nthese DTOs will usually form a rich, interconnected graph of objects."}),"\n",(0,o.jsx)(n.p,{children:"These DTOs act as the output of the endpoints."}),"\n",(0,o.jsx)(n.p,{children:"An entity can be mapped to one or more DTOs if we need different API\nrepresentations of a specific entity. For example, we can use a specific DTO\nfor a class of user, and a different DTO for another class or user."}),"\n",(0,o.jsx)(n.h3,{id:"input-dtos",children:"Input DTOs"}),"\n",(0,o.jsx)(n.p,{children:"The DTOs representing the input data for operations that require an input, like\nPOST, PUT, and PATCH."}),"\n",(0,o.jsx)(n.h2,{id:"components-defined-by-api-platform",children:"Components Defined by API Platform"}),"\n",(0,o.jsx)(n.h3,{id:"state-provider",children:"State Provider"}),"\n",(0,o.jsx)(n.p,{children:"Used to get the output of a GET operations. Using our guidelines, you will\nimplement a state provider for every GET operation that you define. The state\nprovider will be responsible for fetching the entity from the domain layer,\nmapping it to the DTO, and returning it."}),"\n",(0,o.jsx)(n.h3,{id:"state-processor",children:"State Processor"}),"\n",(0,o.jsx)(n.p,{children:"Modifies the state of the entity. Used by the POST, PUT, PATCH, and DELETE\noperations. Using our guidelines, you will implement a state processor for every\noperation that modifies the state of the entity."}),"\n",(0,o.jsx)(n.h3,{id:"paginator",children:"Paginator"}),"\n",(0,o.jsx)(n.p,{children:"A paginator is an API Platform interface used to paginate the results of a GET\noperations. If your endpoint is a GET operation that is supposed to return a\ncollection of objects, you should return a paginator object instead of an array\nor a collection. By doing so, you will get proper paging of the results."}),"\n",(0,o.jsxs)(n.h2,{id:"components-defined-by-rekalogikaapi-lite",children:["Components Defined By ",(0,o.jsx)(n.code,{children:"rekalogika/api-lite"})]}),"\n",(0,o.jsx)(n.h3,{id:"mapper",children:"Mapper"}),"\n",(0,o.jsxs)(n.p,{children:["Maps an object to another object. The functionality is provided by\n",(0,o.jsx)(n.code,{children:"rekalogika/mapper"})," behind the scenes. It can be used to map between entities\nand DTOs. This mapper provides several critical features for our purposes,\nincluding handling circular references and lazy-loading target objects.\nTherefore, we can have interconnected DTOs and API Platform should be able to\ngenerate IRIs without causing the hydration of the entire object graph."]}),"\n",(0,o.jsx)(n.h3,{id:"paginator-applier",children:"Paginator Applier"}),"\n",(0,o.jsxs)(n.p,{children:["A service provided by ",(0,o.jsx)(n.code,{children:"rekalogika/api-lite"})," to automatically transform\na collection of objects to a paginator. It ships with paginator appliers for\nDoctrine Collection, Selectable, Query, QueryBuilder, as well as Pagerfanta and\nPagerfanta adapter.."]})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(6540);const o={},a=i.createContext(o);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);