"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[5444],{693:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"analytics/internals/refresh","title":"Refresh Mechanism","description":"DirtyFlag","source":"@site/docs/analytics/99-internals/02-refresh.md","sourceDirName":"analytics/99-internals","slug":"/analytics/internals/refresh","permalink":"/analytics/internals/refresh","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/analytics/99-internals/02-refresh.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Refresh Mechanism"},"sidebar":"docs","previous":{"title":"Partitioning","permalink":"/analytics/internals/partitioning"},"next":{"title":"Current To-do List","permalink":"/analytics/internals/todo"}}');var s=n(4848),r=n(8453);const a={title:"Refresh Mechanism"},o=void 0,c={},l=[{value:"<code>DirtyFlag</code>",id:"dirtyflag",level:2},{value:"<code>SourceEntityListener</code>",id:"sourceentitylistener",level:2},{value:"<code>NewDirtyFlagListener</code>",id:"newdirtyflaglistener",level:2}];function d(e){const t={admonition:"admonition",code:"code",h2:"h2",p:"p",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"dirtyflag",children:(0,s.jsx)(t.code,{children:"DirtyFlag"})}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.code,{children:"DirtyFlag"})," is an entity indicating a dirty partition, which is a partition in\na summary table that needs to be refreshed. ",(0,s.jsx)(t.code,{children:"DirtyFlag"})," should be persisted and\nflushed at the same time as the rest of the entities, during the ",(0,s.jsx)(t.code,{children:"onFlush"}),"\nevent. So if the flush fails, the flag will not be saved."]}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.code,{children:"DirtyFlag"})," can have null partition information. In this case, it means there\nare new persisted entities that need to be summarized. New entities need to be\nhandled differently because they are not guaranteed to have an ID before flush."]}),"\n",(0,s.jsx)(t.h2,{id:"sourceentitylistener",children:(0,s.jsx)(t.code,{children:"SourceEntityListener"})}),"\n",(0,s.jsxs)(t.p,{children:["Listens on Doctrine's ",(0,s.jsx)(t.code,{children:"onFlush"})," event. For every pending entities, it checks the\nchange set and determines if the change affects any summary tables. If a\nproperty is changed, and that would affect one or more summary tables, it\ncreates the corresponding ",(0,s.jsx)(t.code,{children:"DirtyFlag"})," objects for each of the partition that\nneeds to be refreshed."]}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsx)(t.p,{children:"This automatic detection works only for simple cases: it only detects the change\nof the properties in the entity itself. If the change that would affect the\nsummary is in a related entity, the framework cannot detect that."})}),"\n",(0,s.jsxs)(t.p,{children:["At the end of a flush, the listener will dispatch a ",(0,s.jsx)(t.code,{children:"NewDirtyFlagEvent"})," event."]}),"\n",(0,s.jsx)(t.h2,{id:"newdirtyflaglistener",children:(0,s.jsx)(t.code,{children:"NewDirtyFlagListener"})}),"\n",(0,s.jsxs)(t.p,{children:["Listens on the ",(0,s.jsx)(t.code,{children:"NewDirtyFlagEvent"})," event. It calls\n",(0,s.jsx)(t.code,{children:"RefreshScheduler::scheduleWorker()"})," to schedule a worker to refresh the dirty\npartitions."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var i=n(6540);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);