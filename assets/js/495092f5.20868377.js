"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[2491],{6852:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>s});const t=JSON.parse('{"id":"reconstitutor/methods","title":"Methods","description":"There are several methods that you can override in your reconstitutor classes.","source":"@site/docs/reconstitutor/03-methods.md","sourceDirName":"reconstitutor","slug":"/reconstitutor/methods","permalink":"/reconstitutor/methods","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/reconstitutor/03-methods.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Methods"},"sidebar":"docs","previous":{"title":"Usage","permalink":"/reconstitutor/usage"},"next":{"title":"rekalogika/rekapager","permalink":"/rekapager/"}}');var i=o(4848),r=o(8453);const a={title:"Methods"},c=void 0,d={},s=[{value:"<code>onCreate()</code>",id:"oncreate",level:2},{value:"<code>onLoad()</code>",id:"onload",level:2},{value:"<code>onSave()</code>",id:"onsave",level:2},{value:"<code>onRemove()</code>",id:"onremove",level:2},{value:"<code>onClear()</code>",id:"onclear",level:2}];function l(e){const n={admonition:"admonition",code:"code",h2:"h2",p:"p",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["There are several methods that you can override in your reconstitutor classes.\nMost of the time, you will be working with the ",(0,i.jsx)(n.code,{children:"onSave()"}),", ",(0,i.jsx)(n.code,{children:"onLoad()"}),", and\n",(0,i.jsx)(n.code,{children:"onRemove()"})," methods."]}),"\n",(0,i.jsx)(n.h2,{id:"oncreate",children:(0,i.jsx)(n.code,{children:"onCreate()"})}),"\n",(0,i.jsxs)(n.p,{children:["Executed when the object is added to the persistence layer, e.g. when you first\ncall Doctrine's ",(0,i.jsx)(n.code,{children:"EntityManager::persist()"})," on the object."]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"Implementors should generally avoid using this method for initializing the\nobject, and instead initialize the object using a factory. Changing the object's\nbehavior in this method can be surprising to the caller and can be considered\nanti-pattern."})}),"\n",(0,i.jsx)(n.h2,{id:"onload",children:(0,i.jsx)(n.code,{children:"onLoad()"})}),"\n",(0,i.jsxs)(n.p,{children:["Called when the object is loaded from the database. For example, when you call\n",(0,i.jsx)(n.code,{children:"EntityManager::find()"})," or ",(0,i.jsx)(n.code,{children:"EntityManager::findAll()"}),", or when you use ",(0,i.jsx)(n.code,{children:"Query"}),"\nto load the object."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["If the object is a proxy, ",(0,i.jsx)(n.code,{children:"onLoad()"})," will be called only after the object is\ninitialized. Calling ",(0,i.jsx)(n.code,{children:"EntityManager::getReference()"})," by itself does not trigger\n",(0,i.jsx)(n.code,{children:"onLoad()"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"onsave",children:(0,i.jsx)(n.code,{children:"onSave()"})}),"\n",(0,i.jsxs)(n.p,{children:["Called after the object is saved to the database. For example, when you call\n",(0,i.jsx)(n.code,{children:"EntityManager::flush()"}),"."]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"onSave()"})," will be called for all initialized objects in the unit of\nwork, even if the object is not dirty."]}),(0,i.jsxs)(n.p,{children:["If the object is an uninitialized proxy, ",(0,i.jsx)(n.code,{children:"onSave()"})," will not be called on that\nobject."]})]}),"\n",(0,i.jsx)(n.h2,{id:"onremove",children:(0,i.jsx)(n.code,{children:"onRemove()"})}),"\n",(0,i.jsxs)(n.p,{children:["Called when the object is removed from the database. For example, when you\nmark the object to be removed using ",(0,i.jsx)(n.code,{children:"EntityManager::remove()"}),", then call\n",(0,i.jsx)(n.code,{children:"EntityManager::flush()"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["If the object is an uninitialized proxy when you call ",(0,i.jsx)(n.code,{children:"EntityManager::remove()"}),",\nthe framework will initialize the object before calling ",(0,i.jsx)(n.code,{children:"onRemove()"}),". So\n",(0,i.jsx)(n.code,{children:"onRemove()"})," will always get an initialized object, but already removed from\ndatabase by Doctrine."]})}),"\n",(0,i.jsx)(n.h2,{id:"onclear",children:(0,i.jsx)(n.code,{children:"onClear()"})}),"\n",(0,i.jsxs)(n.p,{children:["Called when the object is cleared from the persistence layer. For example, when\nyou call ",(0,i.jsx)(n.code,{children:"EntityManager::clear()"}),", and also when you call\n",(0,i.jsx)(n.code,{children:"EntityManager::detach()"})," then ",(0,i.jsx)(n.code,{children:"EntityManager::flush()"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["We cannot call ",(0,i.jsx)(n.code,{children:"onClear()"})," right on ",(0,i.jsx)(n.code,{children:"EntityManager::detach()"}),", because Doctrine\ndoes not provide the necessary event. We can know they are being detached only\nafter ",(0,i.jsx)(n.code,{children:"EntityManager::flush()"})," is called because we track the objects as they go\nthrough their lifecycle."]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>c});var t=o(6540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);