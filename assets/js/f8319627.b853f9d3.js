"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[3137],{2810:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"analytics/time-dimension/dimensions","title":"Dimensions","description":"To summarize a source time field to a single time dimension, you can use the","source":"@site/docs/analytics/08-time-dimension/02-dimensions.md","sourceDirName":"analytics/08-time-dimension","slug":"/analytics/time-dimension/dimensions","permalink":"/analytics/time-dimension/dimensions","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/analytics/08-time-dimension/02-dimensions.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Dimensions"},"sidebar":"docs","previous":{"title":"Dimension Groups","permalink":"/analytics/time-dimension/dimension-groups"},"next":{"title":"Metadata","permalink":"/analytics/metadata/"}}');var s=i(4848),o=i(8453);const a={title:"Dimensions"},r=void 0,l={},c=[{value:"Usage Inside a Dimension Group",id:"usage-inside-a-dimension-group",level:2}];function d(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"To summarize a source time field to a single time dimension, you can use the\nfollowing pattern:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"use Doctrine\\ORM\\Mapping as ORM;\nuse Rekalogika\\Analytics\\Core\\Metadata as Analytics;\nuse Rekalogika\\Analytics\\Core\\Entity\\BaseSummary;\nuse Rekalogika\\Analytics\\Core\\ValueResolver\\PropertyValue;\nuse Rekalogika\\Analytics\\Time\\ValueResolver\\TimeBinValueResolver;\nuse Rekalogika\\Analytics\\Time\\Metadata\\TimeProperties;\nuse Rekalogika\\Analytics\\Time\\Bin\\Date;\n\nclass OrderSummary extends BaseSummary\n{\n    #[ORM\\Column(type: Date::TYPE, nullable: true)]\n    #[Analytics\\Dimension(\n        source: new TimeBinValueResolver(\n            binClass: Date::class,\n            input: new PropertyValue('time'),\n        ),\n    )]\n    #[TimeProperties(\n        sourceTimeZone: new \\DateTimeZone('UTC'),\n        summaryTimeZone: new \\DateTimeZone('Asia/Jakarta'),\n    )]\n    private ?int $date = null;\n\n    public function getDate(): ?Date\n    {\n        return $this->getContext()->getUserValue(\n            property: 'date',\n            class: Date::class,\n        );\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ORM\\Column(type: Date::TYPE"}),") is the Doctrine column type. The ",(0,s.jsx)(n.code,{children:"TYPE"})," constant\ncontains the suitable Doctrine column type for each time bin type, which may be\n",(0,s.jsx)(n.code,{children:"integer"})," or ",(0,s.jsx)(n.code,{children:"smallint"}),", depending on the type."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"source"})," is an instance of ",(0,s.jsx)(n.code,{children:"TimeBinValueResolver"}),", which takes the input,\nthen bins it to the specified time bin type. Here we take the property ",(0,s.jsx)(n.code,{children:"time"}),",\nand bin it to a date."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"TimeProperties"})," attribute is used to specify the source and summary time\nzones. If the input expression does not contain a time zone, it will be assumed\nto be in the source time zone. If the input contains a time zone, or if it is a\ndate, then the source time zone will be ignored. The summary time zone is used\nto convert the input time to the summary time zone."]}),"\n",(0,s.jsxs)(n.p,{children:["The property type hint of the time dimension must be ",(0,s.jsx)(n.code,{children:"?int"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The getter method ",(0,s.jsx)(n.code,{children:"getDate()"})," returns the time dimension as an instance of\n",(0,s.jsx)(n.code,{children:"Date"}),". The ",(0,s.jsx)(n.code,{children:"getContext()->getUserValue()"})," method is used to automatically\nget the value from the context. Internally, the context will get it from the\n",(0,s.jsx)(n.code,{children:"TimeBinValueResolver"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Technically, you can omit the smart getter, and return the integer value as is.\nBut the ",(0,s.jsx)(n.code,{children:"Date"})," class and other ",(0,s.jsx)(n.code,{children:"TimeBin"}),"/",(0,s.jsx)(n.code,{children:"RecurringTimeBin"})," classes provide a\nmore convenient way to work with time dimensions. They provide descriptive\noutput, start and end times, and give the framework the ability to fill in\nmissing values in the output."]}),"\n",(0,s.jsx)(n.h2,{id:"usage-inside-a-dimension-group",children:"Usage Inside a Dimension Group"}),"\n",(0,s.jsx)(n.p,{children:"If you want to use the time dimension inside a dimension group, you can do the\nsame as above with these changes:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["You don't need to supply the ",(0,s.jsx)(n.code,{children:"input"})," parameter in the ",(0,s.jsx)(n.code,{children:"TimeBinValueResolver"}),",\nas it will get the value from upstream."]}),"\n",(0,s.jsxs)(n.li,{children:["You should omit the ",(0,s.jsx)(n.code,{children:"TimeProperties"})," attribute, so the user will be able to\nspecify the time zone in the summary class."]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var t=i(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);