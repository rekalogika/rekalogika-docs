"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[4692],{8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}},8731:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"pivot-table/usage","title":"Usage","description":"This section explains how to use the library.","source":"@site/docs/pivot-table/02-usage.md","sourceDirName":"pivot-table","slug":"/pivot-table/usage","permalink":"/pivot-table/usage","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/pivot-table/02-usage.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Usage"},"sidebar":"docs","previous":{"title":"Quick Start","permalink":"/pivot-table/quick-start"},"next":{"title":"Rendering a Pivot Table","permalink":"/pivot-table/rendering"}}');var r=t(4848),i=t(8453);const s={title:"Usage"},o=void 0,l={},d=[{value:"SQL Query",id:"sql-query",level:2},{value:"Getting the Data",id:"getting-the-data",level:2},{value:"Transforming the Raw Data to a Cube",id:"transforming-the-raw-data-to-a-cube",level:2},{value:"Transforming the Cube to a Pivot Table",id:"transforming-the-cube-to-a-pivot-table",level:2},{value:"Rendering the Pivot Table",id:"rendering-the-pivot-table",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"This section explains how to use the library."}),"\n",(0,r.jsx)(n.h2,{id:"sql-query",children:"SQL Query"}),"\n",(0,r.jsx)(n.p,{children:"Usually, we will need to get the data from a database. For maximum\nfunctionality, the result must be cubed. The query should look like the\nfollowing example for PostgreSQL."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"SELECT\n    -- Here, name, country, and month are the dimensions. ArrayTable works with\n    -- field names, so use aliases if necessary.\n    name,\n    country,\n    month,\n\n    -- count and sum are the measures. Again, ArrayTable works with field names,\n    -- use aliases to resolve ambiguity.\n    COUNT(*) AS count,\n    SUM(price) AS sum,\n\n    -- the grouping function determines if a field is 'rolled-up'.\n    GROUPING(name, country, month) AS grouping\nFROM items\n\n-- The library works best with a CUBEd result, although it can work without it\n-- in a degraded mode.\nGROUP BY DISTINCT CUBE(name, country, month)\n\n-- ORDER BY clause determines the order of the dimensions in the output table.\nORDER BY\n    name,\n    country,\n    month\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["The library can work with ",(0,r.jsx)(n.code,{children:"ROLLUP"})," or even without any grouping, but some\nfunctionality will be lost. See ",(0,r.jsx)(n.a,{href:"/pivot-table/grouping",children:"Grouping Strategies"})," for more\ninformation."]})}),"\n",(0,r.jsx)(n.h2,{id:"getting-the-data",children:"Getting the Data"}),"\n",(0,r.jsxs)(n.p,{children:["The library does not care how you get the data, but ",(0,r.jsx)(n.code,{children:"ArrayTable"})," needs the data\nto be in the form of ",(0,r.jsx)(n.code,{children:"iterable<array<string,mixed>>"}),". You can use whatever means\nto get the data, including PDO, a database abstraction library, or an ORM."]}),"\n",(0,r.jsxs)(n.p,{children:["Also note the data type is ",(0,r.jsx)(n.code,{children:"mixed"}),", you can use raw strings or numbers as\nreturned by the database, or it can also be in higher-level types as returned by\nan ORM or database abstraction layer, including enums, entity objects, value\nobjects, etc. You may need to provide a ",(0,r.jsx)(n.a,{href:"/pivot-table/rendering",children:"custom renderer"})," to\nrender the high-level types."]}),"\n",(0,r.jsx)(n.h2,{id:"transforming-the-raw-data-to-a-cube",children:"Transforming the Raw Data to a Cube"}),"\n",(0,r.jsxs)(n.p,{children:["The library works with a ",(0,r.jsx)(n.code,{children:"Cube"})," instance. So, we need to transform the raw data\ninto a ",(0,r.jsx)(n.code,{children:"Cube"}),". The library provides ",(0,r.jsx)(n.code,{children:"ArrayTableFactory"})," that you can use to create a\n",(0,r.jsx)(n.code,{children:"Cube"})," from the raw data."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Rekalogika\\PivotTable\\ArrayTable\\ArrayTableFactory;\n\n/** @var iterable<array<string,mixed>> $data The raw data from the database */\n\n$cube = ArrayTableFactory::createCube(\n    input: $data,\n\n    // dimension fields must be in the same order as the GROUPING() function in\n    // the SQL query:\n    dimensionFields: ['name', 'country', 'month'],\n    measureFields: ['count', 'sum'],\n    groupingField: 'grouping',\n\n    // Legends for dimensions and measures. The special dimension '@values'\n    // represents the grouped measures.\n    legends: [\n        '@values' => 'Values',\n        'name' => 'Item Name',\n        'country' => 'Country',\n        'month' => 'Month',\n        'count' => 'Count',\n        'sum' => 'Sum',\n    ],\n\n    // The labels to use for dimension subtotals.\n    subtotalLabels: [\n        'name' => 'All Names',\n        'country' => 'All Countries',\n        'month' => 'All Months',\n    ],\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"transforming-the-cube-to-a-pivot-table",children:"Transforming the Cube to a Pivot Table"}),"\n",(0,r.jsxs)(n.p,{children:["Next, we need to transform the ",(0,r.jsx)(n.code,{children:"Cube"})," into a pivot table. This is done by\n",(0,r.jsx)(n.code,{children:"PivotTableTransformer"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Rekalogika\\PivotTable\\PivotTableTransformer;\nuse Rekalogika\\PivotTable\\Contracts\\Cube\\Cube;\n\n/** @var Cube $cube The data cube from the previous step */\n\n$htmlTable = PivotTableTransformer::transform(\n    cube: $cube,\n\n    // Dimensions that go to the rows.\n    rows: ['country', 'month'],\n\n    // Dimensions that go to the columns.\n    columns: ['@values', 'name'],\n\n    // Which measures to include\n    measures: ['count', 'sum'],\n\n    // A dimension in this list will not get a legend in the output table. Only\n    // makes sense if the dimension is pivoted.\n    skipLegends: ['@values'],\n\n    // Add subtotals for these dimensions. Subtotals will only be added if they\n    // exist here.\n    subtotals: [\n        'name' => true,\n        'country' => true,\n    ],\n);\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"@values"})," is a special dimension that represents the measures. You can regard it\nas a dimension that has as many values as the number of measures."]})}),"\n",(0,r.jsx)(n.h2,{id:"rendering-the-pivot-table",children:"Rendering the Pivot Table"}),"\n",(0,r.jsxs)(n.p,{children:["Finally, we need to render the pivot table. The library provides a default\nrenderer ",(0,r.jsx)(n.code,{children:"BasicTableRenderer"})," that renders the pivot table into an HTML string."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Rekalogika\\PivotTable\\TableRenderer\\BasicTableRenderer;\nuse Rekalogika\\PivotTable\\HtmlTable\\Table;\n\n/** @var Table $htmlTable The pivot table from the previous step */\n\n$html = BasicTableRenderer::render($htmlTable);\necho $html;\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}}}]);