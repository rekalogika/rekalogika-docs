"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[3219],{367:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"file-bundle/file-location/file-location","title":"Where The Files Are Stored","description":"The service ChainedClassBasedFileLocationResolver decides where to store the","source":"@site/docs/file-bundle/17-file-location/01-file-location.md","sourceDirName":"file-bundle/17-file-location","slug":"/file-bundle/file-location/file-location","permalink":"/file-bundle/file-location/file-location","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/file-bundle/17-file-location/01-file-location.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Where The Files Are Stored"},"sidebar":"docs","previous":{"title":"Command Line Utilities","permalink":"/file-bundle/cli"},"next":{"title":"Overriding the Algorithm","permalink":"/file-bundle/file-location/overriding"}}');var o=i(4848),l=i(8453);const r={title:"Where The Files Are Stored"},s=void 0,a={},c=[{value:"Default Algorithm",id:"default-algorithm",level:2},{value:"Determining the File Location",id:"determining-the-file-location",level:2},{value:"About File Names",id:"about-file-names",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Architecture",id:"architecture",level:2}];function h(e){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["The service ",(0,o.jsx)(t.code,{children:"ChainedClassBasedFileLocationResolver"})," decides where to store the\nfile. It takes the entity class, identifier, and the name of the property\nholding the file and outputs a ",(0,o.jsx)(t.code,{children:"FilePointer"})," pointing to the location where the\nfile in that property will be stored."]}),"\n",(0,o.jsx)(t.h2,{id:"default-algorithm",children:"Default Algorithm"}),"\n",(0,o.jsxs)(t.p,{children:["The default implementation ",(0,o.jsx)(t.code,{children:"DefaultClassBasedFileLocationResolver"}),"\nstores files into the filesystem with the identifier 'default' and the key\nsimilar to the following:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"entity/ffa87ef3fc5388bc8b666e2cec17d27cc493d0c1/image/e5/80/72/6d/31337\n\u2570----\u256f \u2570--------------------------------------\u256f \u2570---\u256f \u2570---------\u256f \u2570---\u256f\n  A                      B                        C        D        E\n"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"A: Prefix, defaults to 'entity'."}),"\n",(0,o.jsx)(t.li,{children:"B: The class signature, by default it is the SHA-1 hash of the entity's\nfully-qualified class name."}),"\n",(0,o.jsx)(t.li,{children:"C: Property name."}),"\n",(0,o.jsx)(t.li,{children:"D: Hashed directories of the entity's ID. The ID is hashed using SHA-1, then\nsplit by 2 characters each. Then, the first four of them are taken to form\nthe directory structure."}),"\n",(0,o.jsx)(t.li,{children:"E: The entity ID."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"This default should be sufficient in most cases, for all entities, and all\ntypes of file system. It is chosen with the following objectives in mind:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"It masks internal details (entity class names) because we may need to expose\nthe name to the Internet."}),"\n",(0,o.jsx)(t.li,{children:"It does not store too many files in a single directory because some\nfile system types struggle with a huge number of files in a directory."}),"\n",(0,o.jsx)(t.li,{children:"The ordering is chosen to make it easier for manual administration tasks."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["To obtain the entity's ID, ",(0,o.jsx)(t.code,{children:"DefaultFileLocationResolver"})," calls\n",(0,o.jsx)(t.code,{children:"ObjectIdResolverInterface"}),". By default, it is ",(0,o.jsx)(t.code,{children:"DoctrineObjectIdResolver"})," which\nobtains the ID from Doctrine Entity Manager."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"DefaultFileLocationResolver"})," then uses\n",(0,o.jsx)(t.code,{children:"ClassBasedFileLocationResolverInterface"})," to determine the location of the file\nwhich ultimately provides the above logic."]}),"\n",(0,o.jsx)(t.h2,{id:"determining-the-file-location",children:"Determining the File Location"}),"\n",(0,o.jsxs)(t.p,{children:["To determine the location of a file, you can use the ",(0,o.jsx)(t.code,{children:"rekalogika:file:resolve"}),"\ncommand. The command takes the entity class, the identifier, and the property\nname of the file in the class, in that order:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-bash",children:"$ php bin/console rekalogika:file:resolve \\\n      'App\\Entity\\Article' \\\n      01955f6c-f3ff-7830-b78b-1b06603c1c98 \\\n      image\n"})}),"\n",(0,o.jsx)(t.p,{children:"The information will also appear in Symfony's profiler panel."}),"\n",(0,o.jsx)(t.h2,{id:"about-file-names",children:"About File Names"}),"\n",(0,o.jsx)(t.p,{children:"Like modern key-value cloud storage services, this framework uses the concept of\n'keys', not 'paths'. The file name is not used as the name of the key but is\nstored in the metadata, along with other properties of the file (file size,\ntype, etc.). The original file name is never considered when determining where to\nstore the file."}),"\n",(0,o.jsx)(t.p,{children:"The metadata itself is stored in a sidecar file. Using the example above, the\nmetadata will be stored in this location:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"entity/ffa87ef3fc5388bc8b666e2cec17d27cc493d0c1/image/e5/80/72/6d/31337.metadata\n"})}),"\n",(0,o.jsx)(t.p,{children:"The caller can obtain the file name using the appropriate methods:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-php",children:"$imageFilename = $entity->getImage()?->getName();\n"})}),"\n",(0,o.jsx)(t.p,{children:"When possible, the framework should copy the file name of the original file to\nthe destination metadata when the file was first associated with the entity."}),"\n",(0,o.jsx)(t.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,o.jsx)(t.p,{children:"The storage key of the file is deterministic. It is determined only by the\nobject's class name, the object's ID, and the name of the property containing the\nfile. As long as those don't change, the key will remain the same."}),"\n",(0,o.jsx)(t.p,{children:"When persisting an entity, the framework will calculate the destination storage\nkey of every applicable property of the entity, and compare it to the current\nfile residing on each property:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"If both are the same, the framework leaves it alone."}),"\n",(0,o.jsx)(t.li,{children:"If they are different, the framework will copy the file from the entity to the\nstorage destination."}),"\n",(0,o.jsx)(t.li,{children:"If null, the framework will attempt to remove the file from the storage,\nirrespective of whether the file exists or not."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"architecture",children:"Architecture"}),"\n",(0,o.jsxs)(t.p,{children:["In a nutshell: Doctrine Unit Of Work \u27a1\ufe0f Doctrine Events \u27a1\ufe0f\n",(0,o.jsx)(t.code,{children:"rekalogika/reconstitutor"})," \u27a1\ufe0f ",(0,o.jsx)(t.code,{children:"InterfaceReconstitutor"})," &\n",(0,o.jsx)(t.code,{children:"AttributeReconstitutor"})," \u27a1\ufe0f ",(0,o.jsx)(t.code,{children:"ObjectManagerInterface"})," \u27a1\ufe0f\n",(0,o.jsx)(t.code,{children:"PropertyManagerInterface"})," \u27a1\ufe0f ",(0,o.jsx)(t.code,{children:"FileRepository"})," (from rekalogika/file)."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"InterfaceReconstitutor"})," & ",(0,o.jsx)(t.code,{children:"AttributeReconstitutor"})," are the entry points of this\npackage. They execute methods of ",(0,o.jsx)(t.code,{children:"ObjectManagerInterface"})," which calls\n",(0,o.jsx)(t.code,{children:"PropertyManagerInterface"}),", which in turn  works with the entities and\n",(0,o.jsx)(t.code,{children:"FileRepository"})," to manage the association between the entities and files."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"InterfaceReconstitutor"})," & ",(0,o.jsx)(t.code,{children:"AttributeReconstitutor"})," are registered to the\nservice container so that they are called by our ",(0,o.jsx)(t.code,{children:"rekalogika/reconstitutor"})," when\nthe relevant events are being emitted by Doctrine. The service configuration is\ndone by the package ",(0,o.jsx)(t.code,{children:"rekalogika/file-bundle"}),"."]})]})}function d(e={}){const{wrapper:t}={...(0,l.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>s});var n=i(6540);const o={},l=n.createContext(o);function r(e){const t=n.useContext(l);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),n.createElement(l.Provider,{value:t},e.children)}}}]);