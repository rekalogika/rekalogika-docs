"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[1860],{9938:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>a});var t=o(5893),i=o(1151);const l={title:"Potential Out-of-Memory Handling"},s=void 0,r={id:"collections/behaviors/oom",title:"Potential Out-of-Memory Handling",description:"Problem",source:"@site/docs/collections/03-behaviors/01-oom.md",sourceDirName:"collections/03-behaviors",slug:"/collections/behaviors/oom",permalink:"/collections/behaviors/oom",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/collections/03-behaviors/01-oom.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Potential Out-of-Memory Handling"},sidebar:"docs",previous:{title:"Behaviors",permalink:"/collections/behaviors/"},next:{title:"Iterating Large Collections",permalink:"/collections/behaviors/iterator"}},c={},a=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2},{value:"What to Do After the Threshold is Reached",id:"what-to-do-after-the-threshold-is-reached",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"problem",children:"Problem"}),"\n",(0,t.jsxs)(n.p,{children:["Doctrine ORM offers ",(0,t.jsx)(n.a,{href:"https://www.doctrine-project.org/projects/doctrine-orm/en/current/tutorials/extra-lazy-associations.html",children:"extra lazy\ncollections"}),"\nto handle large sets of data. However, only a few methods are extra-lazy-safe.\nThese safe methods will not trigger the full initialization of the collection,\nand won't cause out-of-memory errors:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"contains($entity)"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"containsKey($key)"})," (only if ",(0,t.jsx)(n.code,{children:"indexBy"})," is set)"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"count()"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"get($key)"})," (only if ",(0,t.jsx)(n.code,{children:"indexBy"})," is set)"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"slice($offset, $length = null)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"add($entity)"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"offsetSet($key, $entity)"})," (only if ",(0,t.jsx)(n.code,{children:"$key"})," is null)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"offsetExists($key)"})," (only if ",(0,t.jsx)(n.code,{children:"indexBy"})," is set)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"offsetGet($key)"})," (only if ",(0,t.jsx)(n.code,{children:"indexBy"})," is set)"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"matching($criteria)"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"All the other methods not listed above are not safe. If a non-safe method is\ncalled, Doctrine will load the entire collection into memory, potentially\ncausing out-of-memory errors. These errors can be very difficult to debug. It is\ndifficult to catch in CI. And it often gets triggered in seemingly unrelated\nparts of the application."}),"\n",(0,t.jsx)(n.p,{children:"And it can be all too easy to call the non-safe methods accidentally, giving us\nelusive errors that occur only in production, and never in the development\nenvironment."}),"\n",(0,t.jsx)(n.h2,{id:"solution",children:"Solution"}),"\n",(0,t.jsxs)(n.p,{children:["Our classes will pass the safe methods to the underlying collection unchanged.\nBut if a non-safe method is called, rather than loading the entire set, it adds\na ",(0,t.jsx)(n.code,{children:"LIMIT"})," clause to the query. If the number of results exceeds 500, it gives a\ndeprecation warning. If it exceeds 2000, the classes will throw an exception."]}),"\n",(0,t.jsx)(n.p,{children:"This behavior applies to the following classes:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"RecollectionDecorator"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"CriteriaRecollection"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"AbstractRepository"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"QueryRecollection"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The thresholds can be changed by specifying the options ",(0,t.jsx)(n.code,{children:"$softLimit"})," or\n",(0,t.jsx)(n.code,{children:"$hardLimit"})," in the constructor of the classes that have this behavior."]}),"\n",(0,t.jsxs)(n.p,{children:["The default threshold can be changed by setting static properties\n",(0,t.jsx)(n.code,{children:"$defaultSoftLimit"})," and ",(0,t.jsx)(n.code,{children:"$defaultHardLimit"})," in the ",(0,t.jsx)(n.code,{children:"Configuration"})," class."]}),"\n",(0,t.jsx)(n.h2,{id:"what-to-do-after-the-threshold-is-reached",children:"What to Do After the Threshold is Reached"}),"\n",(0,t.jsx)(n.p,{children:"If you see the warning or exception, it means your code is loading too many\nentities at once, and you need to use a different approach to the problem."}),"\n",(0,t.jsx)(n.p,{children:"To start, you can change your code to use the minimal flavor instead:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Change ",(0,t.jsx)(n.code,{children:"RecollectionDecorator"})," to ",(0,t.jsx)(n.code,{children:"MinimalRecollectionDecorator"})]}),"\n",(0,t.jsxs)(n.li,{children:["Change ",(0,t.jsx)(n.code,{children:"CriteriaRecollection"})," to ",(0,t.jsx)(n.code,{children:"MinimalCriteriaRecollection"})]}),"\n",(0,t.jsxs)(n.li,{children:["Change ",(0,t.jsx)(n.code,{children:"AbstractRepository"})," to ",(0,t.jsx)(n.code,{children:"AbstractMinimalRepository"})]}),"\n",(0,t.jsxs)(n.li,{children:["Change ",(0,t.jsx)(n.code,{children:"QueryRecollection"})," to ",(0,t.jsx)(n.code,{children:"QueryPageable"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These minimal flavors should never trigger full load of the collection."}),"\n",(0,t.jsxs)(n.p,{children:["Then you can run a static analysis tool to find all the places that still call\nthe non-safe methods. You can then refactor the code to use a different\napproach. If you need to iterate over it, read the ",(0,t.jsx)(n.a,{href:"/collections/behaviors/iterator",children:"Iterating Large\nCollections"})," section."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1151:(e,n,o)=>{o.d(n,{Z:()=>r,a:()=>s});var t=o(7294);const i={},l=t.createContext(i);function s(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);