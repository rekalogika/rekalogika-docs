"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[7862],{7250:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>s});var n=t(4848),c=t(8453);const l={title:"Selectable Abstraction"},r=void 0,i={id:"doctrine-collections-decorator/cookbook/selectable-abstraction",title:"Selectable Abstraction",description:"Doctrine ORM uses collection objects that also implement the Selectable",source:"@site/docs/doctrine-collections-decorator/cookbook/13-selectable-abstraction.md",sourceDirName:"doctrine-collections-decorator/cookbook",slug:"/doctrine-collections-decorator/cookbook/selectable-abstraction",permalink:"/doctrine-collections-decorator/cookbook/selectable-abstraction",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/doctrine-collections-decorator/cookbook/13-selectable-abstraction.md",tags:[],version:"current",sidebarPosition:13,frontMatter:{title:"Selectable Abstraction"},sidebar:"docs",previous:{title:"Record Precounting",permalink:"/doctrine-collections-decorator/cookbook/record-precounting"},next:{title:"Decorating Member Objects",permalink:"/doctrine-collections-decorator/cookbook/decorating-members"}},a={},s=[{value:"The Decorator Class",id:"the-decorator-class",level:2},{value:"Usage in the <code>one-to-many</code> Side",id:"usage-in-the-one-to-many-side",level:2},{value:"The Caller Side",id:"the-caller-side",level:2}];function d(e){const o={code:"code",h2:"h2",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(o.p,{children:["Doctrine ORM uses collection objects that also implement the ",(0,n.jsx)(o.code,{children:"Selectable"}),"\ninterface. It gives us the ",(0,n.jsx)(o.code,{children:"matching()"})," method that allows us to filter the\ncollection using a criteria object. It is very powerful and convenient, but also\nan abstraction leak. To use it, the caller needs to know the internal structure\nof the member entity class. Without restraint, the knowledge about the internal\ndetails of a popular class will be spread all over your codebase, and updating\nthe class can potentially become a nightmare."]}),"\n",(0,n.jsxs)(o.p,{children:["To solve the problem, we can decorate the collection object to keep the\n",(0,n.jsx)(o.code,{children:"Selectable"})," interface private and expose more concise, higher-level methods\nthat the caller can use."]}),"\n",(0,n.jsx)(o.h2,{id:"the-decorator-class",children:"The Decorator Class"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-php",children:"use Doctrine\\Common\\Collections\\Collection;\nuse Doctrine\\Common\\Collections\\Criteria;\nuse Doctrine\\Common\\Collections\\Selectable;\nuse Rekalogika\\Collections\\Decorator\\AbstractDecorator\\AbstractCollectionDecorator;\n\n/**\n * @extends AbstractCollectionDecorator<array-key,Book>\n */\nclass BookCollection extends AbstractCollectionDecorator\n{\n    /**\n     * @param Collection<array-key,Book>&Selectable<array-key,Book> $collection\n     */\n    public function __construct(private Collection $collection)\n    {\n        if (!$collection instanceof Selectable) {\n            throw new \\RuntimeException('The wrapped collection must implement the Selectable interface.');\n        }\n    }\n\n    /**\n     * @return Collection<array-key,Book>&Selectable<array-key,Book>\n     */\n    #[\\Override]\n    protected function getWrapped(): Collection&Selectable\n    {\n        return $this->collection;\n    }\n\n    // highlight-start\n    public function findByAuthor(string $author): self\n    {\n        $criteria = Criteria::create()\n            ->where(Criteria::expr()->eq('author', $author));\n\n        $result = $this->getWrapped()->matching($criteria);\n\n        return new self($result);\n    }\n    // highlight-end\n}\n"})}),"\n",(0,n.jsxs)(o.h2,{id:"usage-in-the-one-to-many-side",children:["Usage in the ",(0,n.jsx)(o.code,{children:"one-to-many"})," Side"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-php",children:"use Doctrine\\Common\\Collections\\ArrayCollection;\nuse Doctrine\\Common\\Collections\\Collection;\nuse Doctrine\\ORM\\Mapping as ORM;\n\n#[ORM\\Entity()]\nclass BookShelf\n{\n    /**\n     * @var Collection<array-key,Book>\n     */\n    #[ORM\\OneToMany(targetEntity: Book::class)]\n    private Collection $books;\n\n    public function __construct()\n    {\n        $this->books = new ArrayCollection();\n    }\n\n    public function getBooks(): BookCollection\n    {\n        // highlight-next-line\n        return new BookCollection($this->books);\n    }\n}\n"})}),"\n",(0,n.jsx)(o.h2,{id:"the-caller-side",children:"The Caller Side"}),"\n",(0,n.jsx)(o.p,{children:"Then the caller will be able to do something like this:"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-php",children:"/** @var BookShelf $bookShelf */\n\n$booksByJohnDoe = $bookShelf->getBooks()->findByAuthor('John Doe');\n"})})]})}function h(e={}){const{wrapper:o}={...(0,c.R)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,o,t)=>{t.d(o,{R:()=>r,x:()=>i});var n=t(6540);const c={},l=n.createContext(c);function r(e){const o=n.useContext(l);return n.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function i(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),n.createElement(l.Provider,{value:o},e.children)}}}]);