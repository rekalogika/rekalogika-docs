"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[7522],{7759:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=t(5893),s=t(1151);const o={title:"Basic Usage"},a=void 0,r={id:"domain-event/basic-usage",title:"Basic Usage",description:"Creating Domain Events",source:"@site/docs/domain-event/01-basic-usage.md",sourceDirName:"domain-event",slug:"/domain-event/basic-usage",permalink:"/domain-event/basic-usage",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/domain-event/01-basic-usage.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Basic Usage"},sidebar:"docs",previous:{title:"Introduction & Installation",permalink:"/domain-event/intro"},next:{title:"Manual Control",permalink:"/domain-event/manual-control"}},l={},c=[{value:"Creating Domain Events",id:"creating-domain-events",level:2},{value:"Recording Events",id:"recording-events",level:2},{value:"Listening to Events",id:"listening-to-events",level:2},{value:"Equatable Domain Events",id:"equatable-domain-events",level:2}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"creating-domain-events",children:"Creating Domain Events"}),"\n",(0,i.jsx)(n.p,{children:"Domain events are plain old PHP objects that you create to represent a specific\nevent happening in your domain. There is no particular requirement for these\nclasses."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"// our event superclass for the Post object\n\nabstract class AbstractPostEvent\n{\n    public function __construct(private string $id)\n    {\n    }\n\n    public function getId(): string\n    {\n        return $this->id;\n    }\n}\n\n// our concrete events\n\nfinal class PostCreated extends AbstractPostEvent\n{\n}\n\nfinal class PostChanged extends AbstractPostEvent\n{\n}\n\nfinal class PostRemoved extends AbstractPostEvent\n{\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"recording-events",children:"Recording Events"}),"\n",(0,i.jsxs)(n.p,{children:["Your emitters (entities) must implement ",(0,i.jsx)(n.code,{children:"DomainEventEmitterInterface"}),".\nThere is a ",(0,i.jsx)(n.code,{children:"DomainEventEmitterTrait"})," to help you with that. To record events,\nyou can use the method ",(0,i.jsx)(n.code,{children:"recordEvents()"})," defined in the trait."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Common\\Collections\\ArrayCollection;\nuse Doctrine\\Common\\Collections\\Collection;\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface;\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait;\nuse Symfony\\Component\\Uid\\UuidV7;\n\nclass Post implements DomainEventEmitterInterface\n{\n    use DomainEventEmitterTrait;\n\n    private string $id;\n    private string $title;\n    /** @var Collection<int,Comment> */\n    private Collection $comments;\n\n    public function __construct(string $title)\n    {\n        $this->id = new UuidV7();\n        $this->title = $title;\n        $this->comments = new ArrayCollection();\n\n        // highlight-next-line\n        $this->recordEvent(new PostCreated($this->id));\n    }\n\n    // __remove() is our special method that gets triggered when the entity is\n    // going to be removed from the persistence layer\n    public function __remove()\n    {\n        // highlight-next-line\n        $this->recordEvent(new PostRemoved($this->id));\n    }\n\n    public function setTitle(string $title): void\n    {\n        $this->title = $title;\n\n        // highlight-next-line\n        $this->recordEvent(new PostChanged($this->id));\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"listening-to-events",children:"Listening to Events"}),"\n",(0,i.jsxs)(n.p,{children:["To listen to the events, you can use the usual Symfony way of listening to\nevents. The framework will collect events from persisted entities, and dispatch\nthem at the end of the ",(0,i.jsx)(n.code,{children:"flush()"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener;\n\n#[AsEventListener]\nclass PostEventListener\n{\n    // this method will be invoked after a new Post is persist()-ed & flush()-ed\n    public function __invoke(PostCreated $event) {\n        $postId = $event->getId();\n        // ...\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Alternatively, you can use different attributes to choose a different\ndispatching strategy."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsImmediateDomainEventListener;\nuse Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPostFlushDomainEventListener;\nuse Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPreFlushDomainEventListener;\n\nclass PostEventListener\n{\n    #[AsImmediateDomainEventListener]\n    public function immediate(PostCreated $event) {\n        // this will run immediately after the entity records the event\n    }\n\n    #[AsPreFlushDomainEventListener]\n    public function preFlush(PostCreated $event) {\n        // this will run when you flush() the new post. before the actual\n        // flush()\n    }\n\n    #[AsPostFlushDomainEventListener]\n    public function postFlush(PostCreated $event) {\n        // this will run when you flush() the new post. after the actual\n        // flush()\n    }\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"AsEventListener"})," and ",(0,i.jsx)(n.code,{children:"AsPostFlushDomainEventListener"})," currently have\nidentical behavior, but they utilize different event dispatchers. We plan to\nhave a different event dispatcher behavior with\n",(0,i.jsx)(n.code,{children:"AsPostFlushDomainEventListener"})," while keeping ",(0,i.jsx)(n.code,{children:"AsEventListener"})," standard."]}),"\n",(0,i.jsxs)(n.li,{children:["Doing a ",(0,i.jsx)(n.code,{children:"flush()"})," inside a pre-flush listener is not allowed and will result\nin a ",(0,i.jsx)(n.code,{children:"FlushNotAllowedException"}),"."]}),"\n"]})}),"\n",(0,i.jsx)(n.h2,{id:"equatable-domain-events",children:"Equatable Domain Events"}),"\n",(0,i.jsxs)(n.p,{children:["A domain event can optionally implement ",(0,i.jsx)(n.code,{children:"EquatableDomainEventInterface"})," which\nrequires the method ",(0,i.jsx)(n.code,{children:"getSignature()"}),". Two objects with the same signature will\nbe considered identical by ",(0,i.jsx)(n.code,{children:"DomainEventManager"})," and won't be dispatched twice."]}),"\n",(0,i.jsxs)(n.p,{children:["This is useful if your entity is working with a million of related objects. By\nimplementing ",(0,i.jsx)(n.code,{children:"EquatableDomainEventInterface"}),", you can have your ",(0,i.jsx)(n.code,{children:"ObjectChanged"}),"\nevent dispatched only once and occupy only a single spot in the memory,\ninstead of a million times."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Rekalogika\\Contracts\\DomainEvent\\EquatableDomainEventInterface;\n\nclass PostCommentAdded implements EquatableDomainEventInterface\n{\n    public function __construct(private string $postId)\n    {\n    }\n\n    public function getSignature(): string\n    {\n        return sha1(serialize($this));\n    }\n}\n\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface;\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait;\n\nclass Post implements DomainEventEmitterInterface\n{\n    use DomainEventEmitterTrait;\n\n    // ...\n\n    public function addComment(string $comment): Comment\n    {\n        // ...\n\n        // the PostCommentAdded event will only get dispatched once despite of\n        // addComment being called multiple times.\n        $this->recordEvent(new PostCommentAdded($this->id));\n    }\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Equatable domain events only apply to pre-flush and post-flush events. Immediate\ndomain events are dispatched immediately, and there is no chance for the\nequatable check to take place."})})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>a});var i=t(7294);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);