"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[7199],{886:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var r=a(5893),t=a(1151);const i={title:"Adapters"},o=void 0,s={id:"rekapager/layers/adapters",title:"Adapters",description:"An adapter provides a common interface for different types of underlying data.",source:"@site/docs/rekapager/02-layers/01-adapters.md",sourceDirName:"rekapager/02-layers",slug:"/rekapager/layers/adapters",permalink:"/rekapager/layers/adapters",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/rekapager/02-layers/01-adapters.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Adapters"},sidebar:"docs",previous:{title:"Component Layers",permalink:"/rekapager/layers/"},next:{title:"Pageables and Pages",permalink:"/rekapager/layers/pageable-page"}},l={},d=[{value:"Doctrine ORM <code>QueryBuilder</code> Adapter",id:"doctrine-orm-querybuilder-adapter",level:2},{value:"<code>indexBy</code> Parameter",id:"indexby-parameter",level:3},{value:"Doctrine ORM <code>NativeQuery</code> Adapter",id:"doctrine-orm-nativequery-adapter",level:2},{value:"Doctrine Collections <code>Selectable</code> Adapter",id:"doctrine-collections-selectable-adapter",level:2},{value:"<code>indexBy</code> Parameter",id:"indexby-parameter-1",level:3},{value:"Doctrine Collections <code>Collection</code> Adapter",id:"doctrine-collections-collection-adapter",level:2},{value:"Pagerfanta Adapter Adapter",id:"pagerfanta-adapter-adapter",level:2}];function c(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["An adapter provides a common interface for different types of underlying data.\nThere are two types of adapter interfaces: ",(0,r.jsx)(n.code,{children:"OffsetPaginationAdapterInterface"}),"\nand ",(0,r.jsx)(n.code,{children:"KeysetPaginationAdapterInterface"}),". An adapter implementation can implement\none or both of these interfaces."]}),"\n",(0,r.jsxs)(n.h2,{id:"doctrine-orm-querybuilder-adapter",children:["Doctrine ORM ",(0,r.jsx)(n.code,{children:"QueryBuilder"})," Adapter"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"composer require rekalogika/rekapager-doctrine-orm-adapter\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"QueryBuilderAdapter"})," takes a Doctrine ORM ",(0,r.jsx)(n.code,{children:"QueryBuilder"})," instance. It supports\nkeyset and offset pagination."]}),"\n",(0,r.jsx)(n.p,{children:"With keyset pagination, there are additional prerequisites:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["It must have a sort order. Be sure to call ",(0,r.jsx)(n.code,{children:"orderBy()"})," or ",(0,r.jsx)(n.code,{children:"addOrderBy()"})," on\nthe query builder before passing it to the adapter."]}),"\n",(0,r.jsxs)(n.li,{children:["If a field in a sort order uses a non-scalar type, you should provide a type\nmapping. The adapter will use it in the ",(0,r.jsx)(n.code,{children:"setParameter()"})," method of the\n",(0,r.jsx)(n.code,{children:"QueryBuilder"}),". See the example below."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"If you don't provide a type mapping, the adapter will try to look it up from\nDoctrine's class metadata. If it fails, it will use heuristics to detect the\ntype for some common objects."})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Doctrine\\DBAL\\Types\\Types;\nuse Doctrine\\ORM\\EntityRepository;\nuse Rekalogika\\Rekapager\\Doctrine\\ORM\\QueryBuilderAdapter;\nuse Rekalogika\\Rekapager\\Keyset\\KeysetPageable;\n\n/** @var EntityRepository $postRepository */\n$queryBuilder = $postRepository\n    ->createQueryBuilder('p')\n    ->where('p.group = :group')\n    ->setParameter('group', $group)\n    ->addOrderBy('p.date', 'DESC') // a date field that accepts DateTime\n    ->addOrderBy('p.title', 'ASC')\n    ->addOrderBy('p.id', 'ASC');\n\n// highlight-start\n$adapter = new QueryBuilderAdapter(\n    queryBuilder: $queryBuilder,\n    typeMapping: [\n        'p.date' => Types::DATE_MUTABLE // the type of the date field\n    ],\n    indexBy: 'id' // optional\n);\n// highlight-end\n\n// QueryBuilderAdapter only supports Keyset pagination\n$pageable = new KeysetPageable($adapter);\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"indexby-parameter",children:[(0,r.jsx)(n.code,{children:"indexBy"})," Parameter"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"QueryBuilderAdapter"})," adds items to the end of the ",(0,r.jsx)(n.code,{children:"select"})," clause.\nTherefore, it does not support QueryBuilder's ",(0,r.jsx)(n.code,{children:"indexBy"})," (the third parameter of\n",(0,r.jsx)(n.code,{children:"from()"}),", or the second parameter of a repository's ",(0,r.jsx)(n.code,{children:"createQueryBuilder()"}),")."]}),"\n",(0,r.jsxs)(n.p,{children:["If you need the feature, use the ",(0,r.jsx)(n.code,{children:"indexBy"})," parameter of ",(0,r.jsx)(n.code,{children:"QueryBuilderAdapter"})," as\nthe above example. ",(0,r.jsx)(n.code,{children:"indexBy"})," supports deep addressing by using the dot notation,\ne.g., ",(0,r.jsx)(n.code,{children:"indexBy: 'user.id'"}),"."]}),"\n",(0,r.jsxs)(n.h2,{id:"doctrine-orm-nativequery-adapter",children:["Doctrine ORM ",(0,r.jsx)(n.code,{children:"NativeQuery"})," Adapter"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"composer require rekalogika/rekapager-doctrine-orm-adapter\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"NativeQueryAdapter"})," allows you to use Doctrine's native SQL functionality. It\nsupports only keyset pagination."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Common\\Collections\\Order;\nuse Doctrine\\ORM\\EntityManagerInterface;\nuse Doctrine\\ORM\\Query\\ResultSetMappingBuilder;\nuse Rekalogika\\Rekapager\\Doctrine\\ORM\\NativeQueryAdapter;\nuse Rekalogika\\Rekapager\\Doctrine\\ORM\\Parameter;\nuse Rekalogika\\Rekapager\\Keyset\\KeysetPageable;\n\n/** @var EntityManagerInterface $entityManager */\n\n$resultSetMapping = new ResultSetMappingBuilder($entityManager);\n$resultSetMapping->addRootEntityFromClassMetadata(Post::class, 'p');\n\n$sql = \"\n    SELECT {$resultSetMapping}, {{SELECT}}\n    FROM post p\n    WHERE p.group = :group {{WHERE}}\n    ORDER BY {{ORDER}}\n    LIMIT {{LIMIT}} OFFSET {{OFFSET}}\n\";\n\n$countSql = \"\n    SELECT COUNT(*) AS count\n    FROM (\n        SELECT *\n        FROM post p\n        WHERE p.group = :group {{WHERE}}\n        ORDER BY {{ORDER}}\n        LIMIT {{LIMIT}} OFFSET {{OFFSET}}\n    )\n\";\n\n$countAllSql = \"\n    SELECT COUNT(*) AS count\n    FROM post p\n    WHERE p.set_name = :setName\n\";\n\n$adapter = new NativeQueryAdapter(\n    entityManager: $this->entityManager,\n\n    // The ResultSetMapping or ResultSetMappingBuilder instance\n    resultSetMapping: $resultSetMapping,\n\n    // The SQL query, must contain placeholders for {{SELECT}}, {{WHERE}},\n    // {{ORDER}}, {{LIMIT}}, and {{OFFSET}}\n    sql: $sql,\n\n    // The SQL query for counting records, must contain placeholders for\n    // {{WHERE}}, {{ORDER}}, {{LIMIT}}, and {{OFFSET}}. The count field must\n    // be using the alias 'count'. Optional. If null, the adapter will use $sql\n    // encased in a subquery.\n    countSql: $countSql,\n\n    // The SQL query for counting all records. Optional. If null, total will not\n    // be available.\n    countAllSql: $countAllSql,\n\n    // The ordering must be provided here, not directly in the SQL query.\n    orderBy: [\n        'p.date' => Order::Descending,\n        'p.title' => Order::Ascending,\n        'p.id' => Order::Ascending,\n    ],\n\n    // The parameters for the query.\n    parameters: [\n        new Parameter('group', 'some group'),\n    ],\n\n    // The property of the result that will be used as the index. Optional.\n    indexBy: 'id',\n);\n\n$pageable = new KeysetPageable($adapter);\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"doctrine-collections-selectable-adapter",children:["Doctrine Collections ",(0,r.jsx)(n.code,{children:"Selectable"})," Adapter"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"composer require rekalogika/rekapager-doctrine-collections-adapter\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"SelectableAdapter"})," supports both keyset and offset pagination. The class\nrequires a ",(0,r.jsx)(n.code,{children:"Selectable"})," instance. Usually, it is a Doctrine ",(0,r.jsx)(n.code,{children:"Collection"})," used in\nentities, or a Doctrine repository."]}),"\n",(0,r.jsxs)(n.p,{children:["The class needs to work with a ",(0,r.jsx)(n.code,{children:"Criteria"})," object, but if the caller omits it,\nthe adapter will create an empty ",(0,r.jsx)(n.code,{children:"Criteria"})," object. If the ",(0,r.jsx)(n.code,{children:"Criteria"})," does not\nhave a sort order, the adapter will sort the collection using the field ",(0,r.jsx)(n.code,{children:"id"}),". If\nthe object does not have an ",(0,r.jsx)(n.code,{children:"id"})," field, Doctrine will throw an exception."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Common\\Collections\\Criteria;\nuse Doctrine\\ORM\\EntityRepository;\nuse Rekalogika\\Rekapager\\Doctrine\\Collections\\SelectableAdapter;\nuse Rekalogika\\Rekapager\\Keyset\\KeysetPageable;\nuse Rekalogika\\Rekapager\\Offset\\OffsetPageable;\n\n/** @var EntityRepository $postRepository */\n\n$selectable = $postRepository; // a Doctrine repository is also a Selectable\n// or\n$selectable = $user->getComments(); // a Doctrine Collection in an entity\n\n$criteria = Criteria::create()\n    ->where(Criteria::expr()->eq('group', $group))\n    ->orderBy([\n        'date' => Order::Descending,\n        'title' => Order::Ascending,\n        'id' => Order::Ascending\n    ]);\n\n// highlight-start\n$adapter = new SelectableAdapter(\n    collection: $selectable,\n    criteria: $criteria,\n    indexBy: 'id' // optional\n);\n// highlight-end\n\n$pageable = new KeysetPageable($adapter);\n// or\n$pageable = new OffsetPageable($adapter);\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"indexby-parameter-1",children:[(0,r.jsx)(n.code,{children:"indexBy"})," Parameter"]}),"\n",(0,r.jsxs)(n.p,{children:["There is a Doctrine bug that may prevents a ",(0,r.jsx)(n.code,{children:"matching()"})," call from preserving\nthe keys of the collection. To workaround this issue, add the ",(0,r.jsx)(n.code,{children:"indexBy"}),"\nparameter to the adapter like the example above."]}),"\n",(0,r.jsxs)(n.h2,{id:"doctrine-collections-collection-adapter",children:["Doctrine Collections ",(0,r.jsx)(n.code,{children:"Collection"})," Adapter"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"composer require rekalogika/rekapager-doctrine-collections-adapter\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"CollectionAdapter"})," supports only offset pagination. The class works with a\nDoctrine ",(0,r.jsx)(n.code,{children:"ReadableCollection"})," (also ",(0,r.jsx)(n.code,{children:"Collection"}),") instance."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Common\\Collections\\Collection;\nuse Rekalogika\\Rekapager\\Doctrine\\Collections\\CollectionAdapter;\nuse Rekalogika\\Rekapager\\Offset\\OffsetPageable;\n\n/** @var Collection $collection */\n$collection = $user->getComments(); // a Doctrine Collection in an entity\n\n// highlight-next-line\n$adapter = new CollectionAdapter($collection);\n\n$pageable = new OffsetPageable($adapter);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"pagerfanta-adapter-adapter",children:"Pagerfanta Adapter Adapter"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"composer require rekalogika/rekapager-pagerfanta-adapter\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Allows leveraging any of the existing Pagerfanta adapters. The\n",(0,r.jsx)(n.code,{children:"PagerfantaAdapterAdapter"})," supports only offset pagination. The adapter takes a\nPagerfanta's ",(0,r.jsx)(n.code,{children:"AdapterInterface"})," instance as its argument."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Pagerfanta\\Doctrine\\Collections\\SelectableAdapter;\nuse Rekalogika\\Rekapager\\Offset\\OffsetPageable;\nuse Rekalogika\\Rekapager\\Pagerfanta\\PagerfantaAdapterAdapter;\n\n$criteria = Criteria::create()\n        ->where(Criteria::expr()->eq('group', $group));\n\n$pagerfantaAdapter = new SelectableAdapter($user->getPosts(), $criteria);\n// highlight-next-line\n$adapter = new PagerfantaAdapterAdapter($pagerfantaAdapter);\n\n$pageable = new OffsetPageable($adapter);\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["If you already have a ",(0,r.jsx)(n.code,{children:"Pagerfanta"})," instance, you can use ",(0,r.jsx)(n.code,{children:"PagerfantaPageable"}),"\ninstead."]})})]})}function p(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},1151:(e,n,a)=>{a.d(n,{Z:()=>s,a:()=>o});var r=a(7294);const t={},i=r.createContext(t);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);