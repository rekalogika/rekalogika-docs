"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[1049],{557:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"analytics/summary-entity/partitioning","title":"Partitioning","description":"For performance and to facilitate incremental updates, the summary table is","source":"@site/docs/analytics/02-summary-entity/02-partitioning.md","sourceDirName":"analytics/02-summary-entity","slug":"/analytics/summary-entity/partitioning","permalink":"/analytics/summary-entity/partitioning","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/analytics/02-summary-entity/02-partitioning.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Partitioning"},"sidebar":"docs","previous":{"title":"Summary Class","permalink":"/analytics/summary-entity/summary-class"},"next":{"title":"Dimensions","permalink":"/analytics/summary-entity/dimensions"}}');var r=n(4848),a=n(8453);const s={title:"Partitioning"},o=void 0,l={},c=[{value:"Best Practices, or TLDR;",id:"best-practices-or-tldr",level:2},{value:"Concepts",id:"concepts",level:2},{value:"Available Partitioning Strategies",id:"available-partitioning-strategies",level:2},{value:"<code>DefaultIntegerPartition</code>",id:"defaultintegerpartition",level:3},{value:"<code>UuidV7IntegerPartition</code>",id:"uuidv7integerpartition",level:3},{value:"Custom Integer Partition",id:"custom-integer-partition",level:3},{value:"Custom Non-Integer Partition",id:"custom-non-integer-partition",level:3}];function d(e){const t={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["For performance and to facilitate incremental updates, the summary table is\npartitioned according to the property tagged with the ",(0,r.jsx)(t.code,{children:"#[Analytics\\Partition]"}),"\nattribute. This property must be a Doctrine embeddable that implements\n",(0,r.jsx)(t.code,{children:"Partition"}),"."]}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsx)(t.p,{children:"The partitioning term used here is different from the partitioning term used in\nthe database."})}),"\n",(0,r.jsx)(t.h2,{id:"best-practices-or-tldr",children:"Best Practices, or TLDR;"}),"\n",(0,r.jsx)(t.p,{children:"If the source entity uses an auto-incrementing integer primary key, use this\npartitioning scheme:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-php",children:"use Doctrine\\ORM\\Mapping as ORM;\nuse Rekalogika\\Analytics\\Core\\Metadata as Analytics;\nuse Rekalogika\\Analytics\\Core\\Entity\\BaseSummary;\nuse Rekalogika\\Analytics\\Core\\Partition\\DefaultIntegerPartition;\nuse Rekalogika\\Analytics\\Core\\ValueResolver\\PropertyValue;\n\nclass YourSummary extends BaseSummary\n{\n    // highlight-start\n    #[ORM\\Embedded()]\n    #[Analytics\\Partition(new PropertyValue('id'))]\n    private DefaultIntegerPartition $partition;\n    // highlight-end\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"If your source entity uses UUIDv7 (or ULID) as the primary key, use this\npartitioning scheme:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-php",children:"use Doctrine\\ORM\\Mapping as ORM;\nuse Rekalogika\\Analytics\\Core\\Metadata as Analytics;\nuse Rekalogika\\Analytics\\Core\\Partition\\UuidV7IntegerPartition;\nuse Rekalogika\\Analytics\\Core\\Entity\\BaseSummary;\nuse Rekalogika\\Analytics\\Core\\ValueResolver\\UuidToTruncatedInteger;\n\nclass YourSummary extends BaseSummary\n{\n    // highlight-start\n    #[ORM\\Embedded()]\n    #[Analytics\\Partition(new UuidToTruncatedInteger('id'))]\n    private UuidV7IntegerPartition $partition;\n    // highlight-end\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"concepts",children:"Concepts"}),"\n",(0,r.jsxs)(t.p,{children:["A property of the source entity is designated the ",(0,r.jsx)(t.strong,{children:"partitioning key"}),". The key\nis used to partition the data. The key is usually the primary key of the source\nentity, but not necessarily so. The key must be monotonic, or always increasing,\nbut not necessarily unique. And the key must be permanent, it must not change in\nthe lifetime of the entity."]}),"\n",(0,r.jsxs)(t.p,{children:["Partitioning is divided into ",(0,r.jsx)(t.strong,{children:"levels"}),". Each level consists of multiple\n",(0,r.jsx)(t.strong,{children:"partition"})," of the same length, one after the other. Levels are indicated by a\nnumber. A lower level has a shorter length than a higher level."]}),"\n",(0,r.jsxs)(t.p,{children:["A partition is indicated by the ",(0,r.jsx)(t.strong,{children:"level"})," and the ",(0,r.jsx)(t.strong,{children:"key"}),". A partition of a\nlevel consists of several partitions of the lower level, except the lowermost\nlevel."]}),"\n",(0,r.jsxs)(t.p,{children:["Records from the source entity are grouped by a specific lowest level partition\naccording to the ",(0,r.jsx)(t.strong,{children:"partitioning key"}),", and rolled up into that partition. Then,\neventually, the lowest level accumulates enough partitions, and in turn they are\nrolled up into the next higher level partition. And so on, until the highest\nlevel is reached."]}),"\n",(0,r.jsx)(t.p,{children:"If new source entities are added, they will be rolled up to the newest lowest\nlevel partition, and the framework does not need to reprocess the entire summary\ntable."}),"\n",(0,r.jsx)(t.p,{children:"If changes are detected in the old records, the lowest partition is marked as\ndirty. The framework will reprocess the dirty partition, then mark the higher\nlevel partition as dirty, and so on, until it bubbles up to the highest level.\nAgain, the framework does not need to reprocess the entire summary table."}),"\n",(0,r.jsx)(t.h2,{id:"available-partitioning-strategies",children:"Available Partitioning Strategies"}),"\n",(0,r.jsx)(t.h3,{id:"defaultintegerpartition",children:(0,r.jsx)(t.code,{children:"DefaultIntegerPartition"})}),"\n",(0,r.jsx)(t.p,{children:"Suitable for partitioning auto-incrementing integer primary keys. It partitions\nusing 11, 22, 33, 44, and 55 bits of width. A 11-bit partition aggregates up to\n2048 records."}),"\n",(0,r.jsx)(t.h3,{id:"uuidv7integerpartition",children:(0,r.jsx)(t.code,{children:"UuidV7IntegerPartition"})}),"\n",(0,r.jsxs)(t.p,{children:["Suitable for partitioning UUIDv7 (also ULID) primary keys. It should be coupled\nby a ",(0,r.jsx)(t.code,{children:"UuidToTruncatedInteger"})," value resolver that truncates the 128-bit\nUUID to a 48-bit integer."]}),"\n",(0,r.jsx)(t.p,{children:"UUIDv7 (and ULID) stores the creation time in the first 48 bits. So, the widths\nof each level correspond to the following intervals:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"22 bits: corresponds to 1.165 hour interval"}),"\n",(0,r.jsx)(t.li,{children:"27 bits: corresponds to 1.6 days interval"}),"\n",(0,r.jsx)(t.li,{children:"32 bits: corresponds to 50 days interval"}),"\n",(0,r.jsx)(t.li,{children:"37 bits: corresponds to 4.3 years interval"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"It means the lowest level will contain rolled-up records of those created within\n1.165 hour interval. The second level will contain rolled-up records of those\ncreated within 1.6 days interval, and so on."}),"\n",(0,r.jsx)(t.h3,{id:"custom-integer-partition",children:"Custom Integer Partition"}),"\n",(0,r.jsxs)(t.p,{children:["You can create a custom integer partition by extending ",(0,r.jsx)(t.code,{children:"IntegerPartition"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"custom-non-integer-partition",children:"Custom Non-Integer Partition"}),"\n",(0,r.jsxs)(t.p,{children:["You might be able to create your own non-integer partition by implementing the\n",(0,r.jsx)(t.code,{children:"Partition"})," interface, but currently this is untested and unsupported."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var i=n(6540);const r={},a=i.createContext(r);function s(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);