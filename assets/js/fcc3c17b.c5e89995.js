"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[5683],{5639:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"mapper/object/lazy-loading","title":"Lazy Loading","description":"Mapper will attempt to create a lazy-loading proxy for the target object, and","source":"@site/docs/mapper/02-object/04-lazy-loading.md","sourceDirName":"mapper/02-object","slug":"/mapper/object/lazy-loading","permalink":"/mapper/object/lazy-loading","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/mapper/02-object/04-lazy-loading.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Lazy Loading"},"sidebar":"docs","previous":{"title":"Custom Property Mapper","permalink":"/mapper/object/custom-property-mapper"},"next":{"title":"Dynamic Properties & Property Overloading","permalink":"/mapper/object/dynamic-properties"}}');var a=n(4848),o=n(8453);const r={title:"Lazy Loading"},s=void 0,l={},c=[{value:"Mapping to Doctrine Entities",id:"mapping-to-doctrine-entities",level:2},{value:"API Platform",id:"api-platform",level:2},{value:"Eager Properties",id:"eager-properties",level:2},{value:"PHP 8.4 Lazy Objects",id:"php-84-lazy-objects",level:2},{value:"Disabling Lazy-Loading",id:"disabling-lazy-loading",level:2},{value:"Using <code>MapperOptions</code>",id:"using-mapperoptions",level:3},{value:"Using <code>Eager</code> Attribute",id:"using-eager-attribute",level:3},{value:"Other Ways of Disabling Lazy-Loading",id:"other-ways-of-disabling-lazy-loading",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Mapper will attempt to create a lazy-loading proxy for the target object, and\nuse it in place of the real object. The benefit is that the target object will\nnot be hydrated until it is actually used."}),"\n",(0,a.jsx)(t.p,{children:"If the source object is a Doctrine entity, the mapping will not trigger the\nhydration of the source; even accessing ID properties on the target will also\nnot trigger the hydration. Only after accessing other properties of the target\nwill the hydration take place."}),"\n",(0,a.jsxs)(t.admonition,{type:"warning",children:[(0,a.jsxs)(t.p,{children:["Under PHP < 8.4, if the target is ",(0,a.jsx)(t.code,{children:"final"}),", then lazy-loading is not possible.\nThere are also cases that can prevent a lazy-loading proxy from being created.\nTo see if a proxy is being used, or the reason why it is not, you can see that\nin the Mapper panel in the Symfony profiler."]}),(0,a.jsxs)(t.p,{children:["Under PHP 8.4 and later, Mapper uses native PHP lazy objects, which support\nlazy-loading for ",(0,a.jsx)(t.code,{children:"final"})," classes."]})]}),"\n",(0,a.jsx)(t.h2,{id:"mapping-to-doctrine-entities",children:"Mapping to Doctrine Entities"}),"\n",(0,a.jsxs)(t.p,{children:["Doctrine reads properties using ",(0,a.jsx)(t.code,{children:"Reflection"})," directly, and therefore will not\ntrigger the hydration of our proxy objects. To prevent problems while working\nwith Doctrine entities, Mapper will prevent proxy creation if the target is a\nDoctrine entity."]}),"\n",(0,a.jsx)(t.h2,{id:"api-platform",children:"API Platform"}),"\n",(0,a.jsxs)(t.p,{children:["With API Platform, if you are using DTOs as ",(0,a.jsx)(t.code,{children:"ApiResource"}),", then API Platform\nshould be able to generate IRIs without causing the hydration of the source (if\nthe source is a Doctrine entity). The only thing you need to do is to ensure\nthe source (a Doctrine entity) and the target (an ",(0,a.jsx)(t.code,{children:"ApiResource"})," DTO) both use\nthe same identifier property name. Or better: just use ",(0,a.jsx)(t.code,{children:"id"})," as the identifier\neverywhere, and be done with it."]}),"\n",(0,a.jsx)(t.p,{children:"Without lazy-loading, API Platform will hydrate everything in the object graph,\neven when it only needs to generate an IRI."}),"\n",(0,a.jsx)(t.admonition,{title:"Shameless Plug",type:"info",children:(0,a.jsxs)(t.p,{children:["Read the documentation of ",(0,a.jsx)(t.a,{href:"/api-lite",children:"api-lite"})," to know more about how we\nutilize Mapper with API Platform."]})}),"\n",(0,a.jsx)(t.h2,{id:"eager-properties",children:"Eager Properties"}),"\n",(0,a.jsxs)(t.p,{children:["During the mapping, Mapper will try to identify the identifier properties on the\nsource side. First, it looks for the information in Doctrine's class metadata.\nIf not found, it will use ",(0,a.jsx)(t.code,{children:"id"}),", ",(0,a.jsx)(t.code,{children:"uuid"}),", or ",(0,a.jsx)(t.code,{children:"identifier"})," if any of those exists\non the source side."]}),"\n",(0,a.jsx)(t.p,{children:"These identifier properties will not be lazy, and will be mapped immediately\nafter the instantiation of the target proxy object. This should not cause the\nhydration of the source side because a Doctrine proxy already hold the\nidentifier, even when uninitialized."}),"\n",(0,a.jsxs)(t.p,{children:["If your application needs to have a custom logic for determining the identifier\nfields, you can create a service implementing\n",(0,a.jsx)(t.code,{children:"EagerPropertiesResolverInterface"}),"."]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsx)(t.p,{children:"If an identifier property maps to a constructor argument on the target side,\nthen everything in the constructor will be mapped eagerly."})}),"\n",(0,a.jsx)(t.h2,{id:"php-84-lazy-objects",children:"PHP 8.4 Lazy Objects"}),"\n",(0,a.jsxs)(t.p,{children:["Since Mapper 2.0, if you are using PHP 8.4 or later, Mapper will use native ",(0,a.jsx)(t.a,{href:"https://www.php.net/manual/en/language.oop5.lazy-objects.php",children:"PHP\nlazy objects"}),".\nThere should be no practical difference between the native lazy objects and\nolder ",(0,a.jsx)(t.code,{children:"symfony/var-exporter"})," lazy objects, except that the new mechanism\nsupports ",(0,a.jsx)(t.code,{children:"final"})," classes."]}),"\n",(0,a.jsx)(t.p,{children:"Old-style proxy classes will still be generated during warming up, this is done\nto anticipate the case where the target environment uses different PHP versions."}),"\n",(0,a.jsx)(t.h2,{id:"disabling-lazy-loading",children:"Disabling Lazy-Loading"}),"\n",(0,a.jsx)(t.p,{children:"There should be no downside to using a lazy-loading proxy in place of the real\nobject. In most cases, they should be interchangeable. However, a proxy incurs a\nsmall overhead, and you may wish to disable it in some cases, for example if you\nare using the Mapper in a batch process."}),"\n",(0,a.jsxs)(t.h3,{id:"using-mapperoptions",children:["Using ",(0,a.jsx)(t.code,{children:"MapperOptions"})]}),"\n",(0,a.jsxs)(t.p,{children:["If you want to disable lazy-loading for a mapping run, you can set the option\n",(0,a.jsx)(t.code,{children:"enableLazyLoading"})," to false in the ",(0,a.jsx)(t.code,{children:"MapperOptions"})," object, and add it to the\ncontext:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-php",children:"use Rekalogika\\Mapper\\Context\\Context;\nuse Rekalogika\\Mapper\\Context\\MapperOptions;\n\n$options = new MapperOptions(lazyLoading: false);\n$context = Context::create($options);\n\n$target = $this->mapper->map($source, TargetDto::class, $context);\n"})}),"\n",(0,a.jsxs)(t.h3,{id:"using-eager-attribute",children:["Using ",(0,a.jsx)(t.code,{children:"Eager"})," Attribute"]}),"\n",(0,a.jsxs)(t.p,{children:["To disable proxy creation for a specific class, add the ",(0,a.jsx)(t.code,{children:"#[Eager]"})," attribute to\nthe target class:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-php",children:"use Rekalogika\\Mapper\\Attribute\\Eager;\n\n#[Eager]\nclass TargetDto\n{\n    // ...\n}\n"})}),"\n",(0,a.jsx)(t.h3,{id:"other-ways-of-disabling-lazy-loading",children:"Other Ways of Disabling Lazy-Loading"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"You can instantiate manually, and pass the object as the mapper's target."}),"\n",(0,a.jsxs)(t.li,{children:["You can decorate ",(0,a.jsx)(t.code,{children:"ProxyFactoryInterface"}),", and throw\n",(0,a.jsx)(t.code,{children:"ProxyNotSupportedException"})," if it asks for your specific class. Read\n",(0,a.jsx)(t.code,{children:"DoctrineProxyFactory"})," for an example."]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var i=n(6540);const a={},o=i.createContext(a);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);