"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[7522],{7759:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=t(5893),s=t(1151);const o={title:"Basic Usage"},a=void 0,r={id:"domain-event/basic-usage",title:"Basic Usage",description:"Creating Domain Events",source:"@site/docs/domain-event/01-basic-usage.md",sourceDirName:"domain-event",slug:"/domain-event/basic-usage",permalink:"/domain-event/basic-usage",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/domain-event/01-basic-usage.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Basic Usage"},sidebar:"docs",previous:{title:"Introduction & Installation",permalink:"/domain-event/intro"},next:{title:"Equatable Domain Events",permalink:"/domain-event/equatable"}},l={},c=[{value:"Creating Domain Events",id:"creating-domain-events",level:2},{value:"Recording Events",id:"recording-events",level:2},{value:"Listening to Events",id:"listening-to-events",level:2},{value:"Dispatching the Events",id:"dispatching-the-events",level:2}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"creating-domain-events",children:"Creating Domain Events"}),"\n",(0,i.jsx)(n.p,{children:"Domain events are plain old PHP objects that you create to represent a specific\nevent happening in your domain. There is no particular requirement for these\nclasses."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"// our event superclass for the Post object\n\nabstract class AbstractPostEvent\n{\n    public function __construct(private string $id)\n    {\n    }\n\n    public function getId(): string\n    {\n        return $this->id;\n    }\n}\n\n// our concrete events\n\nfinal class PostCreated extends AbstractPostEvent\n{\n}\n\nfinal class PostChanged extends AbstractPostEvent\n{\n}\n\nfinal class PostRemoved extends AbstractPostEvent\n{\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"recording-events",children:"Recording Events"}),"\n",(0,i.jsxs)(n.p,{children:["Your emitters (entities) must implement ",(0,i.jsx)(n.code,{children:"DomainEventEmitterInterface"}),".\nThere is a ",(0,i.jsx)(n.code,{children:"DomainEventEmitterTrait"})," to help you with that. To record events,\nyou can use the method ",(0,i.jsx)(n.code,{children:"recordEvents()"})," defined in the trait."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Common\\Collections\\ArrayCollection;\nuse Doctrine\\Common\\Collections\\Collection;\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface;\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait;\nuse Symfony\\Component\\Uid\\UuidV7;\n\nclass Post implements DomainEventEmitterInterface\n{\n    use DomainEventEmitterTrait;\n\n    private string $id;\n    private string $title;\n    /** @var Collection<int,Comment> */\n    private Collection $comments;\n\n    public function __construct(string $title)\n    {\n        $this->id = new UuidV7();\n        $this->title = $title;\n        $this->comments = new ArrayCollection();\n\n        // highlight-next-line\n        $this->recordEvent(new PostCreated($this->id));\n    }\n\n    // __remove() is our special method that gets triggered when the entity is\n    // going to be removed from the persistence layer\n    public function __remove()\n    {\n        // highlight-next-line\n        $this->recordEvent(new PostRemoved($this->id));\n    }\n\n    public function setTitle(string $title): void\n    {\n        $this->title = $title;\n\n        // highlight-next-line\n        $this->recordEvent(new PostChanged($this->id));\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"listening-to-events",children:"Listening to Events"}),"\n",(0,i.jsxs)(n.p,{children:["When an entity records the event, the event will be dispatched three times:\nimmediately when it is recorded (immediate strategy), before the ",(0,i.jsx)(n.code,{children:"flush()"})," is\ncalled (pre-flush strategy), and after the ",(0,i.jsx)(n.code,{children:"flush()"})," is called (post-flush\nstrategy)."]}),"\n",(0,i.jsxs)(n.p,{children:["To listen to the events, you can use the usual Symfony way of listening to\nevents. In the following example, the event listener will be invoked after you\ncall ",(0,i.jsx)(n.code,{children:"flush()"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener;\n\n#[AsEventListener]\nclass PostEventListener\n{\n    // this method will be invoked after a new Post is persist()-ed & flush()-ed\n    public function __invoke(PostCreated $event) {\n        $postId = $event->getId();\n        // ...\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Alternatively, you can use different attributes to choose a different\ndispatching strategy."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsImmediateDomainEventListener;\nuse Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPostFlushDomainEventListener;\nuse Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPreFlushDomainEventListener;\n\nclass PostEventListener\n{\n    #[AsImmediateDomainEventListener]\n    public function immediate(PostCreated $event) {\n        // this will be executed immediately after the entity records the event\n    }\n\n    #[AsPreFlushDomainEventListener]\n    public function preFlush(PostCreated $event) {\n        // this will be executed when you flush() the new post. before the actual\n        // flush()\n    }\n\n    #[AsPostFlushDomainEventListener]\n    public function postFlush(PostCreated $event) {\n        // this will be executed when you flush() the new post. after the actual\n        // flush()\n    }\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"AsEventListener"})," and ",(0,i.jsx)(n.code,{children:"AsPostFlushDomainEventListener"})," currently have\nidentical behavior, but they utilize different event dispatchers. We plan to\nhave a different event dispatcher behavior with\n",(0,i.jsx)(n.code,{children:"AsPostFlushDomainEventListener"})," while keeping ",(0,i.jsx)(n.code,{children:"AsEventListener"})," standard."]}),"\n",(0,i.jsxs)(n.li,{children:["Doing a ",(0,i.jsx)(n.code,{children:"flush()"})," inside a pre-flush listener is not allowed and will result\nin a ",(0,i.jsx)(n.code,{children:"FlushNotAllowedException"}),"."]}),"\n"]})}),"\n",(0,i.jsx)(n.h2,{id:"dispatching-the-events",children:"Dispatching the Events"}),"\n",(0,i.jsxs)(n.p,{children:["With pre and post-flush strategy, the actual dispatching of the events is done\nwhen you call ",(0,i.jsx)(n.code,{children:"flush()"})," on the entity manager. It will do the following in\norder:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Collects the events from the entities, and adds them to the pre-flush and\npost-flush queue. Then it dispatches the events in the pre-flush queue."}),"\n",(0,i.jsxs)(n.li,{children:["Calls the actual ",(0,i.jsx)(n.code,{children:"flush()"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Dispatches post-flush events in the queue."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The pre-flush events might generate additional events, in which case they will\nalso be dispatched in the pre-flush phase. It does that until there are no more\nevents to dispatch."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["There is a safeguard in place to prevent infinite loops. If the pre-flush events\nkeep generating more pre-flush events, it will throw a\n",(0,i.jsx)(n.code,{children:"SafeguardTriggeredException"})," after 100 iterations."]})})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>a});var i=t(7294);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);