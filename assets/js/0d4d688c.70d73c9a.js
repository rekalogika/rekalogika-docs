"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[4766],{4160:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>p});const o=JSON.parse('{"id":"mapper/context","title":"Context and Mapping Options","description":"Provide context variables to the mapper to control the mapping process. Or get","source":"@site/docs/mapper/05-context.md","sourceDirName":"mapper","slug":"/mapper/context","permalink":"/mapper/context","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/mapper/05-context.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Context and Mapping Options"},"sidebar":"docs","previous":{"title":"Mapping DateTime","permalink":"/mapper/datetime"},"next":{"title":"Manual Mapping using an Object Mapper","permalink":"/mapper/object-mapper"}}');var r=n(4848),s=n(8453);const a={title:"Context and Mapping Options"},i=void 0,c={},p=[{value:"Context",id:"context",level:2},{value:"Built-in Context Objects",id:"built-in-context-objects",level:2},{value:"Mapper Options",id:"mapper-options",level:2}];function l(e){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Provide context variables to the mapper to control the mapping process. Or get\nsome information about the mapping process."}),"\n",(0,r.jsx)(t.h2,{id:"context",children:"Context"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"Context"})," object stores objects that are used during the mapping process.\nThe caller can provide a ",(0,r.jsx)(t.code,{children:"Context"})," in the ",(0,r.jsx)(t.code,{children:"map()"})," method. If not provided,\nthe mapper will create a new ",(0,r.jsx)(t.code,{children:"Context"})," object internally."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"Context"})," stores objects using class names as keys. Therefore, only one object\nof a given class can be stored in a ",(0,r.jsx)(t.code,{children:"Context"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-php",children:"use Rekalogika\\Mapper\\Context\\Context;\nuse Rekalogika\\Mapper\\MapperInterface;\n\n// Create a context\n$context = Context::create();\n\n// Create a context, initialized with mapper options & a custom object\n$mapperOptions = new MapperOptions(lazyLoading: false);\n$yourCustomObject = new YourCustomObject();\n$context = Context::create($mapperOptions, $yourCustomObject);\n\n// Call map() with the context\n/** @var MapperInterface $mapper */\n$target = $mapper->map($source, TargetObject::class, $context);\n\n// Add an object to the context, note that context is immutable\n$context = $context->with($someObject);\n\n// Remove an object from the context\n$context = $context->without(SomeObject::class);\n\n// Get an object from the context\n$mapperOptions = $context->get(MapperOptions::class);\n// or\n$mapperOptions = $context(MapperOptions::class);\n\n// Iterates over all objects in the context\nforeach ($context as $object) {\n    // ...\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"Context"})," is available in most of the places where you write code to\ncustomize the mapping process."]}),"\n",(0,r.jsx)(t.h2,{id:"built-in-context-objects",children:"Built-in Context Objects"}),"\n",(0,r.jsx)(t.p,{children:"The following context objects are provided by Mapper:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"MapperOptions"}),": Options for the mapping process."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"ObjectCache"}),": Used to store objects that have already been mapped. It is\nused to handle circular references and to prevent infinite loops."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Path"}),": Stores the mapping path. Used for tracing and creating meaningful\nerror messages."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"NormalizerContext"})," and ",(0,r.jsx)(t.code,{children:"DenormalizerContext"}),": Used to store the context\nthat will be used by Symfony Serializer."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"SourcePropertyAttributes"}),": The attributes of the source property."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"TargetPropertyAttributes"}),": The attributes of the target property."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"SourceClassAttributes"}),": The attributes of the source class."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"TargetClassAttributes"}),": The attributes of the target class."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"mapper-options",children:"Mapper Options"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"MapperOptions"})," object is passed by the caller to provide options for the\nmapping process. The following options are available:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"lazyLoading"}),": Enable lazy-loading."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"readTargetValue"}),": If true, the mapper will get the existing value from the\ntarget. If exists, it will be used as the target. If false, the mapper will\nalways create a new target object."]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var o=n(6540);const r={},s=o.createContext(r);function a(e){const t=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:t},e.children)}}}]);