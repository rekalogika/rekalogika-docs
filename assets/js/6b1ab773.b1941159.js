"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[434],{5439:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>s});const t=JSON.parse('{"id":"doctrine-collections-decorator/cookbook/lazy-chained-matching","title":"Lazy Chained Matching","description":"If you call matching() on a PersistentCollection, it will immediately query","source":"@site/docs/doctrine-collections-decorator/cookbook/16-lazy-chained-matching.md","sourceDirName":"doctrine-collections-decorator/cookbook","slug":"/doctrine-collections-decorator/cookbook/lazy-chained-matching","permalink":"/doctrine-collections-decorator/cookbook/lazy-chained-matching","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/doctrine-collections-decorator/cookbook/16-lazy-chained-matching.md","tags":[],"version":"current","sidebarPosition":16,"frontMatter":{"title":"Lazy Chained Matching"},"sidebar":"docs","previous":{"title":"Loading Prevention in Extra Lazy Collections","permalink":"/doctrine-collections-decorator/cookbook/extra-lazy-load-prevention"},"next":{"title":"rekalogika/domain-event","permalink":"/domain-event/"}}');var i=o(4848),c=o(8453);const l={title:"Lazy Chained Matching"},a=void 0,r={},s=[{value:"The Decorator Class",id:"the-decorator-class",level:2},{value:"Usage Example in Entities",id:"usage-example-in-entities",level:2},{value:"The Caller Side",id:"the-caller-side",level:2}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["If you call ",(0,i.jsx)(n.code,{children:"matching()"})," on a ",(0,i.jsx)(n.code,{children:"PersistentCollection"}),", it will immediately query\nthe database and return the result, even if you won't use the result. If you\ncall ",(0,i.jsx)(n.code,{children:"matching()"})," again on the result, it will be processed from the in-memory\n",(0,i.jsx)(n.code,{children:"ArrayCollection"}),", not from the database."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["With ",(0,i.jsx)(n.code,{children:"EXTRA_LAZY"})," fetch mode, ",(0,i.jsx)(n.code,{children:"PersistentCollection"})," will return a\n",(0,i.jsx)(n.code,{children:"LazyCriteriaCollection"}),". But subsequent ",(0,i.jsx)(n.code,{children:"matching()"})," call on the result\nwill still be processed immediately."]})}),"\n",(0,i.jsxs)(n.p,{children:["We can decorate the collection so that chained-",(0,i.jsx)(n.code,{children:"matching()"})," will be done lazily.\nThe database query will only be done when the caller asks for the result.\nCalling ",(0,i.jsx)(n.code,{children:"matching()"})," will only merge the supplied criteria to the existing\ncriteria."]}),"\n",(0,i.jsxs)(n.p,{children:["With the standard behavior, the following code will do the processing three\ntimes (twice with ",(0,i.jsx)(n.code,{children:"EXTRA_LAZY"}),"). With our decorator, it will only be done once\nwhen ",(0,i.jsx)(n.code,{children:"foreach"})," is called."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"/** @var Collection<array-key,mixed> $collection */\n/** @var Criteria $criteria1 */\n/** @var Criteria $criteria2 */\n/** @var Criteria $criteria3 */\n\n$result = $collection\n    ->matching($criteria1)\n    ->matching($criteria2)\n    ->matching($criteria3);\n\nforeach ($result as $item) {\n    // ...\n} \n"})}),"\n",(0,i.jsx)(n.h2,{id:"the-decorator-class",children:"The Decorator Class"}),"\n",(0,i.jsxs)(n.p,{children:["This package already comes with ",(0,i.jsx)(n.code,{children:"LazyMatchingCollection"})," that you can use for\nthis purpose."]}),"\n",(0,i.jsx)(n.h2,{id:"usage-example-in-entities",children:"Usage Example in Entities"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Common\\Collections\\Collection;\nuse Doctrine\\ORM\\Mapping as ORM;\nuse Rekalogika\\Collections\\Decorator\\LazyMatching\\LazyMatchingCollection;\n\n#[ORM\\Entity()]\nclass BookShelf\n{\n    #[ORM\\OneToMany(targetEntity: Book::class, fetch: 'EXTRA_LAZY', indexBy: 'id')]\n    private Collection $books;\n\n    public function __construct()\n    {\n        $this->books = new ArrayCollection();\n    }\n\n    /**\n     * @return Collection<array-key,Book>&Selectable<array-key,Book>\n     */\n    public function getBooks(): Collection&Selectable\n    {\n        // highlight-next-line\n        return new LazyMatchingCollection($this->books);\n    }\n\n    public function getScienceBooks(): Collection\n    {\n        return $this->getBooks()->matching(\n            Criteria::create()\n                ->where(Criteria::expr()->eq('genre', 'science'))\n        );\n    }\n\n    public function getOldScienceBooks(): Collection\n    {\n        return $this->getScienceBook()->matching(\n            Criteria::create()\n                ->where(Criteria::expr()->lt('publishedAt', new \\DateTime('-10 years')))\n        );\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"the-caller-side",children:"The Caller Side"}),"\n",(0,i.jsx)(n.p,{children:"Then the caller will be able to do something like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"$bookShelf = $entityManager->find(BookShelf::class, 1);\n\n$oldScienceBook = $bookShelf->getOldScienceBook();\n\nforeach ($oldScienceBook as $book) {\n    echo $book->getTitle();\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["With this example, there will be only two database queries, one due to\n",(0,i.jsx)(n.code,{children:"$entityManager->find()"}),", and one due to the ",(0,i.jsx)(n.code,{children:"foreach"})," call."]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>l,x:()=>a});var t=o(6540);const i={},c=t.createContext(i);function l(e){const n=t.useContext(c);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);