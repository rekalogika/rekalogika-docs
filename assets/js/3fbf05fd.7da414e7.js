"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[8667],{2064:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"file-bundle/file-location/overriding","title":"Overriding the Algorithm","description":"There are services that you can override to change the way the framework","source":"@site/docs/file-bundle/17-file-location/02-overriding.md","sourceDirName":"file-bundle/17-file-location","slug":"/file-bundle/file-location/overriding","permalink":"/file-bundle/file-location/overriding","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/file-bundle/17-file-location/02-overriding.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Overriding the Algorithm"},"sidebar":"docs","previous":{"title":"Where The Files Are Stored","permalink":"/file-bundle/file-location/file-location"},"next":{"title":"Renaming Class","permalink":"/file-bundle/file-location/renaming-class"}}');var s=i(4848),o=i(8453);const r={title:"Overriding the Algorithm"},a=void 0,l={},c=[{value:"File Location Resolver",id:"file-location-resolver",level:2},{value:"Object ID Resolver",id:"object-id-resolver",level:2},{value:"Class Signature Resolver",id:"class-signature-resolver",level:2},{value:"Manual Service Configuration",id:"manual-service-configuration",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"There are services that you can override to change the way the framework\ndetermines where to store the files. The default implementation is usually\nsufficient, but you can override it if you need to."}),"\n",(0,s.jsx)(n.h2,{id:"file-location-resolver",children:"File Location Resolver"}),"\n",(0,s.jsxs)(n.p,{children:["To override the general algorithm that determines where to store the files, you\ncan create your own implementation of ",(0,s.jsx)(n.code,{children:"ClassBasedFileLocationResolverInterface"}),".\nIt takes the class name of the object, the ID, and the property name; then\nreturns a ",(0,s.jsx)(n.code,{children:"FilePointerInterface"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For an example, see the class ",(0,s.jsx)(n.code,{children:"DefaultClassBasedFileLocationResolver"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"object-id-resolver",children:"Object ID Resolver"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ClassBasedFileLocationResolverInterface"})," takes the object's ID as a string. To\ndetermine the ID, the framework uses ",(0,s.jsx)(n.code,{children:"ObjectIdResolverInterface"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["You can create an ",(0,s.jsx)(n.code,{children:"ObjectIdResolverInterface"})," if you need to override how the\nframework obtains an object's identifier. This is usually only necessary if your\nobject's ID cannot be serialized to string, which should never happen in\npractice."]}),"\n",(0,s.jsx)(n.h2,{id:"class-signature-resolver",children:"Class Signature Resolver"}),"\n",(0,s.jsxs)(n.p,{children:["The framework calls ",(0,s.jsx)(n.code,{children:"ClassSignatureResolverInterface"})," to convert the class name\ninto its signature. This is done so that the class name does not appear in the\nfile path. The default implementation is ",(0,s.jsx)(n.code,{children:"DefaultClassSignatureResolver"})," which\nconverts the class name into its SHA-1 hash."]}),"\n",(0,s.jsxs)(n.p,{children:["Also available is ",(0,s.jsx)(n.code,{children:"AttributeClassSignatureResolver"}),", it looks for the\n",(0,s.jsx)(n.code,{children:"WithFileAssociation"})," attribute on the class and uses the value of its argument\nas the class signature. This is useful if you are renaming a class as it would\nresult in a different SHA-1 hash, and the framework would not be able to find\npreviously stored files."]}),"\n",(0,s.jsx)(n.h2,{id:"manual-service-configuration",children:"Manual Service Configuration"}),"\n",(0,s.jsx)(n.p,{children:"If you are not using autoconfiguration, you have to tag the services you created\nin the service container. Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"services:\n    App\\MyClassBasedFileLocationResolver:\n        tags:\n            - { name: 'rekalogika.file.association.class_based_file_location_resolver' }\n\n    App\\MyObjectIdResolver:\n        tags:\n            - { name: 'rekalogika.file.association.object_id_resolver' }\n\n    App\\MyClassSignatureResolver:\n        tags:\n            - { name: 'rekalogika.file.association.class_signature_resolver' }\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);