"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[1151],{8167:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>c,toc:()=>p});var n=a(4848),s=a(8453);const r={title:"Mapping to Abstract Classes and Interfaces"},o=void 0,c={id:"mapper/object/abstract-interface",title:"Mapping to Abstract Classes and Interfaces",description:"To map to an abstract class or an interface, you can add the attribute",source:"@site/docs/mapper/02-object/02-abstract-interface.md",sourceDirName:"mapper/02-object",slug:"/mapper/object/abstract-interface",permalink:"/mapper/object/abstract-interface",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/mapper/02-object/02-abstract-interface.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Mapping to Abstract Classes and Interfaces"},sidebar:"docs",previous:{title:"Changing the Mapping Behavior with the Map Attribute",permalink:"/mapper/object/map"},next:{title:"Custom Property Mapper",permalink:"/mapper/object/custom-property-mapper"}},i={},p=[];function l(e){const t={admonition:"admonition",code:"code",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["To map to an abstract class or an interface, you can add the attribute\n",(0,n.jsx)(t.code,{children:"InheritanceMap"})," to specify the concrete class the mapper will map to. For\nexample:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-php",children:"use Rekalogika\\Mapper\\Attribute\\InheritanceMap;\nuse Rekalogika\\Mapper\\Tests\\Fixtures\\Inheritance\\ConcreteClassA;\nuse Rekalogika\\Mapper\\Tests\\Fixtures\\Inheritance\\ConcreteClassB;\n\n#[InheritanceMap([\n    ConcreteClassA::class => ConcreteClassADto::class,\n    ConcreteClassB::class => ConcreteClassBDto::class,\n    ConcreteClassB::class => ConcreteClassCDto::class,\n])]\nabstract class AbstractClassDto\n{\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In the above example, the mapper will map the source to ",(0,n.jsx)(t.code,{children:"ConcreteClassADto"})," if\nthe source is an instance of ",(0,n.jsx)(t.code,{children:"ConcreteClassA"}),", and so on."]}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"This only applies if there is no a preexisting object on the target side. If\nthere is already an object on the target side, Mapper will map to that object\ninstead."})}),"\n",(0,n.jsx)(t.admonition,{title:"Protip",type:"tip",children:(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"#[InheritanceMap]"})," is bidirectional. If Mapper encounters the attribute on\nthe source side, it will flip the mapping, so the same attribute above will also\nwork in reverse."]})})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>o,x:()=>c});var n=a(6540);const s={},r=n.createContext(s);function o(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);