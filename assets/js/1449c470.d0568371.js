"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[5493],{7963:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"domain-event/basic-usage","title":"Basic Usage","description":"You make your entities record events happening in your domain. This library","source":"@site/docs/domain-event/02-basic-usage.md","sourceDirName":"domain-event","slug":"/domain-event/basic-usage","permalink":"/domain-event/basic-usage","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/domain-event/02-basic-usage.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Basic Usage"},"sidebar":"docs","previous":{"title":"Outbox Installation & Configuration","permalink":"/domain-event/outbox-setup"},"next":{"title":"Pseudo Magic Method","permalink":"/domain-event/pseudo-magic-method"}}');var s=t(4848),o=t(8453);const a={title:"Basic Usage"},r=void 0,l={},h=[{value:"Creating Domain Events",id:"creating-domain-events",level:2},{value:"Recording Events",id:"recording-events",level:2},{value:"Listening to Events",id:"listening-to-events",level:2},{value:"Dispatching the Events",id:"dispatching-the-events",level:2}];function c(e){const n={admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"You make your entities record events happening in your domain. This library\ndispatches each of the events up to four times in different phases. Your\nlistener chooses which event to listen, and where to listen to."}),"\n",(0,s.jsx)(n.h2,{id:"creating-domain-events",children:"Creating Domain Events"}),"\n",(0,s.jsx)(n.p,{children:"Domain events are plain old PHP objects that you create to represent a specific\nevent happening in your domain. There is no particular requirement for these\nclasses, except they should be serializable. For event bus dispatching, they\nmust be serializable."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"// our event superclass for the Post object\n\nabstract class AbstractPostEvent\n{\n    public function __construct(private string $id)\n    {\n    }\n\n    public function getId(): string\n    {\n        return $this->id;\n    }\n}\n\n// our concrete events\n\nfinal class PostCreated extends AbstractPostEvent\n{\n}\n\nfinal class PostChanged extends AbstractPostEvent\n{\n}\n\nfinal class PostRemoved extends AbstractPostEvent\n{\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"recording-events",children:"Recording Events"}),"\n",(0,s.jsxs)(n.p,{children:["Your emitters (entities) must implement ",(0,s.jsx)(n.code,{children:"DomainEventEmitterInterface"}),".\nThere is a ",(0,s.jsx)(n.code,{children:"DomainEventEmitterTrait"})," to help you with that. To record events,\nyou can use the method ",(0,s.jsx)(n.code,{children:"recordEvents()"})," defined in the trait."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Common\\Collections\\ArrayCollection;\nuse Doctrine\\Common\\Collections\\Collection;\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface;\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait;\nuse Symfony\\Component\\Uid\\UuidV7;\n\nclass Post implements DomainEventEmitterInterface\n{\n    use DomainEventEmitterTrait;\n\n    private string $id;\n    private string $title;\n    /** @var Collection<int,Comment> */\n    private Collection $comments;\n\n    public function __construct(string $title)\n    {\n        $this->id = new UuidV7();\n        $this->title = $title;\n        $this->comments = new ArrayCollection();\n\n        // highlight-next-line\n        $this->recordEvent(new PostCreated($this->id));\n    }\n\n    // __remove() is our pseudo magic method that gets triggered when the entity\n    // is about to be removed from the persistence layer\n    public function __remove()\n    {\n        // highlight-next-line\n        $this->recordEvent(new PostRemoved($this->id));\n    }\n\n    public function setTitle(string $title): void\n    {\n        $this->title = $title;\n\n        // highlight-next-line\n        $this->recordEvent(new PostChanged($this->id));\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"listening-to-events",children:"Listening to Events"}),"\n",(0,s.jsxs)(n.p,{children:["When an entity records the event, the event will be dispatched up to four times:\nimmediately when it is recorded (immediate strategy), before the ",(0,s.jsx)(n.code,{children:"flush()"})," is\ncalled (pre-flush strategy), and after the ",(0,s.jsx)(n.code,{children:"flush()"})," is called (post-flush\nstrategy). Additionally, with the optional ",(0,s.jsx)(n.code,{children:"rekalogika/domain-event-outbox"}),"\npackage, the event will be published on an event bus."]}),"\n",(0,s.jsxs)(n.p,{children:["To listen to the events, you can use the usual Symfony way of listening to\nevents, where the event listener will be invoked after you call ",(0,s.jsx)(n.code,{children:"flush()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"use Symfony\\Component\\EventDispatcher\\Attribute\\AsEventListener;\n\n#[AsEventListener]\nclass PostEventListener\n{\n    // this method will be invoked after a new Post is persist()-ed & flush()-ed\n    public function __invoke(PostCreated $event) {\n        $postId = $event->getId();\n        // ...\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"To choose different dispatching strategy, you can use different attributes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"use Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsImmediateDomainEventListener;\nuse Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPostFlushDomainEventListener;\nuse Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPreFlushDomainEventListener;\nuse Rekalogika\\Contracts\\DomainEvent\\Attribute\\AsPublishedDomainEventListener;\n\nclass PostEventListener\n{\n    #[AsImmediateDomainEventListener]\n    public function immediate(PostCreated $event) {\n        // this will be executed immediately after the entity records the event\n    }\n\n    #[AsPreFlushDomainEventListener]\n    public function preFlush(PostCreated $event) {\n        // this will be executed when you flush() the new post. before the actual\n        // flush()\n    }\n\n    #[AsPostFlushDomainEventListener]\n    public function postFlush(PostCreated $event) {\n        // this will be executed when you flush() the new post. after the actual\n        // flush()\n    }\n\n    #[AsPublishedDomainEventListener]\n    public function eventBus(PostCreated $event) {\n        // the event will be published on the event bus, and this method will\n        // be executed when the event is consumed from the bus\n    }\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AsEventListener"})," and ",(0,s.jsx)(n.code,{children:"AsPostFlushDomainEventListener"})," currently have\nidentical behavior, but they utilize different event dispatchers. We plan to\nhave a different event dispatcher behavior with\n",(0,s.jsx)(n.code,{children:"AsPostFlushDomainEventListener"})," while keeping ",(0,s.jsx)(n.code,{children:"AsEventListener"})," standard."]}),"\n",(0,s.jsxs)(n.li,{children:["Doing a ",(0,s.jsx)(n.code,{children:"flush()"})," inside a pre-flush listener is not allowed and will result\nin a ",(0,s.jsx)(n.code,{children:"FlushNotAllowedException"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AsPublishedDomainEventListener"})," requires the optional\n",(0,s.jsx)(n.code,{children:"rekalogika/domain-event-outbox"})," package."]}),"\n"]})}),"\n",(0,s.jsx)(n.h2,{id:"dispatching-the-events",children:"Dispatching the Events"}),"\n",(0,s.jsxs)(n.p,{children:["With pre and post-flush strategy, the actual dispatching of the events is done\nwhen you call ",(0,s.jsx)(n.code,{children:"flush()"})," on the entity manager. It will do the following in\norder:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Collects the events from the entities, and adds them to the pre-flush and\npost-flush queue. Then it dispatches the events in the pre-flush queue."}),"\n",(0,s.jsxs)(n.li,{children:["Calls the actual ",(0,s.jsx)(n.code,{children:"flush()"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Dispatches post-flush events in the queue."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The pre-flush events might generate additional events, in which case they will\nalso be dispatched in the pre-flush phase. It does that until there are no more\nevents to dispatch."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["There is a safeguard in place to prevent infinite loops. If the pre-flush events\nkeep generating more pre-flush events, it will throw a\n",(0,s.jsx)(n.code,{children:"SafeguardTriggeredException"})," after 100 iterations."]})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"AsPublishedDomainEventListener"})," strategy works by adding the events to the\noutbox table in the same phase as the pre-flush strategy. Then the message relay\nreads the table, and publishes the events to the event bus."]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(6540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);