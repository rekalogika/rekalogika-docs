"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[3485],{3980:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var t=i(5893),s=i(1151);const o={title:"Key Type Widening"},r=void 0,c={id:"collections/behaviors/key-type-widening",title:"Key Type Widening",description:"Problem",source:"@site/docs/collections/03-behaviors/05-key-type-widening.md",sourceDirName:"collections/03-behaviors",slug:"/collections/behaviors/key-type-widening",permalink:"/collections/behaviors/key-type-widening",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/collections/03-behaviors/05-key-type-widening.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Key Type Widening"},sidebar:"docs",previous:{title:"Selectable Abstraction Leak",permalink:"/collections/behaviors/selectable-leak"},next:{title:"Miscellaneous",permalink:"/collections/misc"}},l={},d=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2}];function a(e){const n={admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"problem",children:"Problem"}),"\n",(0,t.jsxs)(n.admonition,{type:"warning",children:[(0,t.jsxs)(n.p,{children:["Previously, this feature is used to convert UUID objects to string before it is\nused as a key in a ",(0,t.jsx)(n.code,{children:"Collection"}),". Unfortunately, we found out afterward that\nDoctrine's behavior regarding UUID keys is undefined and inconsistent. For\nexample, UUID primary keys is converted into 8-4-4-4-12 format with PostgreSQL,\nbut become binary strings with SQLite."]}),(0,t.jsx)(n.p,{children:"We retain this feature because there are other benefits to it."})]}),"\n",(0,t.jsxs)(n.p,{children:["The keys in Doctrine ",(0,t.jsx)(n.code,{children:"Collection"})," can only be ",(0,t.jsx)(n.code,{children:"int|string"}),". On the other\nhand, Doctrine supports objects, like UUIDs, as primary keys. Therefore, callers\nneed to convert objects to the expected string format before using them as keys\nin a ",(0,t.jsx)(n.code,{children:"Collection"}),", especially if ",(0,t.jsx)(n.code,{children:"strict_types"})," is enabled."]}),"\n",(0,t.jsx)(n.p,{children:"In some cases, passing UUIDs in the wrong format will give us 500 errors because\nthe database doesn't like it. They should be 404 errors instead."}),"\n",(0,t.jsxs)(n.p,{children:["In some cases, the caller cannot know the type of the key, and must perform type\nchecking to ensure it is ",(0,t.jsx)(n.code,{children:"int|string"})," before using it in a ",(0,t.jsx)(n.code,{children:"Collection"}),". This\nresult in unnecessary boilerplate code."]}),"\n",(0,t.jsx)(n.h2,{id:"solution",children:"Solution"}),"\n",(0,t.jsxs)(n.p,{children:["Our interfaces extends ",(0,t.jsx)(n.code,{children:"Collection"})," and overrides the following methods to widen\nthe key type to ",(0,t.jsx)(n.code,{children:"mixed"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"containsKey($key)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"get($key)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"remove($key)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"set($key, $value)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"offsetExists($key)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"offsetGet($key)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"offsetSet($key, $value)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"offsetUnset($key)"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Then, the object is converted to string and passed to the underlying\n",(0,t.jsx)(n.code,{children:"Collection"}),". If it is not possible, our classes will throw an exception, which\nwill become a 404 error."]}),"\n",(0,t.jsxs)(n.p,{children:["The above is the default behavior as defined in ",(0,t.jsx)(n.code,{children:"DefaultKeyTransformer"}),". The\nbehavior can be changed using the argument ",(0,t.jsx)(n.code,{children:"$keyTransformer"})," in any of our\nclasses. The default behavior can be changed by setting\n",(0,t.jsx)(n.code,{children:"Configuration::$defaultKeyTransformer"}),". A new behavior can be created by\nimplementing the ",(0,t.jsx)(n.code,{children:"KeyTransformer"})," interface."]}),"\n",(0,t.jsxs)(n.p,{children:["Other than ",(0,t.jsx)(n.code,{children:"DefaultKeyTransformer"}),", the library also ships with\n",(0,t.jsx)(n.code,{children:"UuidKeyTransformer"}),". It ensures the input is in the correct UUID format before\npassing it to the underlying ",(0,t.jsx)(n.code,{children:"Collection"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>c,a:()=>r});var t=i(7294);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);