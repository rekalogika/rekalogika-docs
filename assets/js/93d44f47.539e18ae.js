"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[6182],{7141:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>g,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"rekapager/usage","title":"Installation and Usage","description":"Installation checklist:","source":"@site/docs/rekapager/01-usage.md","sourceDirName":"rekapager","slug":"/rekapager/usage","permalink":"/rekapager/usage","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/rekapager/01-usage.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Installation and Usage"},"sidebar":"docs","previous":{"title":"Introduction","permalink":"/rekapager/intro"},"next":{"title":"Adapters","permalink":"/rekapager/adapters/"}}');var r=a(4848),i=a(8453);const o={title:"Installation and Usage"},s=void 0,l={},c=[{value:"Transforming the underlying data into a <code>PageableInterface</code> object",id:"transforming-the-underlying-data-into-a-pageableinterface-object",level:2},{value:"Transforming the <code>PageableInterface</code> into a <code>PagerInterface</code> object",id:"transforming-the-pageableinterface-into-a-pagerinterface-object",level:2},{value:"Rendering the Pager",id:"rendering-the-pager",level:2},{value:"Batch Processing",id:"batch-processing",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Installation checklist:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"adapters",children:"Install one or more adapters"})," for the data types that you are\nusing."]}),"\n",(0,r.jsxs)(n.li,{children:["Install the integration package for the framework you are using. Currently,\nthere are ",(0,r.jsx)(n.a,{href:"/rekapager/framework-integration/symfony",children:"Symfony integration"})," and\n",(0,r.jsx)(n.a,{href:"/rekapager/framework-integration/api-platform",children:"API Platform integration"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{title:"Protip",type:"tip",children:(0,r.jsx)(n.p,{children:"If you are using this library only for batch processing, then installing only\nthe adapters you need is sufficient."})}),"\n",(0,r.jsxs)(n.h2,{id:"transforming-the-underlying-data-into-a-pageableinterface-object",children:["Transforming the underlying data into a ",(0,r.jsx)(n.code,{children:"PageableInterface"})," object"]}),"\n",(0,r.jsx)(n.p,{children:"This part is framework-independent."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Doctrine\\DBAL\\Types\\Types;\nuse Doctrine\\ORM\\EntityRepository;\nuse Rekalogika\\Rekapager\\Doctrine\\ORM\\QueryBuilderAdapter;\nuse Rekalogika\\Rekapager\\Keyset\\KeysetPageable;\nuse Rekalogika\\Rekapager\\Offset\\OffsetPageable;\n\n// The underlying data in this example is a Doctrine ORM QueryBuilder\n\n/** @var EntityRepository $postRepository */\n\n$queryBuilder = $postRepository\n    ->createQueryBuilder('p')\n    ->where('p.group = :group')\n    ->setParameter('group', $group)\n    ->addOrderBy('p.date', 'DESC')\n    ->addOrderBy('p.title', 'ASC')\n    ->addOrderBy('p.id', 'ASC');\n\n// The adapter provides an uniform interface for the different types of\n// underlying data collection\n\n$adapter = new QueryBuilderAdapter(\n    queryBuilder: $queryBuilder,\n    typeMapping: [\n        'p.date' => Types::DATE_MUTABLE\n    ]\n),\n\n// A pageable represents something that can be partitioned into pages. This\n// example uses KeysetPageable, which is a pageable that supports keyset\n// pagination.\n\n$pageable = new KeysetPageable(\n    adapter: $adapter,\n    itemsPerPage: $itemsPerPage,\n    count: $count,\n);\n\n// There is also an OffsetPageable for offset pagination. An adapter can\n// support either or both types of pagination.\n\n$pageable = new OffsetPageable(\n    adapter: $adapter,\n    itemsPerPage: $itemsPerPage,\n    count: $count,\n);\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"transforming-the-pageableinterface-into-a-pagerinterface-object",children:["Transforming the ",(0,r.jsx)(n.code,{children:"PageableInterface"})," into a ",(0,r.jsx)(n.code,{children:"PagerInterface"})," object"]}),"\n",(0,r.jsxs)(n.p,{children:["In this phase, we start involving the framework used in the application. The\nexample below uses Symfony integration provided by\n",(0,r.jsx)(n.code,{children:"rekalogika/rekapager-bundle"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Rekalogika\\Rekapager\\Bundle\\Contracts\\PagerFactoryInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\n\n/** @var PagerFactoryInterface $pagerFactory */\n/** @var Request $request */\n\n// The pager factory is a service that creates a PagerInterface from a\n// PageableInterface\n\n$pager = $pagerFactory->createFromPageable(\n    pageable: $pageable,\n    request: $request,\n    options: new PagerOptions(\n        proximity: 3,\n    )\n);\n\n$currentPage = $pager->getCurrentPage();\n\nforeach ($currentPage as $item) {\n    // Do something with the item\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"rendering-the-pager",children:"Rendering the Pager"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"PagerInterface"})," object contains all the necessary information to render the\npagination control in the user interface. The example below uses the Twig\nintegration provided by ",(0,r.jsx)(n.code,{children:"rekalogika/rekapager-bundle"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-twig",children:"{# Outputs the item from the current page #}\n\n<table class=\"table\">\n    <thead>\n        <tr>\n            <th>ID</th>\n            <th>Title</th>\n            <th>Date</th>\n            <th>Content</th>\n        </tr>\n    </thead>\n    // highlight-next-line\n    <tbody {{ rekapager_infinite_scrolling_content() }}>\n        {% for post in pager.currentPage %}\n            <tr>\n                <td>{{ post.id }}</td>\n                <td>{{ post.title }}</td>\n                <td>{{ post.date|date('Y-m-d') }}</td>\n                <td>{{ post.content }}</td>\n            </tr>\n        {% endfor %}\n    </tbody>\n</table>\n\n{# Render the pager #}\n\n// highlight-next-line\n{{ rekapager(pager) }}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"batch-processing",children:"Batch Processing"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.code,{children:"PageableInterface"})," object can also be used for batch processing a large\namount of underlying data. The example below demonstrates how to do batch\nprocessing using Doctrine."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-php",children:"use Doctrine\\ORM\\EntityManagerInterface;\nuse Rekalogika\\Rekapager\\PageableInterface;\n\n/** @var PageableInterface $pageable */\n/** @var EntityManagerInterface $entityManager */\n\nforeach ($pageable->withItemsPerPage(1000)->getPages() as $page) {\n    foreach ($page as $item) {\n        // Do something with the item\n    }\n\n    // Do something after each page here\n    $entityManager->flush(); // if required\n    $entitymanager->clear();\n}\n"})})]})}function g(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>s});var t=a(6540);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);