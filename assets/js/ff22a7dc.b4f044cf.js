"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[5444],{693:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"analytics/internals/refresh","title":"Refresh Mechanism","description":"DirtyFlag","source":"@site/docs/analytics/99-internals/02-refresh.md","sourceDirName":"analytics/99-internals","slug":"/analytics/internals/refresh","permalink":"/analytics/internals/refresh","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/analytics/99-internals/02-refresh.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Refresh Mechanism"},"sidebar":"docs","previous":{"title":"Partitioning","permalink":"/analytics/internals/partitioning"},"next":{"title":"Current To-do List","permalink":"/analytics/internals/todo"}}');var i=t(4848),s=t(8453);const a={title:"Refresh Mechanism"},o=void 0,l={},c=[{value:"<code>DirtyFlag</code>",id:"dirtyflag",level:2},{value:"<code>SourceEntityListener</code>",id:"sourceentitylistener",level:2},{value:"<code>NewDirtyFlagListener</code>",id:"newdirtyflaglistener",level:2},{value:"Refresh Worker",id:"refresh-worker",level:2}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"dirtyflag",children:(0,i.jsx)(n.code,{children:"DirtyFlag"})}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"DirtyFlag"})," is an entity indicating a dirty partition, which is a partition in\na summary table that needs to be refreshed. ",(0,i.jsx)(n.code,{children:"DirtyFlag"})," should be persisted and\nflushed at the same time as the rest of the entities, during the ",(0,i.jsx)(n.code,{children:"onFlush"}),"\nevent. So if the flush fails, the flag will not be saved."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"DirtyFlag"})," can have null partition information. In this case, it means there\nare new persisted entities that need to be summarized. New entities need to be\nhandled differently because they are not guaranteed to have an ID before flush."]}),"\n",(0,i.jsx)(n.h2,{id:"sourceentitylistener",children:(0,i.jsx)(n.code,{children:"SourceEntityListener"})}),"\n",(0,i.jsxs)(n.p,{children:["Listens on Doctrine's ",(0,i.jsx)(n.code,{children:"onFlush"})," event. For every pending entities, it checks the\nchange set and determines if the change affects any summary tables. If a\nproperty is changed, and that would affect one or more summary tables, it\ncreates the corresponding ",(0,i.jsx)(n.code,{children:"DirtyFlag"})," objects for each of the partition that\nneeds to be refreshed."]}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"This automatic detection works only for simple cases: it only detects the change\nof the properties in the entity itself. If the change that would affect the\nsummary is in a related entity, the framework cannot detect that."})}),"\n",(0,i.jsxs)(n.p,{children:["At the end of a flush, the listener will dispatch a ",(0,i.jsx)(n.code,{children:"NewDirtyFlagEvent"})," event."]}),"\n",(0,i.jsx)(n.h2,{id:"newdirtyflaglistener",children:(0,i.jsx)(n.code,{children:"NewDirtyFlagListener"})}),"\n",(0,i.jsxs)(n.p,{children:["Listens on the ",(0,i.jsx)(n.code,{children:"NewDirtyFlagEvent"})," event. It calls\n",(0,i.jsx)(n.code,{children:"RefreshScheduler::scheduleWorker()"})," to schedule a worker to refresh the dirty\npartitions."]}),"\n",(0,i.jsx)(n.h2,{id:"refresh-worker",children:"Refresh Worker"}),"\n",(0,i.jsx)(n.p,{children:"The refresh worker is responsible for performing refresh at a specific time. Its\nobjectives:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Runs immediately if there is no contention."}),"\n",(0,i.jsx)(n.li,{children:"Runs only once within a given interval."}),"\n",(0,i.jsx)(n.li,{children:"Allows ad-hoc refreshes to take place."}),"\n",(0,i.jsx)(n.li,{children:"Anticipates long-running refreshes."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["There are 3 timing parameters used by the worker defined in ",(0,i.jsx)(n.code,{children:"RefreshClassProperties"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"startDelay"}),": The delay between the source change and the first worker run."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"interval"}),": The interval between runs."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"expectedMaximumProcessingTime"}),": The maximum time the worker is expected to\nrun."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Scheduler pseudocode:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$s = startDelay\n$i = interval\n$m = expectedMaximumProcessingTime\n\nacquire lock that expires at now() + $s + $m + 2 * $i\n\nif lock acquired:\n    schedule primary worker at now() + $s\n    do not release $lock\nelse:\n    raise flag\n"})}),"\n",(0,i.jsx)(n.p,{children:"Worker pseudocode:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"refresh lock to expire at now() + $m + 2 * $i\nremove flag\ndo the work\nrefresh lock to expire at now() + 2 * $i\nschedule secondary worker at now() + $i\n"})}),"\n",(0,i.jsx)(n.p,{children:"Secondary worker pseudocode:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"if flag is raised:\n    execute primary worker\nelse:\n    release lock\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);