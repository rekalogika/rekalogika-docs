"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[2735],{2735:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var a=n(5893),s=n(1151);const o={title:"Transactional Outbox Pattern"},r=void 0,i={id:"domain-event/transactional-outbox-pattern",title:"Transactional Outbox Pattern",description:"The package rekalogika/domain-event-outbox implements the transactional outbox",source:"@site/docs/domain-event/09-transactional-outbox-pattern.md",sourceDirName:"domain-event",slug:"/domain-event/transactional-outbox-pattern",permalink:"/domain-event/transactional-outbox-pattern",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/domain-event/09-transactional-outbox-pattern.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{title:"Transactional Outbox Pattern"},sidebar:"docs",previous:{title:"Testing",permalink:"/domain-event/testing"},next:{title:"Tips",permalink:"/domain-event/tips"}},h={},l=[{value:"How It Works",id:"how-it-works",level:2},{value:"Comparison with the Post-Flush Strategy",id:"comparison-with-the-post-flush-strategy",level:2},{value:"Message Preparer",id:"message-preparer",level:2}];function d(e){const t={code:"code",h2:"h2",p:"p",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["The package ",(0,a.jsx)(t.code,{children:"rekalogika/domain-event-outbox"})," implements the transactional outbox\npattern. It publishes the events as part of a database transaction by saving\nthem to the outbox table. This mechanism guarantees integrity and delivery."]}),"\n",(0,a.jsx)(t.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,a.jsxs)(t.p,{children:["During the same time as the pre-flush phase, for each of the domain events, the\nframework wraps the event in a Symfony Messenger ",(0,a.jsx)(t.code,{children:"Envelope"}),", and then in an\n",(0,a.jsx)(t.code,{children:"OutboxMessage"})," object. Then, it calls the entity manager to persist the\n",(0,a.jsx)(t.code,{children:"OutboxMessage"})," object."]}),"\n",(0,a.jsxs)(t.p,{children:["When ",(0,a.jsx)(t.code,{children:"flush()"})," or ",(0,a.jsx)(t.code,{children:"commit()"})," is finally called, Doctrine will save the\n",(0,a.jsx)(t.code,{children:"OutboxMessage"})," objects in the same transaction as the rest of the changes to\nthe domain entities. This guarantees that the events are published only if the\ntransaction is successful."]}),"\n",(0,a.jsxs)(t.p,{children:["At the end of the request, the framework dispatches ",(0,a.jsx)(t.code,{children:"MessageRelayStartMessage"}),".\nThis message is handled by ",(0,a.jsx)(t.code,{children:"MessageRelayStartMessageHandler"})," which runs the\n",(0,a.jsx)(t.code,{children:"MessageRelay"})," service. The ",(0,a.jsx)(t.code,{children:"MessageRelay"})," service reads the outbox table,\npublishes the events to the event bus, and removes the events from the outbox\ntable."]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"MessageRelay"})," service handles all the domain events, not just the ones that\nwere saved during the current request. If the relaying is unsuccessful, the\nevents left in the outbox will be retried on the next run. This guarantees that\nthe events will be delivered."]}),"\n",(0,a.jsx)(t.h2,{id:"comparison-with-the-post-flush-strategy",children:"Comparison with the Post-Flush Strategy"}),"\n",(0,a.jsx)(t.p,{children:"With the post-flush strategy, if an error happens during the dispatching, then\nthe event is lost."}),"\n",(0,a.jsx)(t.p,{children:"In contrast, the transactional outbox pattern guarantees that the event will be\ndelivered. If an error happens, both the events and the entire changes to the\ndomain model will not be committed to the database. Because all the other\nchanges are rolled back, the discarded events would have been invalid anyway,\nand should not be delivered."}),"\n",(0,a.jsx)(t.h2,{id:"message-preparer",children:"Message Preparer"}),"\n",(0,a.jsxs)(t.p,{children:["When the domain events are being saved to the outbox table, the message preparer\nservices are executed to prepare the events. By default, it adds the\n",(0,a.jsx)(t.code,{children:"UserIdentifierStamp"})," to the envelope. You can add your own message preparer by\nimplementing the ",(0,a.jsx)(t.code,{children:"MessagePreparerInterface"})," (tag name:\n",(0,a.jsx)(t.code,{children:"rekalogika.domain_event.outbox.message_preparer"}),")"]})]})}function c(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>r});var a=n(7294);const s={},o=a.createContext(s);function r(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);