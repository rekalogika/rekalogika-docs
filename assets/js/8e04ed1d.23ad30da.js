"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[6130],{9450:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"domain-event/equatable","title":"Equatable Domain Events","description":"A domain event can optionally implement EquatableDomainEventInterface which","source":"@site/docs/domain-event/04-equatable.md","sourceDirName":"domain-event","slug":"/domain-event/equatable","permalink":"/domain-event/equatable","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/domain-event/04-equatable.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Equatable Domain Events"},"sidebar":"docs","previous":{"title":"Pseudo Magic Method","permalink":"/domain-event/pseudo-magic-method"},"next":{"title":"Transactions","permalink":"/domain-event/transaction"}}');var i=t(4848),o=t(8453);const s={title:"Equatable Domain Events"},r=void 0,c={},d=[];function l(e){const n={admonition:"admonition",code:"code",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["A domain event can optionally implement ",(0,i.jsx)(n.code,{children:"EquatableDomainEventInterface"})," which\nrequires the method ",(0,i.jsx)(n.code,{children:"getSignature()"}),". Two objects with the same signature will\nbe considered identical and won't be dispatched twice."]}),"\n",(0,i.jsxs)(n.p,{children:["This is useful if your entity is working with a million of related objects. By\nimplementing ",(0,i.jsx)(n.code,{children:"EquatableDomainEventInterface"}),", you can have your ",(0,i.jsx)(n.code,{children:"ObjectChanged"}),"\nevent dispatched only once and occupy only a single spot in the memory,\ninstead of a million times."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Rekalogika\\Contracts\\DomainEvent\\EquatableDomainEventInterface;\n\nclass PostCommentAdded implements EquatableDomainEventInterface\n{\n    public function __construct(private string $postId)\n    {\n    }\n\n    public function getSignature(): string\n    {\n        return sha1(serialize($this));\n    }\n}\n\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterInterface;\nuse Rekalogika\\Contracts\\DomainEvent\\DomainEventEmitterTrait;\n\nclass Post implements DomainEventEmitterInterface\n{\n    use DomainEventEmitterTrait;\n\n    // ...\n\n    public function addComment(string $comment): Comment\n    {\n        // ...\n\n        // the PostCommentAdded event will only get dispatched once despite of\n        // addComment being called multiple times.\n        $this->recordEvent(new PostCommentAdded($this->id));\n    }\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"Equatable domain events only apply to where the events are spooled before they\nare processed. Immediate domain events are dispatched immediately, and there is\nno chance for the equatable check to take place."})}),"\n",(0,i.jsx)(n.admonition,{type:"warning",children:(0,i.jsx)(n.p,{children:"There is no guarantee that the event will be dispatched only once. Two events\nconsidered identical may have been recorded in two different phases, and never\nget grouped together."})})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var a=t(6540);const i={},o=a.createContext(i);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);