"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[4708],{9157:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});var i=t(5893),o=t(1151);const l={title:"ArrayCollection"},r=void 0,s={id:"collections/implementations/array-collection",title:"ArrayCollection",description:"Modification to Doctrine's ArrayCollection, so that it does matching()",source:"@site/docs/collections/02-implementations/04-array-collection.md",sourceDirName:"collections/02-implementations",slug:"/collections/implementations/array-collection",permalink:"/collections/implementations/array-collection",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/collections/02-implementations/04-array-collection.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"ArrayCollection"},sidebar:"docs",previous:{title:"Repository",permalink:"/collections/implementations/repository"},next:{title:"Behaviors",permalink:"/collections/behaviors/"}},a={},c=[{value:"Installation",id:"installation",level:2},{value:"Usage",id:"usage",level:2},{value:"Description",id:"description",level:2},{value:"Limitation",id:"limitation",level:2},{value:"Example",id:"example",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Modification to Doctrine's ",(0,i.jsx)(n.code,{children:"ArrayCollection"}),", so that it does ",(0,i.jsx)(n.code,{children:"matching()"}),"\nagainst the private properties directly, not against the return values of their\ngetters."]}),"\n",(0,i.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"composer require rekalogika/collections-domain\n"})}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsxs)(n.p,{children:["Simply substitute ",(0,i.jsx)(n.code,{children:"Doctrine\\Common\\Collections\\ArrayCollection"})," with\n",(0,i.jsx)(n.code,{children:"Rekalogika\\Domain\\Collections\\ArrayCollection"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-diff",children:"- use Doctrine\\Common\\Collections\\ArrayCollection;\n+ use Rekalogika\\Domain\\Collections\\ArrayCollection;\n"})}),"\n",(0,i.jsx)(n.p,{children:"It should be safe to do a mass find-and-replace in all of your entities."}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsxs)(n.p,{children:["Doctrine entities usually initialize a ",(0,i.jsx)(n.code,{children:"Collection"})," using ",(0,i.jsx)(n.code,{children:"ArrayCollection"})," in\ntheir constructors. But when the entity is hydrated from the database, Doctrine\nORM will inject a ",(0,i.jsx)(n.code,{children:"PersistentCollection"})," directly into the property."]}),"\n",(0,i.jsxs)(n.p,{children:["If we call ",(0,i.jsx)(n.code,{children:"matching()"})," against the ",(0,i.jsx)(n.code,{children:"PersistentCollection"}),", it will be done\nagainst the related entities' private properties directly. While\n",(0,i.jsx)(n.code,{children:"ArrayCollection"})," does it against the return values of the getters."]}),"\n",(0,i.jsx)(n.p,{children:"Therefore, there will be a 'mismatching' in the collection's behavior between\nwhen the owning entity is new and not yet persisted, and after it is hydrated\nfrom the database."}),"\n",(0,i.jsx)(n.p,{children:"The problem happens when, for example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The property does not have a getter, or"}),"\n",(0,i.jsx)(n.li,{children:"The getter returns a different value or different type from the property's\nvalue, or"}),"\n",(0,i.jsx)(n.li,{children:"The getter contains business logic, and does not return the property's value\nas is."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The problem usually happens with new, not-yet-persisted entities, and in unit\ntests where the tests don't involve the database."}),"\n",(0,i.jsxs)(n.p,{children:["Our ",(0,i.jsx)(n.code,{children:"ArrayCollection"})," changes the behavior so that it does the ",(0,i.jsx)(n.code,{children:"matching()"}),"\nagainst the private properties directly, so that both ",(0,i.jsx)(n.code,{children:"Collection"}),"s will have\nthe same behavior."]}),"\n",(0,i.jsx)(n.h2,{id:"limitation",children:"Limitation"}),"\n",(0,i.jsxs)(n.p,{children:["This problem will also happen when ",(0,i.jsx)(n.code,{children:"fetch"})," set to ",(0,i.jsx)(n.code,{children:"EAGER"}),", or when the\ncollection is initialized before the ",(0,i.jsx)(n.code,{children:"matching()"})," is called. Unfortunately, it\nis impossible to work around this problem outside Doctrine."]}),"\n",(0,i.jsxs)(n.p,{children:["However, if you can afford to fetch the collection eagerly, then you can afford\nto use ",(0,i.jsx)(n.code,{children:"filter()"})," instead. Unlike ",(0,i.jsx)(n.code,{children:"matching()"}),", ",(0,i.jsx)(n.code,{children:"filter()"})," is always consistent\nin every cases."]}),"\n",(0,i.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,i.jsxs)(n.p,{children:["The following classes implement the ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Null_object_pattern",children:"null object\npattern"}),". If the\n",(0,i.jsx)(n.code,{children:"nationality"})," property is ",(0,i.jsx)(n.code,{children:"null"}),", it will return an instance of ",(0,i.jsx)(n.code,{children:"Stateless"}),"\ninstead of ",(0,i.jsx)(n.code,{children:"null"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Common\\Collections\\ArrayCollection;\nuse Doctrine\\Common\\Collections\\Collection;\n\nclass Country {}\nclass Stateless extends Country {}\n\nclass Player\n{\n    public function __construct(\n        private string $name,\n        private Team $team,\n        private ?Country $nationality = null,\n    ) {\n    }\n\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    public function getTeam(): Team\n    {\n        return $this->team;\n    }\n\n    public function getNationality(): Country\n    {\n        return $this->country ?? new Stateless();\n    }\n}\n\nclass Team\n{\n    /** @var Collection<int,Player> */\n    private Collection $players;\n\n    public function __construct()\n    {\n        $this->players = new ArrayCollection();\n    }\n\n    /**\n     * @return Collection<int,Player>\n     */\n    public function getPlayers(): Collection\n    {\n        return $this->players;\n    }\n\n    public function getStatelessPlayers(): Collection\n    {\n        return $this->players->matching(\n            Criteria::create()\n                ->where(Criteria::expr()->isNull('nationality'))\n        );\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If the ",(0,i.jsx)(n.code,{children:"Team"})," is not yet persisted, the ",(0,i.jsx)(n.code,{children:"getStatelessPlayers()"})," method will\nincorrectly return an empty collection every time. But if the ",(0,i.jsx)(n.code,{children:"Team"})," object is\nhydrated from the database, it will correctly return the players without a\nnationality."]}),"\n",(0,i.jsxs)(n.p,{children:["Changing the code to use ",(0,i.jsx)(n.code,{children:"Rekalogika\\Domain\\Collections\\ArrayCollection"})," will\nresolve the problem."]})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>r});var i=t(7294);const o={},l=i.createContext(o);function r(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);