"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[7048],{5529:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"mapper/cache-prewarming","title":"Cache Pre-warming","description":"Mapper caches the results of expensive processing, so when it does the same","source":"@site/docs/mapper/17-cache-prewarming.md","sourceDirName":"mapper","slug":"/mapper/cache-prewarming","permalink":"/mapper/cache-prewarming","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/mapper/17-cache-prewarming.md","tags":[],"version":"current","sidebarPosition":17,"frontMatter":{"title":"Cache Pre-warming"},"sidebar":"docs","previous":{"title":"Debugging the Mapper","permalink":"/mapper/debugging"},"next":{"title":"Cookbook","permalink":"/mapper/cookbook/"}}');var i=a(4848),o=a(8453);const r={title:"Cache Pre-warming"},s=void 0,p={},c=[{value:"Pre-warming is Optional",id:"pre-warming-is-optional",level:2},{value:"When Pre-warming is Useful",id:"when-pre-warming-is-useful",level:2},{value:"How to Pre-warm the Cache",id:"how-to-pre-warm-the-cache",level:2},{value:"Using PHPStan to Automatically Generate the Mapping Collection",id:"using-phpstan-to-automatically-generate-the-mapping-collection",level:2}];function l(e){const n={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Mapper caches the results of expensive processing, so when it does the same\nmapping again, it can quickly refer to the cached result instead of doing the\nexpensive processing once more."}),"\n",(0,i.jsx)(n.p,{children:"Because this cache won't change during the lifetime of the application, it can\nmake sense to pre-warm the cache before deployment."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"This chapter is Symfony-specific."})}),"\n",(0,i.jsx)(n.h2,{id:"pre-warming-is-optional",children:"Pre-warming is Optional"}),"\n",(0,i.jsx)(n.p,{children:"First off, Mapper can work without pre-warming the cache. It will just take a\nbit longer to process the first mapping. In most deployments, it should not be\nnecessary to pre-warm the cache."}),"\n",(0,i.jsx)(n.h2,{id:"when-pre-warming-is-useful",children:"When Pre-warming is Useful"}),"\n",(0,i.jsx)(n.p,{children:"Very busy applications: Without pre-warming, a new deployment starts with an\nempty cache. With a busy application, it can result in a load spike, where many\nrequests come in at the same time, and each request tries to perform the same\nexpensive operation. By shipping the pre-warmed cache as part of the deployment\nimage, you can avoid this problem."}),"\n",(0,i.jsx)(n.p,{children:"Strict read-only deployments: Such systems might have no choice but to store the\ncache over the network, and pre-warming can help to reduce the overhead."}),"\n",(0,i.jsx)(n.h2,{id:"how-to-pre-warm-the-cache",children:"How to Pre-warm the Cache"}),"\n",(0,i.jsxs)(n.p,{children:["Mapper cannot possibly know beforehand which mapping you are going to do in the\napplication. So, you need to inform Mapper the list of the mappings. To do so,\nyou can create a mapping collection file and store it in the\n",(0,i.jsx)(n.code,{children:"config/rekalogika-mapper"})," directory, any filename is fine."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",metastring:'title="config/rekalogika-mapper/mappings.php"',children:"<?php\n\nuse Rekalogika\\Mapper\\CacheWarmer\\MappingCollection;\n\nreturn function (MappingCollection $mappingCollection) : void {\n    $mappingCollection->addObjectMapping(\n        source: SomeSourceClass::class,\n        target: SomeTargetClass::class\n    );\n\n    $mappingCollection->addObjectMapping(\n        source: OtherSourceClass::class,\n        target: OtherTargetClass::class\n    );\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then, the mapping cache will be pre-warmed as part of Symfony's cache\npre-warming process:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ APP_ENV=prod APP_DEBUG=0 php bin/console cache:clear\n"})}),"\n",(0,i.jsx)(n.h2,{id:"using-phpstan-to-automatically-generate-the-mapping-collection",children:"Using PHPStan to Automatically Generate the Mapping Collection"}),"\n",(0,i.jsx)(n.p,{children:"If you are using PHPStan, you can add the configuration below to your PHPStan\nconfiguration file, then PHPStan will automatically generate the mapping\ncollection in the specified file every time you run PHPStan."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",metastring:'title="phpstan.neon.dist"',children:"parameters:\n    rekalogika-mapper:\n        mapperDumpFile: config/rekalogika-mapper/generated-mappings.php\n\n# only required if you are not using phpstan/extension-installer:\nincludes:\n    - vendor/rekalogika/mapper/phpstan-extension.neon\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"The automatic PHPStan mapping generation is not foolproof. It cannot detect\nevery possible use cases. You might still need to add some of the mappings\nmanually."})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>s});var t=a(6540);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);