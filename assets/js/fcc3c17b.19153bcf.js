"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[5683],{5639:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"mapper/object/lazy-loading","title":"Lazy Loading","description":"Mapper will attempt to create a lazy-loading proxy for the target object, and","source":"@site/docs/mapper/02-object/04-lazy-loading.md","sourceDirName":"mapper/02-object","slug":"/mapper/object/lazy-loading","permalink":"/mapper/object/lazy-loading","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/mapper/02-object/04-lazy-loading.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Lazy Loading"},"sidebar":"docs","previous":{"title":"Custom Property Mapper","permalink":"/mapper/object/custom-property-mapper"},"next":{"title":"Dynamic Properties & Property Overloading","permalink":"/mapper/object/dynamic-properties"}}');var o=n(4848),a=n(8453);const r={title:"Lazy Loading"},s=void 0,l={},d=[{value:"Mapping to Doctrine Entities",id:"mapping-to-doctrine-entities",level:2},{value:"API Platform",id:"api-platform",level:2},{value:"Eager Properties",id:"eager-properties",level:2},{value:"Disabling Lazy-Loading",id:"disabling-lazy-loading",level:2},{value:"Using <code>MapperOptions</code>",id:"using-mapperoptions",level:3},{value:"Using <code>Eager</code> Attribute",id:"using-eager-attribute",level:3},{value:"Other Ways of Disabling Lazy-Loading",id:"other-ways-of-disabling-lazy-loading",level:3}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Mapper will attempt to create a lazy-loading proxy for the target object, and\nuse it in place of the real object. The benefit is that the target object will\nnot be hydrated until it is actually used."}),"\n",(0,o.jsx)(t.p,{children:"If the source object is a Doctrine entity, the mapping will not trigger the\nhydration of the source; even accessing ID properties on the target will also\nnot trigger the hydration. Only after accessing other properties of the target\nwill the hydration take place."}),"\n",(0,o.jsx)(t.admonition,{type:"warning",children:(0,o.jsxs)(t.p,{children:["If the target is ",(0,o.jsx)(t.code,{children:"final"}),", then lazy-loading will not be possible. There are also\nother cases that can prevent a lazy-loading proxy from being created. To see if\na proxy is being used, or the reason why it is not, you can see that in the\nMapper panel in the Symfony profiler."]})}),"\n",(0,o.jsx)(t.h2,{id:"mapping-to-doctrine-entities",children:"Mapping to Doctrine Entities"}),"\n",(0,o.jsxs)(t.p,{children:["Doctrine reads properties using ",(0,o.jsx)(t.code,{children:"Reflection"})," directly, and therefore will not\ntrigger the hydration of our proxy objects. To prevent problems while working\nwith Doctrine entities, Mapper will prevent proxy creation if the target is a\nDoctrine entity."]}),"\n",(0,o.jsx)(t.h2,{id:"api-platform",children:"API Platform"}),"\n",(0,o.jsxs)(t.p,{children:["With API Platform, if you are using DTOs as ",(0,o.jsx)(t.code,{children:"ApiResource"}),", then API Platform\nshould be able to generate IRIs without causing the hydration of the source (if\nthe source is a Doctrine entity). The only thing you need to do is to ensure\nthe source (a Doctrine entity) and the target (an ",(0,o.jsx)(t.code,{children:"ApiResource"})," DTO) both use\nthe same identifier property name. Or better: just use ",(0,o.jsx)(t.code,{children:"id"})," as the identifier\neverywhere, and be done with it."]}),"\n",(0,o.jsx)(t.p,{children:"Without lazy-loading, API Platform will hydrate everything in the object graph,\neven when it only needs to generate an IRI."}),"\n",(0,o.jsx)(t.admonition,{title:"Shameless Plug",type:"info",children:(0,o.jsxs)(t.p,{children:["Read the documentation of ",(0,o.jsx)(t.a,{href:"/api-lite",children:"api-lite"})," to know more about how we\nutilize Mapper with API Platform."]})}),"\n",(0,o.jsx)(t.h2,{id:"eager-properties",children:"Eager Properties"}),"\n",(0,o.jsxs)(t.p,{children:["During the mapping, Mapper will try to identify the identifier properties on the\nsource side. First, it looks for the information in Doctrine's class metadata.\nIf not found, it will use ",(0,o.jsx)(t.code,{children:"id"}),", ",(0,o.jsx)(t.code,{children:"uuid"}),", or ",(0,o.jsx)(t.code,{children:"identifier"})," if any of those exists\non the source side."]}),"\n",(0,o.jsx)(t.p,{children:"These identifier properties will not be lazy, and will be mapped immediately\nafter the instantiation of the target proxy object. This should not cause the\nhydration of the source side because a Doctrine proxy already hold the\nidentifier, even when uninitialized."}),"\n",(0,o.jsxs)(t.p,{children:["If your application needs to have a custom logic for determining the identifier\nfields, you can create a service implementing\n",(0,o.jsx)(t.code,{children:"EagerPropertiesResolverInterface"}),"."]}),"\n",(0,o.jsx)(t.admonition,{type:"info",children:(0,o.jsx)(t.p,{children:"If an identifier property maps to a constructor argument on the target side,\nthen everything in the constructor will be mapped eagerly."})}),"\n",(0,o.jsx)(t.h2,{id:"disabling-lazy-loading",children:"Disabling Lazy-Loading"}),"\n",(0,o.jsx)(t.p,{children:"There should be no downside to using a lazy-loading proxy in place of the real\nobject. In most cases, they should be interchangeable. However, a proxy incurs a\nsmall overhead, and you may wish to disable it in some cases, for example if you\nare using the Mapper in a batch process."}),"\n",(0,o.jsxs)(t.h3,{id:"using-mapperoptions",children:["Using ",(0,o.jsx)(t.code,{children:"MapperOptions"})]}),"\n",(0,o.jsxs)(t.p,{children:["If you want to disable lazy-loading for a mapping run, you can set the option\n",(0,o.jsx)(t.code,{children:"enableLazyLoading"})," to false in the ",(0,o.jsx)(t.code,{children:"MapperOptions"})," object, and add it to the\ncontext:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-php",children:"use Rekalogika\\Mapper\\Context\\Context;\nuse Rekalogika\\Mapper\\Context\\MapperOptions;\n\n$options = new MapperOptions(lazyLoading: false);\n$context = Context::create($options);\n\n$target = $this->mapper->map($source, TargetDto::class, $context);\n"})}),"\n",(0,o.jsxs)(t.h3,{id:"using-eager-attribute",children:["Using ",(0,o.jsx)(t.code,{children:"Eager"})," Attribute"]}),"\n",(0,o.jsxs)(t.p,{children:["To disable proxy creation for a specific class, add the ",(0,o.jsx)(t.code,{children:"#[Eager]"})," attribute to\nthe target class:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-php",children:"use Rekalogika\\Mapper\\Attribute\\Eager;\n\n#[Eager]\nclass TargetDto\n{\n    // ...\n}\n"})}),"\n",(0,o.jsx)(t.h3,{id:"other-ways-of-disabling-lazy-loading",children:"Other Ways of Disabling Lazy-Loading"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["Currently, if the target is ",(0,o.jsx)(t.code,{children:"final"}),", then it will not use a proxy. But in\nfuture versions of PHP, final objects might be finally allowed to be proxied."]}),"\n",(0,o.jsx)(t.li,{children:"You can instantiate manually, and pass the object as the mapper's target."}),"\n",(0,o.jsxs)(t.li,{children:["You can decorate ",(0,o.jsx)(t.code,{children:"ProxyGeneratorInterface"}),", and throw\n",(0,o.jsx)(t.code,{children:"ProxyNotSupportedException"})," if it asks for your specific class. Read\n",(0,o.jsx)(t.code,{children:"DoctrineProxyGenerator"})," for an example."]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var i=n(6540);const o={},a=i.createContext(o);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);